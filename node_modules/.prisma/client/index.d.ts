
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model Indicator
 * 
 */
export type Indicator = $Result.DefaultSelection<Prisma.$IndicatorPayload>
/**
 * Model ThreatEntity
 * 
 */
export type ThreatEntity = $Result.DefaultSelection<Prisma.$ThreatEntityPayload>
/**
 * Model IndicatorThreat
 * 
 */
export type IndicatorThreat = $Result.DefaultSelection<Prisma.$IndicatorThreatPayload>
/**
 * Model OT_Event
 * 
 */
export type OT_Event = $Result.DefaultSelection<Prisma.$OT_EventPayload>
/**
 * Model Sighting
 * 
 */
export type Sighting = $Result.DefaultSelection<Prisma.$SightingPayload>
/**
 * Model Case
 * 
 */
export type Case = $Result.DefaultSelection<Prisma.$CasePayload>
/**
 * Model Evidence
 * 
 */
export type Evidence = $Result.DefaultSelection<Prisma.$EvidencePayload>
/**
 * Model Custody
 * 
 */
export type Custody = $Result.DefaultSelection<Prisma.$CustodyPayload>
/**
 * Model AttackScenario
 * 
 */
export type AttackScenario = $Result.DefaultSelection<Prisma.$AttackScenarioPayload>
/**
 * Model AttackRun
 * 
 */
export type AttackRun = $Result.DefaultSelection<Prisma.$AttackRunPayload>
/**
 * Model AttackResult
 * 
 */
export type AttackResult = $Result.DefaultSelection<Prisma.$AttackResultPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.indicator`: Exposes CRUD operations for the **Indicator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Indicators
    * const indicators = await prisma.indicator.findMany()
    * ```
    */
  get indicator(): Prisma.IndicatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threatEntity`: Exposes CRUD operations for the **ThreatEntity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThreatEntities
    * const threatEntities = await prisma.threatEntity.findMany()
    * ```
    */
  get threatEntity(): Prisma.ThreatEntityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.indicatorThreat`: Exposes CRUD operations for the **IndicatorThreat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndicatorThreats
    * const indicatorThreats = await prisma.indicatorThreat.findMany()
    * ```
    */
  get indicatorThreat(): Prisma.IndicatorThreatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oT_Event`: Exposes CRUD operations for the **OT_Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OT_Events
    * const oT_Events = await prisma.oT_Event.findMany()
    * ```
    */
  get oT_Event(): Prisma.OT_EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sighting`: Exposes CRUD operations for the **Sighting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sightings
    * const sightings = await prisma.sighting.findMany()
    * ```
    */
  get sighting(): Prisma.SightingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.case`: Exposes CRUD operations for the **Case** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cases
    * const cases = await prisma.case.findMany()
    * ```
    */
  get case(): Prisma.CaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evidence`: Exposes CRUD operations for the **Evidence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evidences
    * const evidences = await prisma.evidence.findMany()
    * ```
    */
  get evidence(): Prisma.EvidenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.custody`: Exposes CRUD operations for the **Custody** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Custodies
    * const custodies = await prisma.custody.findMany()
    * ```
    */
  get custody(): Prisma.CustodyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attackScenario`: Exposes CRUD operations for the **AttackScenario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttackScenarios
    * const attackScenarios = await prisma.attackScenario.findMany()
    * ```
    */
  get attackScenario(): Prisma.AttackScenarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attackRun`: Exposes CRUD operations for the **AttackRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttackRuns
    * const attackRuns = await prisma.attackRun.findMany()
    * ```
    */
  get attackRun(): Prisma.AttackRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attackResult`: Exposes CRUD operations for the **AttackResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttackResults
    * const attackResults = await prisma.attackResult.findMany()
    * ```
    */
  get attackResult(): Prisma.AttackResultDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Asset: 'Asset',
    Indicator: 'Indicator',
    ThreatEntity: 'ThreatEntity',
    IndicatorThreat: 'IndicatorThreat',
    OT_Event: 'OT_Event',
    Sighting: 'Sighting',
    Case: 'Case',
    Evidence: 'Evidence',
    Custody: 'Custody',
    AttackScenario: 'AttackScenario',
    AttackRun: 'AttackRun',
    AttackResult: 'AttackResult'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "asset" | "indicator" | "threatEntity" | "indicatorThreat" | "oT_Event" | "sighting" | "case" | "evidence" | "custody" | "attackScenario" | "attackRun" | "attackResult"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      Indicator: {
        payload: Prisma.$IndicatorPayload<ExtArgs>
        fields: Prisma.IndicatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          findFirst: {
            args: Prisma.IndicatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          findMany: {
            args: Prisma.IndicatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>[]
          }
          create: {
            args: Prisma.IndicatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          createMany: {
            args: Prisma.IndicatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>[]
          }
          delete: {
            args: Prisma.IndicatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          update: {
            args: Prisma.IndicatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          deleteMany: {
            args: Prisma.IndicatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IndicatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>[]
          }
          upsert: {
            args: Prisma.IndicatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          aggregate: {
            args: Prisma.IndicatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicator>
          }
          groupBy: {
            args: Prisma.IndicatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicatorCountArgs<ExtArgs>
            result: $Utils.Optional<IndicatorCountAggregateOutputType> | number
          }
        }
      }
      ThreatEntity: {
        payload: Prisma.$ThreatEntityPayload<ExtArgs>
        fields: Prisma.ThreatEntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThreatEntityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThreatEntityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEntityPayload>
          }
          findFirst: {
            args: Prisma.ThreatEntityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThreatEntityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEntityPayload>
          }
          findMany: {
            args: Prisma.ThreatEntityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEntityPayload>[]
          }
          create: {
            args: Prisma.ThreatEntityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEntityPayload>
          }
          createMany: {
            args: Prisma.ThreatEntityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThreatEntityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEntityPayload>[]
          }
          delete: {
            args: Prisma.ThreatEntityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEntityPayload>
          }
          update: {
            args: Prisma.ThreatEntityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEntityPayload>
          }
          deleteMany: {
            args: Prisma.ThreatEntityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThreatEntityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ThreatEntityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEntityPayload>[]
          }
          upsert: {
            args: Prisma.ThreatEntityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEntityPayload>
          }
          aggregate: {
            args: Prisma.ThreatEntityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThreatEntity>
          }
          groupBy: {
            args: Prisma.ThreatEntityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThreatEntityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThreatEntityCountArgs<ExtArgs>
            result: $Utils.Optional<ThreatEntityCountAggregateOutputType> | number
          }
        }
      }
      IndicatorThreat: {
        payload: Prisma.$IndicatorThreatPayload<ExtArgs>
        fields: Prisma.IndicatorThreatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicatorThreatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorThreatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicatorThreatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorThreatPayload>
          }
          findFirst: {
            args: Prisma.IndicatorThreatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorThreatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicatorThreatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorThreatPayload>
          }
          findMany: {
            args: Prisma.IndicatorThreatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorThreatPayload>[]
          }
          create: {
            args: Prisma.IndicatorThreatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorThreatPayload>
          }
          createMany: {
            args: Prisma.IndicatorThreatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicatorThreatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorThreatPayload>[]
          }
          delete: {
            args: Prisma.IndicatorThreatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorThreatPayload>
          }
          update: {
            args: Prisma.IndicatorThreatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorThreatPayload>
          }
          deleteMany: {
            args: Prisma.IndicatorThreatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicatorThreatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IndicatorThreatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorThreatPayload>[]
          }
          upsert: {
            args: Prisma.IndicatorThreatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorThreatPayload>
          }
          aggregate: {
            args: Prisma.IndicatorThreatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicatorThreat>
          }
          groupBy: {
            args: Prisma.IndicatorThreatGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicatorThreatGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicatorThreatCountArgs<ExtArgs>
            result: $Utils.Optional<IndicatorThreatCountAggregateOutputType> | number
          }
        }
      }
      OT_Event: {
        payload: Prisma.$OT_EventPayload<ExtArgs>
        fields: Prisma.OT_EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OT_EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OT_EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OT_EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OT_EventPayload>
          }
          findFirst: {
            args: Prisma.OT_EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OT_EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OT_EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OT_EventPayload>
          }
          findMany: {
            args: Prisma.OT_EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OT_EventPayload>[]
          }
          create: {
            args: Prisma.OT_EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OT_EventPayload>
          }
          createMany: {
            args: Prisma.OT_EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OT_EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OT_EventPayload>[]
          }
          delete: {
            args: Prisma.OT_EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OT_EventPayload>
          }
          update: {
            args: Prisma.OT_EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OT_EventPayload>
          }
          deleteMany: {
            args: Prisma.OT_EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OT_EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OT_EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OT_EventPayload>[]
          }
          upsert: {
            args: Prisma.OT_EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OT_EventPayload>
          }
          aggregate: {
            args: Prisma.OT_EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOT_Event>
          }
          groupBy: {
            args: Prisma.OT_EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<OT_EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.OT_EventCountArgs<ExtArgs>
            result: $Utils.Optional<OT_EventCountAggregateOutputType> | number
          }
        }
      }
      Sighting: {
        payload: Prisma.$SightingPayload<ExtArgs>
        fields: Prisma.SightingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SightingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SightingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SightingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SightingPayload>
          }
          findFirst: {
            args: Prisma.SightingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SightingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SightingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SightingPayload>
          }
          findMany: {
            args: Prisma.SightingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SightingPayload>[]
          }
          create: {
            args: Prisma.SightingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SightingPayload>
          }
          createMany: {
            args: Prisma.SightingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SightingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SightingPayload>[]
          }
          delete: {
            args: Prisma.SightingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SightingPayload>
          }
          update: {
            args: Prisma.SightingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SightingPayload>
          }
          deleteMany: {
            args: Prisma.SightingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SightingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SightingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SightingPayload>[]
          }
          upsert: {
            args: Prisma.SightingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SightingPayload>
          }
          aggregate: {
            args: Prisma.SightingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSighting>
          }
          groupBy: {
            args: Prisma.SightingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SightingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SightingCountArgs<ExtArgs>
            result: $Utils.Optional<SightingCountAggregateOutputType> | number
          }
        }
      }
      Case: {
        payload: Prisma.$CasePayload<ExtArgs>
        fields: Prisma.CaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          findFirst: {
            args: Prisma.CaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          findMany: {
            args: Prisma.CaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>[]
          }
          create: {
            args: Prisma.CaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          createMany: {
            args: Prisma.CaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>[]
          }
          delete: {
            args: Prisma.CaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          update: {
            args: Prisma.CaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          deleteMany: {
            args: Prisma.CaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>[]
          }
          upsert: {
            args: Prisma.CaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          aggregate: {
            args: Prisma.CaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCase>
          }
          groupBy: {
            args: Prisma.CaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseCountArgs<ExtArgs>
            result: $Utils.Optional<CaseCountAggregateOutputType> | number
          }
        }
      }
      Evidence: {
        payload: Prisma.$EvidencePayload<ExtArgs>
        fields: Prisma.EvidenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvidenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvidenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          findFirst: {
            args: Prisma.EvidenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvidenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          findMany: {
            args: Prisma.EvidenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[]
          }
          create: {
            args: Prisma.EvidenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          createMany: {
            args: Prisma.EvidenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvidenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[]
          }
          delete: {
            args: Prisma.EvidenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          update: {
            args: Prisma.EvidenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          deleteMany: {
            args: Prisma.EvidenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvidenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvidenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[]
          }
          upsert: {
            args: Prisma.EvidenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          aggregate: {
            args: Prisma.EvidenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvidence>
          }
          groupBy: {
            args: Prisma.EvidenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvidenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvidenceCountArgs<ExtArgs>
            result: $Utils.Optional<EvidenceCountAggregateOutputType> | number
          }
        }
      }
      Custody: {
        payload: Prisma.$CustodyPayload<ExtArgs>
        fields: Prisma.CustodyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustodyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustodyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustodyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustodyPayload>
          }
          findFirst: {
            args: Prisma.CustodyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustodyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustodyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustodyPayload>
          }
          findMany: {
            args: Prisma.CustodyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustodyPayload>[]
          }
          create: {
            args: Prisma.CustodyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustodyPayload>
          }
          createMany: {
            args: Prisma.CustodyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustodyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustodyPayload>[]
          }
          delete: {
            args: Prisma.CustodyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustodyPayload>
          }
          update: {
            args: Prisma.CustodyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustodyPayload>
          }
          deleteMany: {
            args: Prisma.CustodyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustodyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustodyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustodyPayload>[]
          }
          upsert: {
            args: Prisma.CustodyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustodyPayload>
          }
          aggregate: {
            args: Prisma.CustodyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustody>
          }
          groupBy: {
            args: Prisma.CustodyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustodyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustodyCountArgs<ExtArgs>
            result: $Utils.Optional<CustodyCountAggregateOutputType> | number
          }
        }
      }
      AttackScenario: {
        payload: Prisma.$AttackScenarioPayload<ExtArgs>
        fields: Prisma.AttackScenarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttackScenarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackScenarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttackScenarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackScenarioPayload>
          }
          findFirst: {
            args: Prisma.AttackScenarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackScenarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttackScenarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackScenarioPayload>
          }
          findMany: {
            args: Prisma.AttackScenarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackScenarioPayload>[]
          }
          create: {
            args: Prisma.AttackScenarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackScenarioPayload>
          }
          createMany: {
            args: Prisma.AttackScenarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttackScenarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackScenarioPayload>[]
          }
          delete: {
            args: Prisma.AttackScenarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackScenarioPayload>
          }
          update: {
            args: Prisma.AttackScenarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackScenarioPayload>
          }
          deleteMany: {
            args: Prisma.AttackScenarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttackScenarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttackScenarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackScenarioPayload>[]
          }
          upsert: {
            args: Prisma.AttackScenarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackScenarioPayload>
          }
          aggregate: {
            args: Prisma.AttackScenarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttackScenario>
          }
          groupBy: {
            args: Prisma.AttackScenarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttackScenarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttackScenarioCountArgs<ExtArgs>
            result: $Utils.Optional<AttackScenarioCountAggregateOutputType> | number
          }
        }
      }
      AttackRun: {
        payload: Prisma.$AttackRunPayload<ExtArgs>
        fields: Prisma.AttackRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttackRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttackRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackRunPayload>
          }
          findFirst: {
            args: Prisma.AttackRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttackRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackRunPayload>
          }
          findMany: {
            args: Prisma.AttackRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackRunPayload>[]
          }
          create: {
            args: Prisma.AttackRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackRunPayload>
          }
          createMany: {
            args: Prisma.AttackRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttackRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackRunPayload>[]
          }
          delete: {
            args: Prisma.AttackRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackRunPayload>
          }
          update: {
            args: Prisma.AttackRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackRunPayload>
          }
          deleteMany: {
            args: Prisma.AttackRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttackRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttackRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackRunPayload>[]
          }
          upsert: {
            args: Prisma.AttackRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackRunPayload>
          }
          aggregate: {
            args: Prisma.AttackRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttackRun>
          }
          groupBy: {
            args: Prisma.AttackRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttackRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttackRunCountArgs<ExtArgs>
            result: $Utils.Optional<AttackRunCountAggregateOutputType> | number
          }
        }
      }
      AttackResult: {
        payload: Prisma.$AttackResultPayload<ExtArgs>
        fields: Prisma.AttackResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttackResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttackResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackResultPayload>
          }
          findFirst: {
            args: Prisma.AttackResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttackResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackResultPayload>
          }
          findMany: {
            args: Prisma.AttackResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackResultPayload>[]
          }
          create: {
            args: Prisma.AttackResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackResultPayload>
          }
          createMany: {
            args: Prisma.AttackResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttackResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackResultPayload>[]
          }
          delete: {
            args: Prisma.AttackResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackResultPayload>
          }
          update: {
            args: Prisma.AttackResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackResultPayload>
          }
          deleteMany: {
            args: Prisma.AttackResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttackResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttackResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackResultPayload>[]
          }
          upsert: {
            args: Prisma.AttackResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttackResultPayload>
          }
          aggregate: {
            args: Prisma.AttackResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttackResult>
          }
          groupBy: {
            args: Prisma.AttackResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttackResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttackResultCountArgs<ExtArgs>
            result: $Utils.Optional<AttackResultCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    asset?: AssetOmit
    indicator?: IndicatorOmit
    threatEntity?: ThreatEntityOmit
    indicatorThreat?: IndicatorThreatOmit
    oT_Event?: OT_EventOmit
    sighting?: SightingOmit
    case?: CaseOmit
    evidence?: EvidenceOmit
    custody?: CustodyOmit
    attackScenario?: AttackScenarioOmit
    attackRun?: AttackRunOmit
    attackResult?: AttackResultOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    attackRuns: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attackRuns?: boolean | UserCountOutputTypeCountAttackRunsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttackRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttackRunWhereInput
  }


  /**
   * Count Type AssetCountOutputType
   */

  export type AssetCountOutputType = {
    events: number
    sightings: number
    attackRuns: number
  }

  export type AssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | AssetCountOutputTypeCountEventsArgs
    sightings?: boolean | AssetCountOutputTypeCountSightingsArgs
    attackRuns?: boolean | AssetCountOutputTypeCountAttackRunsArgs
  }

  // Custom InputTypes
  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCountOutputType
     */
    select?: AssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OT_EventWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountSightingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SightingWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountAttackRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttackRunWhereInput
  }


  /**
   * Count Type IndicatorCountOutputType
   */

  export type IndicatorCountOutputType = {
    sightings: number
    threats: number
  }

  export type IndicatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sightings?: boolean | IndicatorCountOutputTypeCountSightingsArgs
    threats?: boolean | IndicatorCountOutputTypeCountThreatsArgs
  }

  // Custom InputTypes
  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCountOutputType
     */
    select?: IndicatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeCountSightingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SightingWhereInput
  }

  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeCountThreatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorThreatWhereInput
  }


  /**
   * Count Type ThreatEntityCountOutputType
   */

  export type ThreatEntityCountOutputType = {
    indicators: number
  }

  export type ThreatEntityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicators?: boolean | ThreatEntityCountOutputTypeCountIndicatorsArgs
  }

  // Custom InputTypes
  /**
   * ThreatEntityCountOutputType without action
   */
  export type ThreatEntityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntityCountOutputType
     */
    select?: ThreatEntityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ThreatEntityCountOutputType without action
   */
  export type ThreatEntityCountOutputTypeCountIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorThreatWhereInput
  }


  /**
   * Count Type CaseCountOutputType
   */

  export type CaseCountOutputType = {
    evidencias: number
  }

  export type CaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidencias?: boolean | CaseCountOutputTypeCountEvidenciasArgs
  }

  // Custom InputTypes
  /**
   * CaseCountOutputType without action
   */
  export type CaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseCountOutputType
     */
    select?: CaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CaseCountOutputType without action
   */
  export type CaseCountOutputTypeCountEvidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceWhereInput
  }


  /**
   * Count Type EvidenceCountOutputType
   */

  export type EvidenceCountOutputType = {
    custodies: number
  }

  export type EvidenceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    custodies?: boolean | EvidenceCountOutputTypeCountCustodiesArgs
  }

  // Custom InputTypes
  /**
   * EvidenceCountOutputType without action
   */
  export type EvidenceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceCountOutputType
     */
    select?: EvidenceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvidenceCountOutputType without action
   */
  export type EvidenceCountOutputTypeCountCustodiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustodyWhereInput
  }


  /**
   * Count Type AttackScenarioCountOutputType
   */

  export type AttackScenarioCountOutputType = {
    runs: number
  }

  export type AttackScenarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runs?: boolean | AttackScenarioCountOutputTypeCountRunsArgs
  }

  // Custom InputTypes
  /**
   * AttackScenarioCountOutputType without action
   */
  export type AttackScenarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenarioCountOutputType
     */
    select?: AttackScenarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttackScenarioCountOutputType without action
   */
  export type AttackScenarioCountOutputTypeCountRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttackRunWhereInput
  }


  /**
   * Count Type AttackRunCountOutputType
   */

  export type AttackRunCountOutputType = {
    results: number
  }

  export type AttackRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | AttackRunCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * AttackRunCountOutputType without action
   */
  export type AttackRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRunCountOutputType
     */
    select?: AttackRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttackRunCountOutputType without action
   */
  export type AttackRunCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttackResultWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    papel: string | null
    senhaHash: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    papel: string | null
    senhaHash: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    papel: number
    senhaHash: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    papel?: true
    senhaHash?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    papel?: true
    senhaHash?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    papel?: true
    senhaHash?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    nome: string
    email: string
    papel: string
    senhaHash: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    papel?: boolean
    senhaHash?: boolean
    attackRuns?: boolean | User$attackRunsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    papel?: boolean
    senhaHash?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    papel?: boolean
    senhaHash?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    papel?: boolean
    senhaHash?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "email" | "papel" | "senhaHash", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attackRuns?: boolean | User$attackRunsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      attackRuns: Prisma.$AttackRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      email: string
      papel: string
      senhaHash: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attackRuns<T extends User$attackRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$attackRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly nome: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly papel: FieldRef<"User", 'String'>
    readonly senhaHash: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.attackRuns
   */
  export type User$attackRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    where?: AttackRunWhereInput
    orderBy?: AttackRunOrderByWithRelationInput | AttackRunOrderByWithRelationInput[]
    cursor?: AttackRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttackRunScalarFieldEnum | AttackRunScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    criticidade: number | null
  }

  export type AssetSumAggregateOutputType = {
    criticidade: number | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    nome: string | null
    tipo: string | null
    fabricante: string | null
    modelo: string | null
    ip: string | null
    zona: string | null
    criticidade: number | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    tipo: string | null
    fabricante: string | null
    modelo: string | null
    ip: string | null
    zona: string | null
    criticidade: number | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    nome: number
    tipo: number
    fabricante: number
    modelo: number
    ip: number
    zona: number
    criticidade: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    criticidade?: true
  }

  export type AssetSumAggregateInputType = {
    criticidade?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    nome?: true
    tipo?: true
    fabricante?: true
    modelo?: true
    ip?: true
    zona?: true
    criticidade?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    nome?: true
    tipo?: true
    fabricante?: true
    modelo?: true
    ip?: true
    zona?: true
    criticidade?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    nome?: true
    tipo?: true
    fabricante?: true
    modelo?: true
    ip?: true
    zona?: true
    criticidade?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    nome: string
    tipo: string
    fabricante: string | null
    modelo: string | null
    ip: string | null
    zona: string | null
    criticidade: number | null
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    tipo?: boolean
    fabricante?: boolean
    modelo?: boolean
    ip?: boolean
    zona?: boolean
    criticidade?: boolean
    events?: boolean | Asset$eventsArgs<ExtArgs>
    sightings?: boolean | Asset$sightingsArgs<ExtArgs>
    attackRuns?: boolean | Asset$attackRunsArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    tipo?: boolean
    fabricante?: boolean
    modelo?: boolean
    ip?: boolean
    zona?: boolean
    criticidade?: boolean
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    tipo?: boolean
    fabricante?: boolean
    modelo?: boolean
    ip?: boolean
    zona?: boolean
    criticidade?: boolean
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    nome?: boolean
    tipo?: boolean
    fabricante?: boolean
    modelo?: boolean
    ip?: boolean
    zona?: boolean
    criticidade?: boolean
  }

  export type AssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "tipo" | "fabricante" | "modelo" | "ip" | "zona" | "criticidade", ExtArgs["result"]["asset"]>
  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | Asset$eventsArgs<ExtArgs>
    sightings?: boolean | Asset$sightingsArgs<ExtArgs>
    attackRuns?: boolean | Asset$attackRunsArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      events: Prisma.$OT_EventPayload<ExtArgs>[]
      sightings: Prisma.$SightingPayload<ExtArgs>[]
      attackRuns: Prisma.$AttackRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      tipo: string
      fabricante: string | null
      modelo: string | null
      ip: string | null
      zona: string | null
      criticidade: number | null
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets and returns the data updated in the database.
     * @param {AssetUpdateManyAndReturnArgs} args - Arguments to update many Assets.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    events<T extends Asset$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Asset$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sightings<T extends Asset$sightingsArgs<ExtArgs> = {}>(args?: Subset<T, Asset$sightingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attackRuns<T extends Asset$attackRunsArgs<ExtArgs> = {}>(args?: Subset<T, Asset$attackRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly nome: FieldRef<"Asset", 'String'>
    readonly tipo: FieldRef<"Asset", 'String'>
    readonly fabricante: FieldRef<"Asset", 'String'>
    readonly modelo: FieldRef<"Asset", 'String'>
    readonly ip: FieldRef<"Asset", 'String'>
    readonly zona: FieldRef<"Asset", 'String'>
    readonly criticidade: FieldRef<"Asset", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
  }

  /**
   * Asset updateManyAndReturn
   */
  export type AssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to delete.
     */
    limit?: number
  }

  /**
   * Asset.events
   */
  export type Asset$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventInclude<ExtArgs> | null
    where?: OT_EventWhereInput
    orderBy?: OT_EventOrderByWithRelationInput | OT_EventOrderByWithRelationInput[]
    cursor?: OT_EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OT_EventScalarFieldEnum | OT_EventScalarFieldEnum[]
  }

  /**
   * Asset.sightings
   */
  export type Asset$sightingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
    where?: SightingWhereInput
    orderBy?: SightingOrderByWithRelationInput | SightingOrderByWithRelationInput[]
    cursor?: SightingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SightingScalarFieldEnum | SightingScalarFieldEnum[]
  }

  /**
   * Asset.attackRuns
   */
  export type Asset$attackRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    where?: AttackRunWhereInput
    orderBy?: AttackRunOrderByWithRelationInput | AttackRunOrderByWithRelationInput[]
    cursor?: AttackRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttackRunScalarFieldEnum | AttackRunScalarFieldEnum[]
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model Indicator
   */

  export type AggregateIndicator = {
    _count: IndicatorCountAggregateOutputType | null
    _avg: IndicatorAvgAggregateOutputType | null
    _sum: IndicatorSumAggregateOutputType | null
    _min: IndicatorMinAggregateOutputType | null
    _max: IndicatorMaxAggregateOutputType | null
  }

  export type IndicatorAvgAggregateOutputType = {
    severidade: number | null
  }

  export type IndicatorSumAggregateOutputType = {
    severidade: number | null
  }

  export type IndicatorMinAggregateOutputType = {
    id: string | null
    tipo: string | null
    pattern: string | null
    severidade: number | null
    fonte: string | null
    validadeInicio: Date | null
    validadeFim: Date | null
  }

  export type IndicatorMaxAggregateOutputType = {
    id: string | null
    tipo: string | null
    pattern: string | null
    severidade: number | null
    fonte: string | null
    validadeInicio: Date | null
    validadeFim: Date | null
  }

  export type IndicatorCountAggregateOutputType = {
    id: number
    tipo: number
    pattern: number
    severidade: number
    fonte: number
    validadeInicio: number
    validadeFim: number
    _all: number
  }


  export type IndicatorAvgAggregateInputType = {
    severidade?: true
  }

  export type IndicatorSumAggregateInputType = {
    severidade?: true
  }

  export type IndicatorMinAggregateInputType = {
    id?: true
    tipo?: true
    pattern?: true
    severidade?: true
    fonte?: true
    validadeInicio?: true
    validadeFim?: true
  }

  export type IndicatorMaxAggregateInputType = {
    id?: true
    tipo?: true
    pattern?: true
    severidade?: true
    fonte?: true
    validadeInicio?: true
    validadeFim?: true
  }

  export type IndicatorCountAggregateInputType = {
    id?: true
    tipo?: true
    pattern?: true
    severidade?: true
    fonte?: true
    validadeInicio?: true
    validadeFim?: true
    _all?: true
  }

  export type IndicatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicator to aggregate.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Indicators
    **/
    _count?: true | IndicatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndicatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndicatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicatorMaxAggregateInputType
  }

  export type GetIndicatorAggregateType<T extends IndicatorAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicator[P]>
      : GetScalarType<T[P], AggregateIndicator[P]>
  }




  export type IndicatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorWhereInput
    orderBy?: IndicatorOrderByWithAggregationInput | IndicatorOrderByWithAggregationInput[]
    by: IndicatorScalarFieldEnum[] | IndicatorScalarFieldEnum
    having?: IndicatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicatorCountAggregateInputType | true
    _avg?: IndicatorAvgAggregateInputType
    _sum?: IndicatorSumAggregateInputType
    _min?: IndicatorMinAggregateInputType
    _max?: IndicatorMaxAggregateInputType
  }

  export type IndicatorGroupByOutputType = {
    id: string
    tipo: string
    pattern: string
    severidade: number | null
    fonte: string | null
    validadeInicio: Date | null
    validadeFim: Date | null
    _count: IndicatorCountAggregateOutputType | null
    _avg: IndicatorAvgAggregateOutputType | null
    _sum: IndicatorSumAggregateOutputType | null
    _min: IndicatorMinAggregateOutputType | null
    _max: IndicatorMaxAggregateOutputType | null
  }

  type GetIndicatorGroupByPayload<T extends IndicatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicatorGroupByOutputType[P]>
            : GetScalarType<T[P], IndicatorGroupByOutputType[P]>
        }
      >
    >


  export type IndicatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    pattern?: boolean
    severidade?: boolean
    fonte?: boolean
    validadeInicio?: boolean
    validadeFim?: boolean
    sightings?: boolean | Indicator$sightingsArgs<ExtArgs>
    threats?: boolean | Indicator$threatsArgs<ExtArgs>
    _count?: boolean | IndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicator"]>

  export type IndicatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    pattern?: boolean
    severidade?: boolean
    fonte?: boolean
    validadeInicio?: boolean
    validadeFim?: boolean
  }, ExtArgs["result"]["indicator"]>

  export type IndicatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    pattern?: boolean
    severidade?: boolean
    fonte?: boolean
    validadeInicio?: boolean
    validadeFim?: boolean
  }, ExtArgs["result"]["indicator"]>

  export type IndicatorSelectScalar = {
    id?: boolean
    tipo?: boolean
    pattern?: boolean
    severidade?: boolean
    fonte?: boolean
    validadeInicio?: boolean
    validadeFim?: boolean
  }

  export type IndicatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "pattern" | "severidade" | "fonte" | "validadeInicio" | "validadeFim", ExtArgs["result"]["indicator"]>
  export type IndicatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sightings?: boolean | Indicator$sightingsArgs<ExtArgs>
    threats?: boolean | Indicator$threatsArgs<ExtArgs>
    _count?: boolean | IndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IndicatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type IndicatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IndicatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Indicator"
    objects: {
      sightings: Prisma.$SightingPayload<ExtArgs>[]
      threats: Prisma.$IndicatorThreatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tipo: string
      pattern: string
      severidade: number | null
      fonte: string | null
      validadeInicio: Date | null
      validadeFim: Date | null
    }, ExtArgs["result"]["indicator"]>
    composites: {}
  }

  type IndicatorGetPayload<S extends boolean | null | undefined | IndicatorDefaultArgs> = $Result.GetResult<Prisma.$IndicatorPayload, S>

  type IndicatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IndicatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndicatorCountAggregateInputType | true
    }

  export interface IndicatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Indicator'], meta: { name: 'Indicator' } }
    /**
     * Find zero or one Indicator that matches the filter.
     * @param {IndicatorFindUniqueArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicatorFindUniqueArgs>(args: SelectSubset<T, IndicatorFindUniqueArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Indicator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndicatorFindUniqueOrThrowArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicatorFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Indicator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindFirstArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicatorFindFirstArgs>(args?: SelectSubset<T, IndicatorFindFirstArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Indicator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindFirstOrThrowArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicatorFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Indicators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Indicators
     * const indicators = await prisma.indicator.findMany()
     * 
     * // Get first 10 Indicators
     * const indicators = await prisma.indicator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicatorWithIdOnly = await prisma.indicator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicatorFindManyArgs>(args?: SelectSubset<T, IndicatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Indicator.
     * @param {IndicatorCreateArgs} args - Arguments to create a Indicator.
     * @example
     * // Create one Indicator
     * const Indicator = await prisma.indicator.create({
     *   data: {
     *     // ... data to create a Indicator
     *   }
     * })
     * 
     */
    create<T extends IndicatorCreateArgs>(args: SelectSubset<T, IndicatorCreateArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Indicators.
     * @param {IndicatorCreateManyArgs} args - Arguments to create many Indicators.
     * @example
     * // Create many Indicators
     * const indicator = await prisma.indicator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicatorCreateManyArgs>(args?: SelectSubset<T, IndicatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Indicators and returns the data saved in the database.
     * @param {IndicatorCreateManyAndReturnArgs} args - Arguments to create many Indicators.
     * @example
     * // Create many Indicators
     * const indicator = await prisma.indicator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Indicators and only return the `id`
     * const indicatorWithIdOnly = await prisma.indicator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicatorCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Indicator.
     * @param {IndicatorDeleteArgs} args - Arguments to delete one Indicator.
     * @example
     * // Delete one Indicator
     * const Indicator = await prisma.indicator.delete({
     *   where: {
     *     // ... filter to delete one Indicator
     *   }
     * })
     * 
     */
    delete<T extends IndicatorDeleteArgs>(args: SelectSubset<T, IndicatorDeleteArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Indicator.
     * @param {IndicatorUpdateArgs} args - Arguments to update one Indicator.
     * @example
     * // Update one Indicator
     * const indicator = await prisma.indicator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicatorUpdateArgs>(args: SelectSubset<T, IndicatorUpdateArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Indicators.
     * @param {IndicatorDeleteManyArgs} args - Arguments to filter Indicators to delete.
     * @example
     * // Delete a few Indicators
     * const { count } = await prisma.indicator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicatorDeleteManyArgs>(args?: SelectSubset<T, IndicatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Indicators
     * const indicator = await prisma.indicator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicatorUpdateManyArgs>(args: SelectSubset<T, IndicatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicators and returns the data updated in the database.
     * @param {IndicatorUpdateManyAndReturnArgs} args - Arguments to update many Indicators.
     * @example
     * // Update many Indicators
     * const indicator = await prisma.indicator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Indicators and only return the `id`
     * const indicatorWithIdOnly = await prisma.indicator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IndicatorUpdateManyAndReturnArgs>(args: SelectSubset<T, IndicatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Indicator.
     * @param {IndicatorUpsertArgs} args - Arguments to update or create a Indicator.
     * @example
     * // Update or create a Indicator
     * const indicator = await prisma.indicator.upsert({
     *   create: {
     *     // ... data to create a Indicator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Indicator we want to update
     *   }
     * })
     */
    upsert<T extends IndicatorUpsertArgs>(args: SelectSubset<T, IndicatorUpsertArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Indicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCountArgs} args - Arguments to filter Indicators to count.
     * @example
     * // Count the number of Indicators
     * const count = await prisma.indicator.count({
     *   where: {
     *     // ... the filter for the Indicators we want to count
     *   }
     * })
    **/
    count<T extends IndicatorCountArgs>(
      args?: Subset<T, IndicatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Indicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicatorAggregateArgs>(args: Subset<T, IndicatorAggregateArgs>): Prisma.PrismaPromise<GetIndicatorAggregateType<T>>

    /**
     * Group by Indicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicatorGroupByArgs['orderBy'] }
        : { orderBy?: IndicatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Indicator model
   */
  readonly fields: IndicatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Indicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sightings<T extends Indicator$sightingsArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$sightingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    threats<T extends Indicator$threatsArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$threatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Indicator model
   */
  interface IndicatorFieldRefs {
    readonly id: FieldRef<"Indicator", 'String'>
    readonly tipo: FieldRef<"Indicator", 'String'>
    readonly pattern: FieldRef<"Indicator", 'String'>
    readonly severidade: FieldRef<"Indicator", 'Int'>
    readonly fonte: FieldRef<"Indicator", 'String'>
    readonly validadeInicio: FieldRef<"Indicator", 'DateTime'>
    readonly validadeFim: FieldRef<"Indicator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Indicator findUnique
   */
  export type IndicatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator findUniqueOrThrow
   */
  export type IndicatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator findFirst
   */
  export type IndicatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicators.
     */
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator findFirstOrThrow
   */
  export type IndicatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicators.
     */
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator findMany
   */
  export type IndicatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicators to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator create
   */
  export type IndicatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Indicator.
     */
    data: XOR<IndicatorCreateInput, IndicatorUncheckedCreateInput>
  }

  /**
   * Indicator createMany
   */
  export type IndicatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Indicators.
     */
    data: IndicatorCreateManyInput | IndicatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Indicator createManyAndReturn
   */
  export type IndicatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * The data used to create many Indicators.
     */
    data: IndicatorCreateManyInput | IndicatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Indicator update
   */
  export type IndicatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Indicator.
     */
    data: XOR<IndicatorUpdateInput, IndicatorUncheckedUpdateInput>
    /**
     * Choose, which Indicator to update.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator updateMany
   */
  export type IndicatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Indicators.
     */
    data: XOR<IndicatorUpdateManyMutationInput, IndicatorUncheckedUpdateManyInput>
    /**
     * Filter which Indicators to update
     */
    where?: IndicatorWhereInput
    /**
     * Limit how many Indicators to update.
     */
    limit?: number
  }

  /**
   * Indicator updateManyAndReturn
   */
  export type IndicatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * The data used to update Indicators.
     */
    data: XOR<IndicatorUpdateManyMutationInput, IndicatorUncheckedUpdateManyInput>
    /**
     * Filter which Indicators to update
     */
    where?: IndicatorWhereInput
    /**
     * Limit how many Indicators to update.
     */
    limit?: number
  }

  /**
   * Indicator upsert
   */
  export type IndicatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Indicator to update in case it exists.
     */
    where: IndicatorWhereUniqueInput
    /**
     * In case the Indicator found by the `where` argument doesn't exist, create a new Indicator with this data.
     */
    create: XOR<IndicatorCreateInput, IndicatorUncheckedCreateInput>
    /**
     * In case the Indicator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicatorUpdateInput, IndicatorUncheckedUpdateInput>
  }

  /**
   * Indicator delete
   */
  export type IndicatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter which Indicator to delete.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator deleteMany
   */
  export type IndicatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicators to delete
     */
    where?: IndicatorWhereInput
    /**
     * Limit how many Indicators to delete.
     */
    limit?: number
  }

  /**
   * Indicator.sightings
   */
  export type Indicator$sightingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
    where?: SightingWhereInput
    orderBy?: SightingOrderByWithRelationInput | SightingOrderByWithRelationInput[]
    cursor?: SightingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SightingScalarFieldEnum | SightingScalarFieldEnum[]
  }

  /**
   * Indicator.threats
   */
  export type Indicator$threatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
    where?: IndicatorThreatWhereInput
    orderBy?: IndicatorThreatOrderByWithRelationInput | IndicatorThreatOrderByWithRelationInput[]
    cursor?: IndicatorThreatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorThreatScalarFieldEnum | IndicatorThreatScalarFieldEnum[]
  }

  /**
   * Indicator without action
   */
  export type IndicatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
  }


  /**
   * Model ThreatEntity
   */

  export type AggregateThreatEntity = {
    _count: ThreatEntityCountAggregateOutputType | null
    _min: ThreatEntityMinAggregateOutputType | null
    _max: ThreatEntityMaxAggregateOutputType | null
  }

  export type ThreatEntityMinAggregateOutputType = {
    id: string | null
    tipo: string | null
    nome: string | null
    descricao: string | null
  }

  export type ThreatEntityMaxAggregateOutputType = {
    id: string | null
    tipo: string | null
    nome: string | null
    descricao: string | null
  }

  export type ThreatEntityCountAggregateOutputType = {
    id: number
    tipo: number
    nome: number
    descricao: number
    _all: number
  }


  export type ThreatEntityMinAggregateInputType = {
    id?: true
    tipo?: true
    nome?: true
    descricao?: true
  }

  export type ThreatEntityMaxAggregateInputType = {
    id?: true
    tipo?: true
    nome?: true
    descricao?: true
  }

  export type ThreatEntityCountAggregateInputType = {
    id?: true
    tipo?: true
    nome?: true
    descricao?: true
    _all?: true
  }

  export type ThreatEntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreatEntity to aggregate.
     */
    where?: ThreatEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatEntities to fetch.
     */
    orderBy?: ThreatEntityOrderByWithRelationInput | ThreatEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreatEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThreatEntities
    **/
    _count?: true | ThreatEntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreatEntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreatEntityMaxAggregateInputType
  }

  export type GetThreatEntityAggregateType<T extends ThreatEntityAggregateArgs> = {
        [P in keyof T & keyof AggregateThreatEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreatEntity[P]>
      : GetScalarType<T[P], AggregateThreatEntity[P]>
  }




  export type ThreatEntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreatEntityWhereInput
    orderBy?: ThreatEntityOrderByWithAggregationInput | ThreatEntityOrderByWithAggregationInput[]
    by: ThreatEntityScalarFieldEnum[] | ThreatEntityScalarFieldEnum
    having?: ThreatEntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreatEntityCountAggregateInputType | true
    _min?: ThreatEntityMinAggregateInputType
    _max?: ThreatEntityMaxAggregateInputType
  }

  export type ThreatEntityGroupByOutputType = {
    id: string
    tipo: string
    nome: string
    descricao: string | null
    _count: ThreatEntityCountAggregateOutputType | null
    _min: ThreatEntityMinAggregateOutputType | null
    _max: ThreatEntityMaxAggregateOutputType | null
  }

  type GetThreatEntityGroupByPayload<T extends ThreatEntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreatEntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreatEntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreatEntityGroupByOutputType[P]>
            : GetScalarType<T[P], ThreatEntityGroupByOutputType[P]>
        }
      >
    >


  export type ThreatEntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    nome?: boolean
    descricao?: boolean
    indicators?: boolean | ThreatEntity$indicatorsArgs<ExtArgs>
    _count?: boolean | ThreatEntityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["threatEntity"]>

  export type ThreatEntitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    nome?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["threatEntity"]>

  export type ThreatEntitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    nome?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["threatEntity"]>

  export type ThreatEntitySelectScalar = {
    id?: boolean
    tipo?: boolean
    nome?: boolean
    descricao?: boolean
  }

  export type ThreatEntityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "nome" | "descricao", ExtArgs["result"]["threatEntity"]>
  export type ThreatEntityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicators?: boolean | ThreatEntity$indicatorsArgs<ExtArgs>
    _count?: boolean | ThreatEntityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ThreatEntityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ThreatEntityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ThreatEntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ThreatEntity"
    objects: {
      indicators: Prisma.$IndicatorThreatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tipo: string
      nome: string
      descricao: string | null
    }, ExtArgs["result"]["threatEntity"]>
    composites: {}
  }

  type ThreatEntityGetPayload<S extends boolean | null | undefined | ThreatEntityDefaultArgs> = $Result.GetResult<Prisma.$ThreatEntityPayload, S>

  type ThreatEntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThreatEntityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThreatEntityCountAggregateInputType | true
    }

  export interface ThreatEntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ThreatEntity'], meta: { name: 'ThreatEntity' } }
    /**
     * Find zero or one ThreatEntity that matches the filter.
     * @param {ThreatEntityFindUniqueArgs} args - Arguments to find a ThreatEntity
     * @example
     * // Get one ThreatEntity
     * const threatEntity = await prisma.threatEntity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreatEntityFindUniqueArgs>(args: SelectSubset<T, ThreatEntityFindUniqueArgs<ExtArgs>>): Prisma__ThreatEntityClient<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ThreatEntity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreatEntityFindUniqueOrThrowArgs} args - Arguments to find a ThreatEntity
     * @example
     * // Get one ThreatEntity
     * const threatEntity = await prisma.threatEntity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreatEntityFindUniqueOrThrowArgs>(args: SelectSubset<T, ThreatEntityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThreatEntityClient<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThreatEntity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEntityFindFirstArgs} args - Arguments to find a ThreatEntity
     * @example
     * // Get one ThreatEntity
     * const threatEntity = await prisma.threatEntity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreatEntityFindFirstArgs>(args?: SelectSubset<T, ThreatEntityFindFirstArgs<ExtArgs>>): Prisma__ThreatEntityClient<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThreatEntity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEntityFindFirstOrThrowArgs} args - Arguments to find a ThreatEntity
     * @example
     * // Get one ThreatEntity
     * const threatEntity = await prisma.threatEntity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreatEntityFindFirstOrThrowArgs>(args?: SelectSubset<T, ThreatEntityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThreatEntityClient<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ThreatEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreatEntities
     * const threatEntities = await prisma.threatEntity.findMany()
     * 
     * // Get first 10 ThreatEntities
     * const threatEntities = await prisma.threatEntity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threatEntityWithIdOnly = await prisma.threatEntity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThreatEntityFindManyArgs>(args?: SelectSubset<T, ThreatEntityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ThreatEntity.
     * @param {ThreatEntityCreateArgs} args - Arguments to create a ThreatEntity.
     * @example
     * // Create one ThreatEntity
     * const ThreatEntity = await prisma.threatEntity.create({
     *   data: {
     *     // ... data to create a ThreatEntity
     *   }
     * })
     * 
     */
    create<T extends ThreatEntityCreateArgs>(args: SelectSubset<T, ThreatEntityCreateArgs<ExtArgs>>): Prisma__ThreatEntityClient<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ThreatEntities.
     * @param {ThreatEntityCreateManyArgs} args - Arguments to create many ThreatEntities.
     * @example
     * // Create many ThreatEntities
     * const threatEntity = await prisma.threatEntity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThreatEntityCreateManyArgs>(args?: SelectSubset<T, ThreatEntityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ThreatEntities and returns the data saved in the database.
     * @param {ThreatEntityCreateManyAndReturnArgs} args - Arguments to create many ThreatEntities.
     * @example
     * // Create many ThreatEntities
     * const threatEntity = await prisma.threatEntity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ThreatEntities and only return the `id`
     * const threatEntityWithIdOnly = await prisma.threatEntity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThreatEntityCreateManyAndReturnArgs>(args?: SelectSubset<T, ThreatEntityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ThreatEntity.
     * @param {ThreatEntityDeleteArgs} args - Arguments to delete one ThreatEntity.
     * @example
     * // Delete one ThreatEntity
     * const ThreatEntity = await prisma.threatEntity.delete({
     *   where: {
     *     // ... filter to delete one ThreatEntity
     *   }
     * })
     * 
     */
    delete<T extends ThreatEntityDeleteArgs>(args: SelectSubset<T, ThreatEntityDeleteArgs<ExtArgs>>): Prisma__ThreatEntityClient<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ThreatEntity.
     * @param {ThreatEntityUpdateArgs} args - Arguments to update one ThreatEntity.
     * @example
     * // Update one ThreatEntity
     * const threatEntity = await prisma.threatEntity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThreatEntityUpdateArgs>(args: SelectSubset<T, ThreatEntityUpdateArgs<ExtArgs>>): Prisma__ThreatEntityClient<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ThreatEntities.
     * @param {ThreatEntityDeleteManyArgs} args - Arguments to filter ThreatEntities to delete.
     * @example
     * // Delete a few ThreatEntities
     * const { count } = await prisma.threatEntity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThreatEntityDeleteManyArgs>(args?: SelectSubset<T, ThreatEntityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreatEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreatEntities
     * const threatEntity = await prisma.threatEntity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThreatEntityUpdateManyArgs>(args: SelectSubset<T, ThreatEntityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreatEntities and returns the data updated in the database.
     * @param {ThreatEntityUpdateManyAndReturnArgs} args - Arguments to update many ThreatEntities.
     * @example
     * // Update many ThreatEntities
     * const threatEntity = await prisma.threatEntity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ThreatEntities and only return the `id`
     * const threatEntityWithIdOnly = await prisma.threatEntity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThreatEntityUpdateManyAndReturnArgs>(args: SelectSubset<T, ThreatEntityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ThreatEntity.
     * @param {ThreatEntityUpsertArgs} args - Arguments to update or create a ThreatEntity.
     * @example
     * // Update or create a ThreatEntity
     * const threatEntity = await prisma.threatEntity.upsert({
     *   create: {
     *     // ... data to create a ThreatEntity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreatEntity we want to update
     *   }
     * })
     */
    upsert<T extends ThreatEntityUpsertArgs>(args: SelectSubset<T, ThreatEntityUpsertArgs<ExtArgs>>): Prisma__ThreatEntityClient<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ThreatEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEntityCountArgs} args - Arguments to filter ThreatEntities to count.
     * @example
     * // Count the number of ThreatEntities
     * const count = await prisma.threatEntity.count({
     *   where: {
     *     // ... the filter for the ThreatEntities we want to count
     *   }
     * })
    **/
    count<T extends ThreatEntityCountArgs>(
      args?: Subset<T, ThreatEntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreatEntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThreatEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreatEntityAggregateArgs>(args: Subset<T, ThreatEntityAggregateArgs>): Prisma.PrismaPromise<GetThreatEntityAggregateType<T>>

    /**
     * Group by ThreatEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreatEntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreatEntityGroupByArgs['orderBy'] }
        : { orderBy?: ThreatEntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreatEntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreatEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ThreatEntity model
   */
  readonly fields: ThreatEntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreatEntity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreatEntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicators<T extends ThreatEntity$indicatorsArgs<ExtArgs> = {}>(args?: Subset<T, ThreatEntity$indicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ThreatEntity model
   */
  interface ThreatEntityFieldRefs {
    readonly id: FieldRef<"ThreatEntity", 'String'>
    readonly tipo: FieldRef<"ThreatEntity", 'String'>
    readonly nome: FieldRef<"ThreatEntity", 'String'>
    readonly descricao: FieldRef<"ThreatEntity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ThreatEntity findUnique
   */
  export type ThreatEntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEntityInclude<ExtArgs> | null
    /**
     * Filter, which ThreatEntity to fetch.
     */
    where: ThreatEntityWhereUniqueInput
  }

  /**
   * ThreatEntity findUniqueOrThrow
   */
  export type ThreatEntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEntityInclude<ExtArgs> | null
    /**
     * Filter, which ThreatEntity to fetch.
     */
    where: ThreatEntityWhereUniqueInput
  }

  /**
   * ThreatEntity findFirst
   */
  export type ThreatEntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEntityInclude<ExtArgs> | null
    /**
     * Filter, which ThreatEntity to fetch.
     */
    where?: ThreatEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatEntities to fetch.
     */
    orderBy?: ThreatEntityOrderByWithRelationInput | ThreatEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreatEntities.
     */
    cursor?: ThreatEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreatEntities.
     */
    distinct?: ThreatEntityScalarFieldEnum | ThreatEntityScalarFieldEnum[]
  }

  /**
   * ThreatEntity findFirstOrThrow
   */
  export type ThreatEntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEntityInclude<ExtArgs> | null
    /**
     * Filter, which ThreatEntity to fetch.
     */
    where?: ThreatEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatEntities to fetch.
     */
    orderBy?: ThreatEntityOrderByWithRelationInput | ThreatEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreatEntities.
     */
    cursor?: ThreatEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreatEntities.
     */
    distinct?: ThreatEntityScalarFieldEnum | ThreatEntityScalarFieldEnum[]
  }

  /**
   * ThreatEntity findMany
   */
  export type ThreatEntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEntityInclude<ExtArgs> | null
    /**
     * Filter, which ThreatEntities to fetch.
     */
    where?: ThreatEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatEntities to fetch.
     */
    orderBy?: ThreatEntityOrderByWithRelationInput | ThreatEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThreatEntities.
     */
    cursor?: ThreatEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatEntities.
     */
    skip?: number
    distinct?: ThreatEntityScalarFieldEnum | ThreatEntityScalarFieldEnum[]
  }

  /**
   * ThreatEntity create
   */
  export type ThreatEntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEntityInclude<ExtArgs> | null
    /**
     * The data needed to create a ThreatEntity.
     */
    data: XOR<ThreatEntityCreateInput, ThreatEntityUncheckedCreateInput>
  }

  /**
   * ThreatEntity createMany
   */
  export type ThreatEntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ThreatEntities.
     */
    data: ThreatEntityCreateManyInput | ThreatEntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThreatEntity createManyAndReturn
   */
  export type ThreatEntityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * The data used to create many ThreatEntities.
     */
    data: ThreatEntityCreateManyInput | ThreatEntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThreatEntity update
   */
  export type ThreatEntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEntityInclude<ExtArgs> | null
    /**
     * The data needed to update a ThreatEntity.
     */
    data: XOR<ThreatEntityUpdateInput, ThreatEntityUncheckedUpdateInput>
    /**
     * Choose, which ThreatEntity to update.
     */
    where: ThreatEntityWhereUniqueInput
  }

  /**
   * ThreatEntity updateMany
   */
  export type ThreatEntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ThreatEntities.
     */
    data: XOR<ThreatEntityUpdateManyMutationInput, ThreatEntityUncheckedUpdateManyInput>
    /**
     * Filter which ThreatEntities to update
     */
    where?: ThreatEntityWhereInput
    /**
     * Limit how many ThreatEntities to update.
     */
    limit?: number
  }

  /**
   * ThreatEntity updateManyAndReturn
   */
  export type ThreatEntityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * The data used to update ThreatEntities.
     */
    data: XOR<ThreatEntityUpdateManyMutationInput, ThreatEntityUncheckedUpdateManyInput>
    /**
     * Filter which ThreatEntities to update
     */
    where?: ThreatEntityWhereInput
    /**
     * Limit how many ThreatEntities to update.
     */
    limit?: number
  }

  /**
   * ThreatEntity upsert
   */
  export type ThreatEntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEntityInclude<ExtArgs> | null
    /**
     * The filter to search for the ThreatEntity to update in case it exists.
     */
    where: ThreatEntityWhereUniqueInput
    /**
     * In case the ThreatEntity found by the `where` argument doesn't exist, create a new ThreatEntity with this data.
     */
    create: XOR<ThreatEntityCreateInput, ThreatEntityUncheckedCreateInput>
    /**
     * In case the ThreatEntity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreatEntityUpdateInput, ThreatEntityUncheckedUpdateInput>
  }

  /**
   * ThreatEntity delete
   */
  export type ThreatEntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEntityInclude<ExtArgs> | null
    /**
     * Filter which ThreatEntity to delete.
     */
    where: ThreatEntityWhereUniqueInput
  }

  /**
   * ThreatEntity deleteMany
   */
  export type ThreatEntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreatEntities to delete
     */
    where?: ThreatEntityWhereInput
    /**
     * Limit how many ThreatEntities to delete.
     */
    limit?: number
  }

  /**
   * ThreatEntity.indicators
   */
  export type ThreatEntity$indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
    where?: IndicatorThreatWhereInput
    orderBy?: IndicatorThreatOrderByWithRelationInput | IndicatorThreatOrderByWithRelationInput[]
    cursor?: IndicatorThreatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorThreatScalarFieldEnum | IndicatorThreatScalarFieldEnum[]
  }

  /**
   * ThreatEntity without action
   */
  export type ThreatEntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEntity
     */
    select?: ThreatEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEntity
     */
    omit?: ThreatEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEntityInclude<ExtArgs> | null
  }


  /**
   * Model IndicatorThreat
   */

  export type AggregateIndicatorThreat = {
    _count: IndicatorThreatCountAggregateOutputType | null
    _min: IndicatorThreatMinAggregateOutputType | null
    _max: IndicatorThreatMaxAggregateOutputType | null
  }

  export type IndicatorThreatMinAggregateOutputType = {
    id: string | null
    indicatorId: string | null
    threatId: string | null
  }

  export type IndicatorThreatMaxAggregateOutputType = {
    id: string | null
    indicatorId: string | null
    threatId: string | null
  }

  export type IndicatorThreatCountAggregateOutputType = {
    id: number
    indicatorId: number
    threatId: number
    _all: number
  }


  export type IndicatorThreatMinAggregateInputType = {
    id?: true
    indicatorId?: true
    threatId?: true
  }

  export type IndicatorThreatMaxAggregateInputType = {
    id?: true
    indicatorId?: true
    threatId?: true
  }

  export type IndicatorThreatCountAggregateInputType = {
    id?: true
    indicatorId?: true
    threatId?: true
    _all?: true
  }

  export type IndicatorThreatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorThreat to aggregate.
     */
    where?: IndicatorThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorThreats to fetch.
     */
    orderBy?: IndicatorThreatOrderByWithRelationInput | IndicatorThreatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicatorThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorThreats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorThreats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndicatorThreats
    **/
    _count?: true | IndicatorThreatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicatorThreatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicatorThreatMaxAggregateInputType
  }

  export type GetIndicatorThreatAggregateType<T extends IndicatorThreatAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicatorThreat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicatorThreat[P]>
      : GetScalarType<T[P], AggregateIndicatorThreat[P]>
  }




  export type IndicatorThreatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorThreatWhereInput
    orderBy?: IndicatorThreatOrderByWithAggregationInput | IndicatorThreatOrderByWithAggregationInput[]
    by: IndicatorThreatScalarFieldEnum[] | IndicatorThreatScalarFieldEnum
    having?: IndicatorThreatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicatorThreatCountAggregateInputType | true
    _min?: IndicatorThreatMinAggregateInputType
    _max?: IndicatorThreatMaxAggregateInputType
  }

  export type IndicatorThreatGroupByOutputType = {
    id: string
    indicatorId: string
    threatId: string
    _count: IndicatorThreatCountAggregateOutputType | null
    _min: IndicatorThreatMinAggregateOutputType | null
    _max: IndicatorThreatMaxAggregateOutputType | null
  }

  type GetIndicatorThreatGroupByPayload<T extends IndicatorThreatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicatorThreatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicatorThreatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicatorThreatGroupByOutputType[P]>
            : GetScalarType<T[P], IndicatorThreatGroupByOutputType[P]>
        }
      >
    >


  export type IndicatorThreatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicatorId?: boolean
    threatId?: boolean
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    threat?: boolean | ThreatEntityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorThreat"]>

  export type IndicatorThreatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicatorId?: boolean
    threatId?: boolean
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    threat?: boolean | ThreatEntityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorThreat"]>

  export type IndicatorThreatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicatorId?: boolean
    threatId?: boolean
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    threat?: boolean | ThreatEntityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorThreat"]>

  export type IndicatorThreatSelectScalar = {
    id?: boolean
    indicatorId?: boolean
    threatId?: boolean
  }

  export type IndicatorThreatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "indicatorId" | "threatId", ExtArgs["result"]["indicatorThreat"]>
  export type IndicatorThreatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    threat?: boolean | ThreatEntityDefaultArgs<ExtArgs>
  }
  export type IndicatorThreatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    threat?: boolean | ThreatEntityDefaultArgs<ExtArgs>
  }
  export type IndicatorThreatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    threat?: boolean | ThreatEntityDefaultArgs<ExtArgs>
  }

  export type $IndicatorThreatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndicatorThreat"
    objects: {
      indicator: Prisma.$IndicatorPayload<ExtArgs>
      threat: Prisma.$ThreatEntityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      indicatorId: string
      threatId: string
    }, ExtArgs["result"]["indicatorThreat"]>
    composites: {}
  }

  type IndicatorThreatGetPayload<S extends boolean | null | undefined | IndicatorThreatDefaultArgs> = $Result.GetResult<Prisma.$IndicatorThreatPayload, S>

  type IndicatorThreatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IndicatorThreatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndicatorThreatCountAggregateInputType | true
    }

  export interface IndicatorThreatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndicatorThreat'], meta: { name: 'IndicatorThreat' } }
    /**
     * Find zero or one IndicatorThreat that matches the filter.
     * @param {IndicatorThreatFindUniqueArgs} args - Arguments to find a IndicatorThreat
     * @example
     * // Get one IndicatorThreat
     * const indicatorThreat = await prisma.indicatorThreat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicatorThreatFindUniqueArgs>(args: SelectSubset<T, IndicatorThreatFindUniqueArgs<ExtArgs>>): Prisma__IndicatorThreatClient<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IndicatorThreat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndicatorThreatFindUniqueOrThrowArgs} args - Arguments to find a IndicatorThreat
     * @example
     * // Get one IndicatorThreat
     * const indicatorThreat = await prisma.indicatorThreat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicatorThreatFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicatorThreatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicatorThreatClient<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IndicatorThreat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorThreatFindFirstArgs} args - Arguments to find a IndicatorThreat
     * @example
     * // Get one IndicatorThreat
     * const indicatorThreat = await prisma.indicatorThreat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicatorThreatFindFirstArgs>(args?: SelectSubset<T, IndicatorThreatFindFirstArgs<ExtArgs>>): Prisma__IndicatorThreatClient<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IndicatorThreat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorThreatFindFirstOrThrowArgs} args - Arguments to find a IndicatorThreat
     * @example
     * // Get one IndicatorThreat
     * const indicatorThreat = await prisma.indicatorThreat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicatorThreatFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicatorThreatFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicatorThreatClient<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IndicatorThreats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorThreatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndicatorThreats
     * const indicatorThreats = await prisma.indicatorThreat.findMany()
     * 
     * // Get first 10 IndicatorThreats
     * const indicatorThreats = await prisma.indicatorThreat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicatorThreatWithIdOnly = await prisma.indicatorThreat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicatorThreatFindManyArgs>(args?: SelectSubset<T, IndicatorThreatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IndicatorThreat.
     * @param {IndicatorThreatCreateArgs} args - Arguments to create a IndicatorThreat.
     * @example
     * // Create one IndicatorThreat
     * const IndicatorThreat = await prisma.indicatorThreat.create({
     *   data: {
     *     // ... data to create a IndicatorThreat
     *   }
     * })
     * 
     */
    create<T extends IndicatorThreatCreateArgs>(args: SelectSubset<T, IndicatorThreatCreateArgs<ExtArgs>>): Prisma__IndicatorThreatClient<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IndicatorThreats.
     * @param {IndicatorThreatCreateManyArgs} args - Arguments to create many IndicatorThreats.
     * @example
     * // Create many IndicatorThreats
     * const indicatorThreat = await prisma.indicatorThreat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicatorThreatCreateManyArgs>(args?: SelectSubset<T, IndicatorThreatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IndicatorThreats and returns the data saved in the database.
     * @param {IndicatorThreatCreateManyAndReturnArgs} args - Arguments to create many IndicatorThreats.
     * @example
     * // Create many IndicatorThreats
     * const indicatorThreat = await prisma.indicatorThreat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IndicatorThreats and only return the `id`
     * const indicatorThreatWithIdOnly = await prisma.indicatorThreat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicatorThreatCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicatorThreatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IndicatorThreat.
     * @param {IndicatorThreatDeleteArgs} args - Arguments to delete one IndicatorThreat.
     * @example
     * // Delete one IndicatorThreat
     * const IndicatorThreat = await prisma.indicatorThreat.delete({
     *   where: {
     *     // ... filter to delete one IndicatorThreat
     *   }
     * })
     * 
     */
    delete<T extends IndicatorThreatDeleteArgs>(args: SelectSubset<T, IndicatorThreatDeleteArgs<ExtArgs>>): Prisma__IndicatorThreatClient<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IndicatorThreat.
     * @param {IndicatorThreatUpdateArgs} args - Arguments to update one IndicatorThreat.
     * @example
     * // Update one IndicatorThreat
     * const indicatorThreat = await prisma.indicatorThreat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicatorThreatUpdateArgs>(args: SelectSubset<T, IndicatorThreatUpdateArgs<ExtArgs>>): Prisma__IndicatorThreatClient<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IndicatorThreats.
     * @param {IndicatorThreatDeleteManyArgs} args - Arguments to filter IndicatorThreats to delete.
     * @example
     * // Delete a few IndicatorThreats
     * const { count } = await prisma.indicatorThreat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicatorThreatDeleteManyArgs>(args?: SelectSubset<T, IndicatorThreatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicatorThreats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorThreatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndicatorThreats
     * const indicatorThreat = await prisma.indicatorThreat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicatorThreatUpdateManyArgs>(args: SelectSubset<T, IndicatorThreatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicatorThreats and returns the data updated in the database.
     * @param {IndicatorThreatUpdateManyAndReturnArgs} args - Arguments to update many IndicatorThreats.
     * @example
     * // Update many IndicatorThreats
     * const indicatorThreat = await prisma.indicatorThreat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IndicatorThreats and only return the `id`
     * const indicatorThreatWithIdOnly = await prisma.indicatorThreat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IndicatorThreatUpdateManyAndReturnArgs>(args: SelectSubset<T, IndicatorThreatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IndicatorThreat.
     * @param {IndicatorThreatUpsertArgs} args - Arguments to update or create a IndicatorThreat.
     * @example
     * // Update or create a IndicatorThreat
     * const indicatorThreat = await prisma.indicatorThreat.upsert({
     *   create: {
     *     // ... data to create a IndicatorThreat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndicatorThreat we want to update
     *   }
     * })
     */
    upsert<T extends IndicatorThreatUpsertArgs>(args: SelectSubset<T, IndicatorThreatUpsertArgs<ExtArgs>>): Prisma__IndicatorThreatClient<$Result.GetResult<Prisma.$IndicatorThreatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IndicatorThreats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorThreatCountArgs} args - Arguments to filter IndicatorThreats to count.
     * @example
     * // Count the number of IndicatorThreats
     * const count = await prisma.indicatorThreat.count({
     *   where: {
     *     // ... the filter for the IndicatorThreats we want to count
     *   }
     * })
    **/
    count<T extends IndicatorThreatCountArgs>(
      args?: Subset<T, IndicatorThreatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicatorThreatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndicatorThreat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorThreatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicatorThreatAggregateArgs>(args: Subset<T, IndicatorThreatAggregateArgs>): Prisma.PrismaPromise<GetIndicatorThreatAggregateType<T>>

    /**
     * Group by IndicatorThreat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorThreatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicatorThreatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicatorThreatGroupByArgs['orderBy'] }
        : { orderBy?: IndicatorThreatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicatorThreatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicatorThreatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndicatorThreat model
   */
  readonly fields: IndicatorThreatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndicatorThreat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicatorThreatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicator<T extends IndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorDefaultArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    threat<T extends ThreatEntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ThreatEntityDefaultArgs<ExtArgs>>): Prisma__ThreatEntityClient<$Result.GetResult<Prisma.$ThreatEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndicatorThreat model
   */
  interface IndicatorThreatFieldRefs {
    readonly id: FieldRef<"IndicatorThreat", 'String'>
    readonly indicatorId: FieldRef<"IndicatorThreat", 'String'>
    readonly threatId: FieldRef<"IndicatorThreat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IndicatorThreat findUnique
   */
  export type IndicatorThreatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorThreat to fetch.
     */
    where: IndicatorThreatWhereUniqueInput
  }

  /**
   * IndicatorThreat findUniqueOrThrow
   */
  export type IndicatorThreatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorThreat to fetch.
     */
    where: IndicatorThreatWhereUniqueInput
  }

  /**
   * IndicatorThreat findFirst
   */
  export type IndicatorThreatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorThreat to fetch.
     */
    where?: IndicatorThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorThreats to fetch.
     */
    orderBy?: IndicatorThreatOrderByWithRelationInput | IndicatorThreatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorThreats.
     */
    cursor?: IndicatorThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorThreats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorThreats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorThreats.
     */
    distinct?: IndicatorThreatScalarFieldEnum | IndicatorThreatScalarFieldEnum[]
  }

  /**
   * IndicatorThreat findFirstOrThrow
   */
  export type IndicatorThreatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorThreat to fetch.
     */
    where?: IndicatorThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorThreats to fetch.
     */
    orderBy?: IndicatorThreatOrderByWithRelationInput | IndicatorThreatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorThreats.
     */
    cursor?: IndicatorThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorThreats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorThreats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorThreats.
     */
    distinct?: IndicatorThreatScalarFieldEnum | IndicatorThreatScalarFieldEnum[]
  }

  /**
   * IndicatorThreat findMany
   */
  export type IndicatorThreatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorThreats to fetch.
     */
    where?: IndicatorThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorThreats to fetch.
     */
    orderBy?: IndicatorThreatOrderByWithRelationInput | IndicatorThreatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndicatorThreats.
     */
    cursor?: IndicatorThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorThreats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorThreats.
     */
    skip?: number
    distinct?: IndicatorThreatScalarFieldEnum | IndicatorThreatScalarFieldEnum[]
  }

  /**
   * IndicatorThreat create
   */
  export type IndicatorThreatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
    /**
     * The data needed to create a IndicatorThreat.
     */
    data: XOR<IndicatorThreatCreateInput, IndicatorThreatUncheckedCreateInput>
  }

  /**
   * IndicatorThreat createMany
   */
  export type IndicatorThreatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndicatorThreats.
     */
    data: IndicatorThreatCreateManyInput | IndicatorThreatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndicatorThreat createManyAndReturn
   */
  export type IndicatorThreatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * The data used to create many IndicatorThreats.
     */
    data: IndicatorThreatCreateManyInput | IndicatorThreatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IndicatorThreat update
   */
  export type IndicatorThreatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
    /**
     * The data needed to update a IndicatorThreat.
     */
    data: XOR<IndicatorThreatUpdateInput, IndicatorThreatUncheckedUpdateInput>
    /**
     * Choose, which IndicatorThreat to update.
     */
    where: IndicatorThreatWhereUniqueInput
  }

  /**
   * IndicatorThreat updateMany
   */
  export type IndicatorThreatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndicatorThreats.
     */
    data: XOR<IndicatorThreatUpdateManyMutationInput, IndicatorThreatUncheckedUpdateManyInput>
    /**
     * Filter which IndicatorThreats to update
     */
    where?: IndicatorThreatWhereInput
    /**
     * Limit how many IndicatorThreats to update.
     */
    limit?: number
  }

  /**
   * IndicatorThreat updateManyAndReturn
   */
  export type IndicatorThreatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * The data used to update IndicatorThreats.
     */
    data: XOR<IndicatorThreatUpdateManyMutationInput, IndicatorThreatUncheckedUpdateManyInput>
    /**
     * Filter which IndicatorThreats to update
     */
    where?: IndicatorThreatWhereInput
    /**
     * Limit how many IndicatorThreats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IndicatorThreat upsert
   */
  export type IndicatorThreatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
    /**
     * The filter to search for the IndicatorThreat to update in case it exists.
     */
    where: IndicatorThreatWhereUniqueInput
    /**
     * In case the IndicatorThreat found by the `where` argument doesn't exist, create a new IndicatorThreat with this data.
     */
    create: XOR<IndicatorThreatCreateInput, IndicatorThreatUncheckedCreateInput>
    /**
     * In case the IndicatorThreat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicatorThreatUpdateInput, IndicatorThreatUncheckedUpdateInput>
  }

  /**
   * IndicatorThreat delete
   */
  export type IndicatorThreatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
    /**
     * Filter which IndicatorThreat to delete.
     */
    where: IndicatorThreatWhereUniqueInput
  }

  /**
   * IndicatorThreat deleteMany
   */
  export type IndicatorThreatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorThreats to delete
     */
    where?: IndicatorThreatWhereInput
    /**
     * Limit how many IndicatorThreats to delete.
     */
    limit?: number
  }

  /**
   * IndicatorThreat without action
   */
  export type IndicatorThreatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorThreat
     */
    select?: IndicatorThreatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorThreat
     */
    omit?: IndicatorThreatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorThreatInclude<ExtArgs> | null
  }


  /**
   * Model OT_Event
   */

  export type AggregateOT_Event = {
    _count: OT_EventCountAggregateOutputType | null
    _min: OT_EventMinAggregateOutputType | null
    _max: OT_EventMaxAggregateOutputType | null
  }

  export type OT_EventMinAggregateOutputType = {
    id: string | null
    ts: Date | null
    protocolo: string | null
    srcIp: string | null
    dstIp: string | null
    funcao: string | null
    valor: string | null
    anomalia: boolean | null
    assetId: string | null
  }

  export type OT_EventMaxAggregateOutputType = {
    id: string | null
    ts: Date | null
    protocolo: string | null
    srcIp: string | null
    dstIp: string | null
    funcao: string | null
    valor: string | null
    anomalia: boolean | null
    assetId: string | null
  }

  export type OT_EventCountAggregateOutputType = {
    id: number
    ts: number
    protocolo: number
    srcIp: number
    dstIp: number
    funcao: number
    valor: number
    anomalia: number
    assetId: number
    _all: number
  }


  export type OT_EventMinAggregateInputType = {
    id?: true
    ts?: true
    protocolo?: true
    srcIp?: true
    dstIp?: true
    funcao?: true
    valor?: true
    anomalia?: true
    assetId?: true
  }

  export type OT_EventMaxAggregateInputType = {
    id?: true
    ts?: true
    protocolo?: true
    srcIp?: true
    dstIp?: true
    funcao?: true
    valor?: true
    anomalia?: true
    assetId?: true
  }

  export type OT_EventCountAggregateInputType = {
    id?: true
    ts?: true
    protocolo?: true
    srcIp?: true
    dstIp?: true
    funcao?: true
    valor?: true
    anomalia?: true
    assetId?: true
    _all?: true
  }

  export type OT_EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OT_Event to aggregate.
     */
    where?: OT_EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OT_Events to fetch.
     */
    orderBy?: OT_EventOrderByWithRelationInput | OT_EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OT_EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OT_Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OT_Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OT_Events
    **/
    _count?: true | OT_EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OT_EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OT_EventMaxAggregateInputType
  }

  export type GetOT_EventAggregateType<T extends OT_EventAggregateArgs> = {
        [P in keyof T & keyof AggregateOT_Event]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOT_Event[P]>
      : GetScalarType<T[P], AggregateOT_Event[P]>
  }




  export type OT_EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OT_EventWhereInput
    orderBy?: OT_EventOrderByWithAggregationInput | OT_EventOrderByWithAggregationInput[]
    by: OT_EventScalarFieldEnum[] | OT_EventScalarFieldEnum
    having?: OT_EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OT_EventCountAggregateInputType | true
    _min?: OT_EventMinAggregateInputType
    _max?: OT_EventMaxAggregateInputType
  }

  export type OT_EventGroupByOutputType = {
    id: string
    ts: Date
    protocolo: string
    srcIp: string | null
    dstIp: string | null
    funcao: string | null
    valor: string | null
    anomalia: boolean | null
    assetId: string
    _count: OT_EventCountAggregateOutputType | null
    _min: OT_EventMinAggregateOutputType | null
    _max: OT_EventMaxAggregateOutputType | null
  }

  type GetOT_EventGroupByPayload<T extends OT_EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OT_EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OT_EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OT_EventGroupByOutputType[P]>
            : GetScalarType<T[P], OT_EventGroupByOutputType[P]>
        }
      >
    >


  export type OT_EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    protocolo?: boolean
    srcIp?: boolean
    dstIp?: boolean
    funcao?: boolean
    valor?: boolean
    anomalia?: boolean
    assetId?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oT_Event"]>

  export type OT_EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    protocolo?: boolean
    srcIp?: boolean
    dstIp?: boolean
    funcao?: boolean
    valor?: boolean
    anomalia?: boolean
    assetId?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oT_Event"]>

  export type OT_EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    protocolo?: boolean
    srcIp?: boolean
    dstIp?: boolean
    funcao?: boolean
    valor?: boolean
    anomalia?: boolean
    assetId?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oT_Event"]>

  export type OT_EventSelectScalar = {
    id?: boolean
    ts?: boolean
    protocolo?: boolean
    srcIp?: boolean
    dstIp?: boolean
    funcao?: boolean
    valor?: boolean
    anomalia?: boolean
    assetId?: boolean
  }

  export type OT_EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ts" | "protocolo" | "srcIp" | "dstIp" | "funcao" | "valor" | "anomalia" | "assetId", ExtArgs["result"]["oT_Event"]>
  export type OT_EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }
  export type OT_EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }
  export type OT_EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }

  export type $OT_EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OT_Event"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ts: Date
      protocolo: string
      srcIp: string | null
      dstIp: string | null
      funcao: string | null
      valor: string | null
      anomalia: boolean | null
      assetId: string
    }, ExtArgs["result"]["oT_Event"]>
    composites: {}
  }

  type OT_EventGetPayload<S extends boolean | null | undefined | OT_EventDefaultArgs> = $Result.GetResult<Prisma.$OT_EventPayload, S>

  type OT_EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OT_EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OT_EventCountAggregateInputType | true
    }

  export interface OT_EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OT_Event'], meta: { name: 'OT_Event' } }
    /**
     * Find zero or one OT_Event that matches the filter.
     * @param {OT_EventFindUniqueArgs} args - Arguments to find a OT_Event
     * @example
     * // Get one OT_Event
     * const oT_Event = await prisma.oT_Event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OT_EventFindUniqueArgs>(args: SelectSubset<T, OT_EventFindUniqueArgs<ExtArgs>>): Prisma__OT_EventClient<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OT_Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OT_EventFindUniqueOrThrowArgs} args - Arguments to find a OT_Event
     * @example
     * // Get one OT_Event
     * const oT_Event = await prisma.oT_Event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OT_EventFindUniqueOrThrowArgs>(args: SelectSubset<T, OT_EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OT_EventClient<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OT_Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OT_EventFindFirstArgs} args - Arguments to find a OT_Event
     * @example
     * // Get one OT_Event
     * const oT_Event = await prisma.oT_Event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OT_EventFindFirstArgs>(args?: SelectSubset<T, OT_EventFindFirstArgs<ExtArgs>>): Prisma__OT_EventClient<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OT_Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OT_EventFindFirstOrThrowArgs} args - Arguments to find a OT_Event
     * @example
     * // Get one OT_Event
     * const oT_Event = await prisma.oT_Event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OT_EventFindFirstOrThrowArgs>(args?: SelectSubset<T, OT_EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__OT_EventClient<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OT_Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OT_EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OT_Events
     * const oT_Events = await prisma.oT_Event.findMany()
     * 
     * // Get first 10 OT_Events
     * const oT_Events = await prisma.oT_Event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oT_EventWithIdOnly = await prisma.oT_Event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OT_EventFindManyArgs>(args?: SelectSubset<T, OT_EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OT_Event.
     * @param {OT_EventCreateArgs} args - Arguments to create a OT_Event.
     * @example
     * // Create one OT_Event
     * const OT_Event = await prisma.oT_Event.create({
     *   data: {
     *     // ... data to create a OT_Event
     *   }
     * })
     * 
     */
    create<T extends OT_EventCreateArgs>(args: SelectSubset<T, OT_EventCreateArgs<ExtArgs>>): Prisma__OT_EventClient<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OT_Events.
     * @param {OT_EventCreateManyArgs} args - Arguments to create many OT_Events.
     * @example
     * // Create many OT_Events
     * const oT_Event = await prisma.oT_Event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OT_EventCreateManyArgs>(args?: SelectSubset<T, OT_EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OT_Events and returns the data saved in the database.
     * @param {OT_EventCreateManyAndReturnArgs} args - Arguments to create many OT_Events.
     * @example
     * // Create many OT_Events
     * const oT_Event = await prisma.oT_Event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OT_Events and only return the `id`
     * const oT_EventWithIdOnly = await prisma.oT_Event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OT_EventCreateManyAndReturnArgs>(args?: SelectSubset<T, OT_EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OT_Event.
     * @param {OT_EventDeleteArgs} args - Arguments to delete one OT_Event.
     * @example
     * // Delete one OT_Event
     * const OT_Event = await prisma.oT_Event.delete({
     *   where: {
     *     // ... filter to delete one OT_Event
     *   }
     * })
     * 
     */
    delete<T extends OT_EventDeleteArgs>(args: SelectSubset<T, OT_EventDeleteArgs<ExtArgs>>): Prisma__OT_EventClient<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OT_Event.
     * @param {OT_EventUpdateArgs} args - Arguments to update one OT_Event.
     * @example
     * // Update one OT_Event
     * const oT_Event = await prisma.oT_Event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OT_EventUpdateArgs>(args: SelectSubset<T, OT_EventUpdateArgs<ExtArgs>>): Prisma__OT_EventClient<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OT_Events.
     * @param {OT_EventDeleteManyArgs} args - Arguments to filter OT_Events to delete.
     * @example
     * // Delete a few OT_Events
     * const { count } = await prisma.oT_Event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OT_EventDeleteManyArgs>(args?: SelectSubset<T, OT_EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OT_Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OT_EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OT_Events
     * const oT_Event = await prisma.oT_Event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OT_EventUpdateManyArgs>(args: SelectSubset<T, OT_EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OT_Events and returns the data updated in the database.
     * @param {OT_EventUpdateManyAndReturnArgs} args - Arguments to update many OT_Events.
     * @example
     * // Update many OT_Events
     * const oT_Event = await prisma.oT_Event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OT_Events and only return the `id`
     * const oT_EventWithIdOnly = await prisma.oT_Event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OT_EventUpdateManyAndReturnArgs>(args: SelectSubset<T, OT_EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OT_Event.
     * @param {OT_EventUpsertArgs} args - Arguments to update or create a OT_Event.
     * @example
     * // Update or create a OT_Event
     * const oT_Event = await prisma.oT_Event.upsert({
     *   create: {
     *     // ... data to create a OT_Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OT_Event we want to update
     *   }
     * })
     */
    upsert<T extends OT_EventUpsertArgs>(args: SelectSubset<T, OT_EventUpsertArgs<ExtArgs>>): Prisma__OT_EventClient<$Result.GetResult<Prisma.$OT_EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OT_Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OT_EventCountArgs} args - Arguments to filter OT_Events to count.
     * @example
     * // Count the number of OT_Events
     * const count = await prisma.oT_Event.count({
     *   where: {
     *     // ... the filter for the OT_Events we want to count
     *   }
     * })
    **/
    count<T extends OT_EventCountArgs>(
      args?: Subset<T, OT_EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OT_EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OT_Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OT_EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OT_EventAggregateArgs>(args: Subset<T, OT_EventAggregateArgs>): Prisma.PrismaPromise<GetOT_EventAggregateType<T>>

    /**
     * Group by OT_Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OT_EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OT_EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OT_EventGroupByArgs['orderBy'] }
        : { orderBy?: OT_EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OT_EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOT_EventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OT_Event model
   */
  readonly fields: OT_EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OT_Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OT_EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OT_Event model
   */
  interface OT_EventFieldRefs {
    readonly id: FieldRef<"OT_Event", 'String'>
    readonly ts: FieldRef<"OT_Event", 'DateTime'>
    readonly protocolo: FieldRef<"OT_Event", 'String'>
    readonly srcIp: FieldRef<"OT_Event", 'String'>
    readonly dstIp: FieldRef<"OT_Event", 'String'>
    readonly funcao: FieldRef<"OT_Event", 'String'>
    readonly valor: FieldRef<"OT_Event", 'String'>
    readonly anomalia: FieldRef<"OT_Event", 'Boolean'>
    readonly assetId: FieldRef<"OT_Event", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OT_Event findUnique
   */
  export type OT_EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventInclude<ExtArgs> | null
    /**
     * Filter, which OT_Event to fetch.
     */
    where: OT_EventWhereUniqueInput
  }

  /**
   * OT_Event findUniqueOrThrow
   */
  export type OT_EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventInclude<ExtArgs> | null
    /**
     * Filter, which OT_Event to fetch.
     */
    where: OT_EventWhereUniqueInput
  }

  /**
   * OT_Event findFirst
   */
  export type OT_EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventInclude<ExtArgs> | null
    /**
     * Filter, which OT_Event to fetch.
     */
    where?: OT_EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OT_Events to fetch.
     */
    orderBy?: OT_EventOrderByWithRelationInput | OT_EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OT_Events.
     */
    cursor?: OT_EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OT_Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OT_Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OT_Events.
     */
    distinct?: OT_EventScalarFieldEnum | OT_EventScalarFieldEnum[]
  }

  /**
   * OT_Event findFirstOrThrow
   */
  export type OT_EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventInclude<ExtArgs> | null
    /**
     * Filter, which OT_Event to fetch.
     */
    where?: OT_EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OT_Events to fetch.
     */
    orderBy?: OT_EventOrderByWithRelationInput | OT_EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OT_Events.
     */
    cursor?: OT_EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OT_Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OT_Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OT_Events.
     */
    distinct?: OT_EventScalarFieldEnum | OT_EventScalarFieldEnum[]
  }

  /**
   * OT_Event findMany
   */
  export type OT_EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventInclude<ExtArgs> | null
    /**
     * Filter, which OT_Events to fetch.
     */
    where?: OT_EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OT_Events to fetch.
     */
    orderBy?: OT_EventOrderByWithRelationInput | OT_EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OT_Events.
     */
    cursor?: OT_EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OT_Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OT_Events.
     */
    skip?: number
    distinct?: OT_EventScalarFieldEnum | OT_EventScalarFieldEnum[]
  }

  /**
   * OT_Event create
   */
  export type OT_EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventInclude<ExtArgs> | null
    /**
     * The data needed to create a OT_Event.
     */
    data: XOR<OT_EventCreateInput, OT_EventUncheckedCreateInput>
  }

  /**
   * OT_Event createMany
   */
  export type OT_EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OT_Events.
     */
    data: OT_EventCreateManyInput | OT_EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OT_Event createManyAndReturn
   */
  export type OT_EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * The data used to create many OT_Events.
     */
    data: OT_EventCreateManyInput | OT_EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OT_Event update
   */
  export type OT_EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventInclude<ExtArgs> | null
    /**
     * The data needed to update a OT_Event.
     */
    data: XOR<OT_EventUpdateInput, OT_EventUncheckedUpdateInput>
    /**
     * Choose, which OT_Event to update.
     */
    where: OT_EventWhereUniqueInput
  }

  /**
   * OT_Event updateMany
   */
  export type OT_EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OT_Events.
     */
    data: XOR<OT_EventUpdateManyMutationInput, OT_EventUncheckedUpdateManyInput>
    /**
     * Filter which OT_Events to update
     */
    where?: OT_EventWhereInput
    /**
     * Limit how many OT_Events to update.
     */
    limit?: number
  }

  /**
   * OT_Event updateManyAndReturn
   */
  export type OT_EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * The data used to update OT_Events.
     */
    data: XOR<OT_EventUpdateManyMutationInput, OT_EventUncheckedUpdateManyInput>
    /**
     * Filter which OT_Events to update
     */
    where?: OT_EventWhereInput
    /**
     * Limit how many OT_Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OT_Event upsert
   */
  export type OT_EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventInclude<ExtArgs> | null
    /**
     * The filter to search for the OT_Event to update in case it exists.
     */
    where: OT_EventWhereUniqueInput
    /**
     * In case the OT_Event found by the `where` argument doesn't exist, create a new OT_Event with this data.
     */
    create: XOR<OT_EventCreateInput, OT_EventUncheckedCreateInput>
    /**
     * In case the OT_Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OT_EventUpdateInput, OT_EventUncheckedUpdateInput>
  }

  /**
   * OT_Event delete
   */
  export type OT_EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventInclude<ExtArgs> | null
    /**
     * Filter which OT_Event to delete.
     */
    where: OT_EventWhereUniqueInput
  }

  /**
   * OT_Event deleteMany
   */
  export type OT_EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OT_Events to delete
     */
    where?: OT_EventWhereInput
    /**
     * Limit how many OT_Events to delete.
     */
    limit?: number
  }

  /**
   * OT_Event without action
   */
  export type OT_EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT_Event
     */
    select?: OT_EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OT_Event
     */
    omit?: OT_EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OT_EventInclude<ExtArgs> | null
  }


  /**
   * Model Sighting
   */

  export type AggregateSighting = {
    _count: SightingCountAggregateOutputType | null
    _avg: SightingAvgAggregateOutputType | null
    _sum: SightingSumAggregateOutputType | null
    _min: SightingMinAggregateOutputType | null
    _max: SightingMaxAggregateOutputType | null
  }

  export type SightingAvgAggregateOutputType = {
    count: number | null
  }

  export type SightingSumAggregateOutputType = {
    count: number | null
  }

  export type SightingMinAggregateOutputType = {
    id: string | null
    ts: Date | null
    count: number | null
    indicatorId: string | null
    assetId: string | null
  }

  export type SightingMaxAggregateOutputType = {
    id: string | null
    ts: Date | null
    count: number | null
    indicatorId: string | null
    assetId: string | null
  }

  export type SightingCountAggregateOutputType = {
    id: number
    ts: number
    count: number
    indicatorId: number
    assetId: number
    _all: number
  }


  export type SightingAvgAggregateInputType = {
    count?: true
  }

  export type SightingSumAggregateInputType = {
    count?: true
  }

  export type SightingMinAggregateInputType = {
    id?: true
    ts?: true
    count?: true
    indicatorId?: true
    assetId?: true
  }

  export type SightingMaxAggregateInputType = {
    id?: true
    ts?: true
    count?: true
    indicatorId?: true
    assetId?: true
  }

  export type SightingCountAggregateInputType = {
    id?: true
    ts?: true
    count?: true
    indicatorId?: true
    assetId?: true
    _all?: true
  }

  export type SightingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sighting to aggregate.
     */
    where?: SightingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sightings to fetch.
     */
    orderBy?: SightingOrderByWithRelationInput | SightingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SightingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sightings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sightings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sightings
    **/
    _count?: true | SightingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SightingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SightingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SightingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SightingMaxAggregateInputType
  }

  export type GetSightingAggregateType<T extends SightingAggregateArgs> = {
        [P in keyof T & keyof AggregateSighting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSighting[P]>
      : GetScalarType<T[P], AggregateSighting[P]>
  }




  export type SightingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SightingWhereInput
    orderBy?: SightingOrderByWithAggregationInput | SightingOrderByWithAggregationInput[]
    by: SightingScalarFieldEnum[] | SightingScalarFieldEnum
    having?: SightingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SightingCountAggregateInputType | true
    _avg?: SightingAvgAggregateInputType
    _sum?: SightingSumAggregateInputType
    _min?: SightingMinAggregateInputType
    _max?: SightingMaxAggregateInputType
  }

  export type SightingGroupByOutputType = {
    id: string
    ts: Date
    count: number
    indicatorId: string
    assetId: string
    _count: SightingCountAggregateOutputType | null
    _avg: SightingAvgAggregateOutputType | null
    _sum: SightingSumAggregateOutputType | null
    _min: SightingMinAggregateOutputType | null
    _max: SightingMaxAggregateOutputType | null
  }

  type GetSightingGroupByPayload<T extends SightingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SightingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SightingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SightingGroupByOutputType[P]>
            : GetScalarType<T[P], SightingGroupByOutputType[P]>
        }
      >
    >


  export type SightingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    count?: boolean
    indicatorId?: boolean
    assetId?: boolean
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sighting"]>

  export type SightingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    count?: boolean
    indicatorId?: boolean
    assetId?: boolean
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sighting"]>

  export type SightingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    count?: boolean
    indicatorId?: boolean
    assetId?: boolean
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sighting"]>

  export type SightingSelectScalar = {
    id?: boolean
    ts?: boolean
    count?: boolean
    indicatorId?: boolean
    assetId?: boolean
  }

  export type SightingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ts" | "count" | "indicatorId" | "assetId", ExtArgs["result"]["sighting"]>
  export type SightingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }
  export type SightingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }
  export type SightingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }

  export type $SightingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sighting"
    objects: {
      indicator: Prisma.$IndicatorPayload<ExtArgs>
      asset: Prisma.$AssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ts: Date
      count: number
      indicatorId: string
      assetId: string
    }, ExtArgs["result"]["sighting"]>
    composites: {}
  }

  type SightingGetPayload<S extends boolean | null | undefined | SightingDefaultArgs> = $Result.GetResult<Prisma.$SightingPayload, S>

  type SightingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SightingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SightingCountAggregateInputType | true
    }

  export interface SightingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sighting'], meta: { name: 'Sighting' } }
    /**
     * Find zero or one Sighting that matches the filter.
     * @param {SightingFindUniqueArgs} args - Arguments to find a Sighting
     * @example
     * // Get one Sighting
     * const sighting = await prisma.sighting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SightingFindUniqueArgs>(args: SelectSubset<T, SightingFindUniqueArgs<ExtArgs>>): Prisma__SightingClient<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sighting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SightingFindUniqueOrThrowArgs} args - Arguments to find a Sighting
     * @example
     * // Get one Sighting
     * const sighting = await prisma.sighting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SightingFindUniqueOrThrowArgs>(args: SelectSubset<T, SightingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SightingClient<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sighting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SightingFindFirstArgs} args - Arguments to find a Sighting
     * @example
     * // Get one Sighting
     * const sighting = await prisma.sighting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SightingFindFirstArgs>(args?: SelectSubset<T, SightingFindFirstArgs<ExtArgs>>): Prisma__SightingClient<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sighting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SightingFindFirstOrThrowArgs} args - Arguments to find a Sighting
     * @example
     * // Get one Sighting
     * const sighting = await prisma.sighting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SightingFindFirstOrThrowArgs>(args?: SelectSubset<T, SightingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SightingClient<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sightings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SightingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sightings
     * const sightings = await prisma.sighting.findMany()
     * 
     * // Get first 10 Sightings
     * const sightings = await prisma.sighting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sightingWithIdOnly = await prisma.sighting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SightingFindManyArgs>(args?: SelectSubset<T, SightingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sighting.
     * @param {SightingCreateArgs} args - Arguments to create a Sighting.
     * @example
     * // Create one Sighting
     * const Sighting = await prisma.sighting.create({
     *   data: {
     *     // ... data to create a Sighting
     *   }
     * })
     * 
     */
    create<T extends SightingCreateArgs>(args: SelectSubset<T, SightingCreateArgs<ExtArgs>>): Prisma__SightingClient<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sightings.
     * @param {SightingCreateManyArgs} args - Arguments to create many Sightings.
     * @example
     * // Create many Sightings
     * const sighting = await prisma.sighting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SightingCreateManyArgs>(args?: SelectSubset<T, SightingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sightings and returns the data saved in the database.
     * @param {SightingCreateManyAndReturnArgs} args - Arguments to create many Sightings.
     * @example
     * // Create many Sightings
     * const sighting = await prisma.sighting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sightings and only return the `id`
     * const sightingWithIdOnly = await prisma.sighting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SightingCreateManyAndReturnArgs>(args?: SelectSubset<T, SightingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sighting.
     * @param {SightingDeleteArgs} args - Arguments to delete one Sighting.
     * @example
     * // Delete one Sighting
     * const Sighting = await prisma.sighting.delete({
     *   where: {
     *     // ... filter to delete one Sighting
     *   }
     * })
     * 
     */
    delete<T extends SightingDeleteArgs>(args: SelectSubset<T, SightingDeleteArgs<ExtArgs>>): Prisma__SightingClient<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sighting.
     * @param {SightingUpdateArgs} args - Arguments to update one Sighting.
     * @example
     * // Update one Sighting
     * const sighting = await prisma.sighting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SightingUpdateArgs>(args: SelectSubset<T, SightingUpdateArgs<ExtArgs>>): Prisma__SightingClient<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sightings.
     * @param {SightingDeleteManyArgs} args - Arguments to filter Sightings to delete.
     * @example
     * // Delete a few Sightings
     * const { count } = await prisma.sighting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SightingDeleteManyArgs>(args?: SelectSubset<T, SightingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sightings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SightingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sightings
     * const sighting = await prisma.sighting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SightingUpdateManyArgs>(args: SelectSubset<T, SightingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sightings and returns the data updated in the database.
     * @param {SightingUpdateManyAndReturnArgs} args - Arguments to update many Sightings.
     * @example
     * // Update many Sightings
     * const sighting = await prisma.sighting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sightings and only return the `id`
     * const sightingWithIdOnly = await prisma.sighting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SightingUpdateManyAndReturnArgs>(args: SelectSubset<T, SightingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sighting.
     * @param {SightingUpsertArgs} args - Arguments to update or create a Sighting.
     * @example
     * // Update or create a Sighting
     * const sighting = await prisma.sighting.upsert({
     *   create: {
     *     // ... data to create a Sighting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sighting we want to update
     *   }
     * })
     */
    upsert<T extends SightingUpsertArgs>(args: SelectSubset<T, SightingUpsertArgs<ExtArgs>>): Prisma__SightingClient<$Result.GetResult<Prisma.$SightingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sightings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SightingCountArgs} args - Arguments to filter Sightings to count.
     * @example
     * // Count the number of Sightings
     * const count = await prisma.sighting.count({
     *   where: {
     *     // ... the filter for the Sightings we want to count
     *   }
     * })
    **/
    count<T extends SightingCountArgs>(
      args?: Subset<T, SightingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SightingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sighting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SightingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SightingAggregateArgs>(args: Subset<T, SightingAggregateArgs>): Prisma.PrismaPromise<GetSightingAggregateType<T>>

    /**
     * Group by Sighting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SightingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SightingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SightingGroupByArgs['orderBy'] }
        : { orderBy?: SightingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SightingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSightingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sighting model
   */
  readonly fields: SightingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sighting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SightingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicator<T extends IndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorDefaultArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sighting model
   */
  interface SightingFieldRefs {
    readonly id: FieldRef<"Sighting", 'String'>
    readonly ts: FieldRef<"Sighting", 'DateTime'>
    readonly count: FieldRef<"Sighting", 'Int'>
    readonly indicatorId: FieldRef<"Sighting", 'String'>
    readonly assetId: FieldRef<"Sighting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sighting findUnique
   */
  export type SightingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
    /**
     * Filter, which Sighting to fetch.
     */
    where: SightingWhereUniqueInput
  }

  /**
   * Sighting findUniqueOrThrow
   */
  export type SightingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
    /**
     * Filter, which Sighting to fetch.
     */
    where: SightingWhereUniqueInput
  }

  /**
   * Sighting findFirst
   */
  export type SightingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
    /**
     * Filter, which Sighting to fetch.
     */
    where?: SightingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sightings to fetch.
     */
    orderBy?: SightingOrderByWithRelationInput | SightingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sightings.
     */
    cursor?: SightingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sightings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sightings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sightings.
     */
    distinct?: SightingScalarFieldEnum | SightingScalarFieldEnum[]
  }

  /**
   * Sighting findFirstOrThrow
   */
  export type SightingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
    /**
     * Filter, which Sighting to fetch.
     */
    where?: SightingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sightings to fetch.
     */
    orderBy?: SightingOrderByWithRelationInput | SightingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sightings.
     */
    cursor?: SightingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sightings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sightings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sightings.
     */
    distinct?: SightingScalarFieldEnum | SightingScalarFieldEnum[]
  }

  /**
   * Sighting findMany
   */
  export type SightingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
    /**
     * Filter, which Sightings to fetch.
     */
    where?: SightingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sightings to fetch.
     */
    orderBy?: SightingOrderByWithRelationInput | SightingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sightings.
     */
    cursor?: SightingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sightings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sightings.
     */
    skip?: number
    distinct?: SightingScalarFieldEnum | SightingScalarFieldEnum[]
  }

  /**
   * Sighting create
   */
  export type SightingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
    /**
     * The data needed to create a Sighting.
     */
    data: XOR<SightingCreateInput, SightingUncheckedCreateInput>
  }

  /**
   * Sighting createMany
   */
  export type SightingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sightings.
     */
    data: SightingCreateManyInput | SightingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sighting createManyAndReturn
   */
  export type SightingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * The data used to create many Sightings.
     */
    data: SightingCreateManyInput | SightingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sighting update
   */
  export type SightingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
    /**
     * The data needed to update a Sighting.
     */
    data: XOR<SightingUpdateInput, SightingUncheckedUpdateInput>
    /**
     * Choose, which Sighting to update.
     */
    where: SightingWhereUniqueInput
  }

  /**
   * Sighting updateMany
   */
  export type SightingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sightings.
     */
    data: XOR<SightingUpdateManyMutationInput, SightingUncheckedUpdateManyInput>
    /**
     * Filter which Sightings to update
     */
    where?: SightingWhereInput
    /**
     * Limit how many Sightings to update.
     */
    limit?: number
  }

  /**
   * Sighting updateManyAndReturn
   */
  export type SightingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * The data used to update Sightings.
     */
    data: XOR<SightingUpdateManyMutationInput, SightingUncheckedUpdateManyInput>
    /**
     * Filter which Sightings to update
     */
    where?: SightingWhereInput
    /**
     * Limit how many Sightings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sighting upsert
   */
  export type SightingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
    /**
     * The filter to search for the Sighting to update in case it exists.
     */
    where: SightingWhereUniqueInput
    /**
     * In case the Sighting found by the `where` argument doesn't exist, create a new Sighting with this data.
     */
    create: XOR<SightingCreateInput, SightingUncheckedCreateInput>
    /**
     * In case the Sighting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SightingUpdateInput, SightingUncheckedUpdateInput>
  }

  /**
   * Sighting delete
   */
  export type SightingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
    /**
     * Filter which Sighting to delete.
     */
    where: SightingWhereUniqueInput
  }

  /**
   * Sighting deleteMany
   */
  export type SightingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sightings to delete
     */
    where?: SightingWhereInput
    /**
     * Limit how many Sightings to delete.
     */
    limit?: number
  }

  /**
   * Sighting without action
   */
  export type SightingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sighting
     */
    select?: SightingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sighting
     */
    omit?: SightingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SightingInclude<ExtArgs> | null
  }


  /**
   * Model Case
   */

  export type AggregateCase = {
    _count: CaseCountAggregateOutputType | null
    _min: CaseMinAggregateOutputType | null
    _max: CaseMaxAggregateOutputType | null
  }

  export type CaseMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    status: string | null
    responsavel: string | null
    criadoEm: Date | null
  }

  export type CaseMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    status: string | null
    responsavel: string | null
    criadoEm: Date | null
  }

  export type CaseCountAggregateOutputType = {
    id: number
    titulo: number
    status: number
    responsavel: number
    criadoEm: number
    _all: number
  }


  export type CaseMinAggregateInputType = {
    id?: true
    titulo?: true
    status?: true
    responsavel?: true
    criadoEm?: true
  }

  export type CaseMaxAggregateInputType = {
    id?: true
    titulo?: true
    status?: true
    responsavel?: true
    criadoEm?: true
  }

  export type CaseCountAggregateInputType = {
    id?: true
    titulo?: true
    status?: true
    responsavel?: true
    criadoEm?: true
    _all?: true
  }

  export type CaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Case to aggregate.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cases
    **/
    _count?: true | CaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaseMaxAggregateInputType
  }

  export type GetCaseAggregateType<T extends CaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCase[P]>
      : GetScalarType<T[P], AggregateCase[P]>
  }




  export type CaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseWhereInput
    orderBy?: CaseOrderByWithAggregationInput | CaseOrderByWithAggregationInput[]
    by: CaseScalarFieldEnum[] | CaseScalarFieldEnum
    having?: CaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseCountAggregateInputType | true
    _min?: CaseMinAggregateInputType
    _max?: CaseMaxAggregateInputType
  }

  export type CaseGroupByOutputType = {
    id: string
    titulo: string
    status: string
    responsavel: string | null
    criadoEm: Date
    _count: CaseCountAggregateOutputType | null
    _min: CaseMinAggregateOutputType | null
    _max: CaseMaxAggregateOutputType | null
  }

  type GetCaseGroupByPayload<T extends CaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseGroupByOutputType[P]>
            : GetScalarType<T[P], CaseGroupByOutputType[P]>
        }
      >
    >


  export type CaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    status?: boolean
    responsavel?: boolean
    criadoEm?: boolean
    evidencias?: boolean | Case$evidenciasArgs<ExtArgs>
    _count?: boolean | CaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["case"]>

  export type CaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    status?: boolean
    responsavel?: boolean
    criadoEm?: boolean
  }, ExtArgs["result"]["case"]>

  export type CaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    status?: boolean
    responsavel?: boolean
    criadoEm?: boolean
  }, ExtArgs["result"]["case"]>

  export type CaseSelectScalar = {
    id?: boolean
    titulo?: boolean
    status?: boolean
    responsavel?: boolean
    criadoEm?: boolean
  }

  export type CaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "status" | "responsavel" | "criadoEm", ExtArgs["result"]["case"]>
  export type CaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidencias?: boolean | Case$evidenciasArgs<ExtArgs>
    _count?: boolean | CaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Case"
    objects: {
      evidencias: Prisma.$EvidencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      status: string
      responsavel: string | null
      criadoEm: Date
    }, ExtArgs["result"]["case"]>
    composites: {}
  }

  type CaseGetPayload<S extends boolean | null | undefined | CaseDefaultArgs> = $Result.GetResult<Prisma.$CasePayload, S>

  type CaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseCountAggregateInputType | true
    }

  export interface CaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Case'], meta: { name: 'Case' } }
    /**
     * Find zero or one Case that matches the filter.
     * @param {CaseFindUniqueArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseFindUniqueArgs>(args: SelectSubset<T, CaseFindUniqueArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Case that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseFindUniqueOrThrowArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseFindFirstArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseFindFirstArgs>(args?: SelectSubset<T, CaseFindFirstArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseFindFirstOrThrowArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cases
     * const cases = await prisma.case.findMany()
     * 
     * // Get first 10 Cases
     * const cases = await prisma.case.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caseWithIdOnly = await prisma.case.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaseFindManyArgs>(args?: SelectSubset<T, CaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Case.
     * @param {CaseCreateArgs} args - Arguments to create a Case.
     * @example
     * // Create one Case
     * const Case = await prisma.case.create({
     *   data: {
     *     // ... data to create a Case
     *   }
     * })
     * 
     */
    create<T extends CaseCreateArgs>(args: SelectSubset<T, CaseCreateArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cases.
     * @param {CaseCreateManyArgs} args - Arguments to create many Cases.
     * @example
     * // Create many Cases
     * const case = await prisma.case.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaseCreateManyArgs>(args?: SelectSubset<T, CaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cases and returns the data saved in the database.
     * @param {CaseCreateManyAndReturnArgs} args - Arguments to create many Cases.
     * @example
     * // Create many Cases
     * const case = await prisma.case.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cases and only return the `id`
     * const caseWithIdOnly = await prisma.case.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Case.
     * @param {CaseDeleteArgs} args - Arguments to delete one Case.
     * @example
     * // Delete one Case
     * const Case = await prisma.case.delete({
     *   where: {
     *     // ... filter to delete one Case
     *   }
     * })
     * 
     */
    delete<T extends CaseDeleteArgs>(args: SelectSubset<T, CaseDeleteArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Case.
     * @param {CaseUpdateArgs} args - Arguments to update one Case.
     * @example
     * // Update one Case
     * const case = await prisma.case.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaseUpdateArgs>(args: SelectSubset<T, CaseUpdateArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cases.
     * @param {CaseDeleteManyArgs} args - Arguments to filter Cases to delete.
     * @example
     * // Delete a few Cases
     * const { count } = await prisma.case.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaseDeleteManyArgs>(args?: SelectSubset<T, CaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cases
     * const case = await prisma.case.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaseUpdateManyArgs>(args: SelectSubset<T, CaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cases and returns the data updated in the database.
     * @param {CaseUpdateManyAndReturnArgs} args - Arguments to update many Cases.
     * @example
     * // Update many Cases
     * const case = await prisma.case.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cases and only return the `id`
     * const caseWithIdOnly = await prisma.case.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CaseUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Case.
     * @param {CaseUpsertArgs} args - Arguments to update or create a Case.
     * @example
     * // Update or create a Case
     * const case = await prisma.case.upsert({
     *   create: {
     *     // ... data to create a Case
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Case we want to update
     *   }
     * })
     */
    upsert<T extends CaseUpsertArgs>(args: SelectSubset<T, CaseUpsertArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseCountArgs} args - Arguments to filter Cases to count.
     * @example
     * // Count the number of Cases
     * const count = await prisma.case.count({
     *   where: {
     *     // ... the filter for the Cases we want to count
     *   }
     * })
    **/
    count<T extends CaseCountArgs>(
      args?: Subset<T, CaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Case.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseAggregateArgs>(args: Subset<T, CaseAggregateArgs>): Prisma.PrismaPromise<GetCaseAggregateType<T>>

    /**
     * Group by Case.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseGroupByArgs['orderBy'] }
        : { orderBy?: CaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Case model
   */
  readonly fields: CaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Case.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evidencias<T extends Case$evidenciasArgs<ExtArgs> = {}>(args?: Subset<T, Case$evidenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Case model
   */
  interface CaseFieldRefs {
    readonly id: FieldRef<"Case", 'String'>
    readonly titulo: FieldRef<"Case", 'String'>
    readonly status: FieldRef<"Case", 'String'>
    readonly responsavel: FieldRef<"Case", 'String'>
    readonly criadoEm: FieldRef<"Case", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Case findUnique
   */
  export type CaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case findUniqueOrThrow
   */
  export type CaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case findFirst
   */
  export type CaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cases.
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cases.
     */
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * Case findFirstOrThrow
   */
  export type CaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cases.
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cases.
     */
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * Case findMany
   */
  export type CaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Cases to fetch.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cases.
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * Case create
   */
  export type CaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Case.
     */
    data: XOR<CaseCreateInput, CaseUncheckedCreateInput>
  }

  /**
   * Case createMany
   */
  export type CaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cases.
     */
    data: CaseCreateManyInput | CaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Case createManyAndReturn
   */
  export type CaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * The data used to create many Cases.
     */
    data: CaseCreateManyInput | CaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Case update
   */
  export type CaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Case.
     */
    data: XOR<CaseUpdateInput, CaseUncheckedUpdateInput>
    /**
     * Choose, which Case to update.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case updateMany
   */
  export type CaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cases.
     */
    data: XOR<CaseUpdateManyMutationInput, CaseUncheckedUpdateManyInput>
    /**
     * Filter which Cases to update
     */
    where?: CaseWhereInput
    /**
     * Limit how many Cases to update.
     */
    limit?: number
  }

  /**
   * Case updateManyAndReturn
   */
  export type CaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * The data used to update Cases.
     */
    data: XOR<CaseUpdateManyMutationInput, CaseUncheckedUpdateManyInput>
    /**
     * Filter which Cases to update
     */
    where?: CaseWhereInput
    /**
     * Limit how many Cases to update.
     */
    limit?: number
  }

  /**
   * Case upsert
   */
  export type CaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Case to update in case it exists.
     */
    where: CaseWhereUniqueInput
    /**
     * In case the Case found by the `where` argument doesn't exist, create a new Case with this data.
     */
    create: XOR<CaseCreateInput, CaseUncheckedCreateInput>
    /**
     * In case the Case was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseUpdateInput, CaseUncheckedUpdateInput>
  }

  /**
   * Case delete
   */
  export type CaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter which Case to delete.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case deleteMany
   */
  export type CaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cases to delete
     */
    where?: CaseWhereInput
    /**
     * Limit how many Cases to delete.
     */
    limit?: number
  }

  /**
   * Case.evidencias
   */
  export type Case$evidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    where?: EvidenceWhereInput
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    cursor?: EvidenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Case without action
   */
  export type CaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
  }


  /**
   * Model Evidence
   */

  export type AggregateEvidence = {
    _count: EvidenceCountAggregateOutputType | null
    _avg: EvidenceAvgAggregateOutputType | null
    _sum: EvidenceSumAggregateOutputType | null
    _min: EvidenceMinAggregateOutputType | null
    _max: EvidenceMaxAggregateOutputType | null
  }

  export type EvidenceAvgAggregateOutputType = {
    tamanho: number | null
  }

  export type EvidenceSumAggregateOutputType = {
    tamanho: number | null
  }

  export type EvidenceMinAggregateOutputType = {
    id: string | null
    tipo: string | null
    caminho: string | null
    hashSha256: string | null
    coletadoEm: Date | null
    tamanho: number | null
    caseId: string | null
  }

  export type EvidenceMaxAggregateOutputType = {
    id: string | null
    tipo: string | null
    caminho: string | null
    hashSha256: string | null
    coletadoEm: Date | null
    tamanho: number | null
    caseId: string | null
  }

  export type EvidenceCountAggregateOutputType = {
    id: number
    tipo: number
    caminho: number
    hashSha256: number
    coletadoEm: number
    tamanho: number
    caseId: number
    _all: number
  }


  export type EvidenceAvgAggregateInputType = {
    tamanho?: true
  }

  export type EvidenceSumAggregateInputType = {
    tamanho?: true
  }

  export type EvidenceMinAggregateInputType = {
    id?: true
    tipo?: true
    caminho?: true
    hashSha256?: true
    coletadoEm?: true
    tamanho?: true
    caseId?: true
  }

  export type EvidenceMaxAggregateInputType = {
    id?: true
    tipo?: true
    caminho?: true
    hashSha256?: true
    coletadoEm?: true
    tamanho?: true
    caseId?: true
  }

  export type EvidenceCountAggregateInputType = {
    id?: true
    tipo?: true
    caminho?: true
    hashSha256?: true
    coletadoEm?: true
    tamanho?: true
    caseId?: true
    _all?: true
  }

  export type EvidenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidence to aggregate.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evidences
    **/
    _count?: true | EvidenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvidenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvidenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvidenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvidenceMaxAggregateInputType
  }

  export type GetEvidenceAggregateType<T extends EvidenceAggregateArgs> = {
        [P in keyof T & keyof AggregateEvidence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidence[P]>
      : GetScalarType<T[P], AggregateEvidence[P]>
  }




  export type EvidenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceWhereInput
    orderBy?: EvidenceOrderByWithAggregationInput | EvidenceOrderByWithAggregationInput[]
    by: EvidenceScalarFieldEnum[] | EvidenceScalarFieldEnum
    having?: EvidenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvidenceCountAggregateInputType | true
    _avg?: EvidenceAvgAggregateInputType
    _sum?: EvidenceSumAggregateInputType
    _min?: EvidenceMinAggregateInputType
    _max?: EvidenceMaxAggregateInputType
  }

  export type EvidenceGroupByOutputType = {
    id: string
    tipo: string
    caminho: string
    hashSha256: string
    coletadoEm: Date
    tamanho: number | null
    caseId: string
    _count: EvidenceCountAggregateOutputType | null
    _avg: EvidenceAvgAggregateOutputType | null
    _sum: EvidenceSumAggregateOutputType | null
    _min: EvidenceMinAggregateOutputType | null
    _max: EvidenceMaxAggregateOutputType | null
  }

  type GetEvidenceGroupByPayload<T extends EvidenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvidenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvidenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenceGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenceGroupByOutputType[P]>
        }
      >
    >


  export type EvidenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    caminho?: boolean
    hashSha256?: boolean
    coletadoEm?: boolean
    tamanho?: boolean
    caseId?: boolean
    case?: boolean | CaseDefaultArgs<ExtArgs>
    custodies?: boolean | Evidence$custodiesArgs<ExtArgs>
    _count?: boolean | EvidenceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidence"]>

  export type EvidenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    caminho?: boolean
    hashSha256?: boolean
    coletadoEm?: boolean
    tamanho?: boolean
    caseId?: boolean
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidence"]>

  export type EvidenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    caminho?: boolean
    hashSha256?: boolean
    coletadoEm?: boolean
    tamanho?: boolean
    caseId?: boolean
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidence"]>

  export type EvidenceSelectScalar = {
    id?: boolean
    tipo?: boolean
    caminho?: boolean
    hashSha256?: boolean
    coletadoEm?: boolean
    tamanho?: boolean
    caseId?: boolean
  }

  export type EvidenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "caminho" | "hashSha256" | "coletadoEm" | "tamanho" | "caseId", ExtArgs["result"]["evidence"]>
  export type EvidenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | CaseDefaultArgs<ExtArgs>
    custodies?: boolean | Evidence$custodiesArgs<ExtArgs>
    _count?: boolean | EvidenceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EvidenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }
  export type EvidenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | CaseDefaultArgs<ExtArgs>
  }

  export type $EvidencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evidence"
    objects: {
      case: Prisma.$CasePayload<ExtArgs>
      custodies: Prisma.$CustodyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tipo: string
      caminho: string
      hashSha256: string
      coletadoEm: Date
      tamanho: number | null
      caseId: string
    }, ExtArgs["result"]["evidence"]>
    composites: {}
  }

  type EvidenceGetPayload<S extends boolean | null | undefined | EvidenceDefaultArgs> = $Result.GetResult<Prisma.$EvidencePayload, S>

  type EvidenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvidenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvidenceCountAggregateInputType | true
    }

  export interface EvidenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evidence'], meta: { name: 'Evidence' } }
    /**
     * Find zero or one Evidence that matches the filter.
     * @param {EvidenceFindUniqueArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenceFindUniqueArgs>(args: SelectSubset<T, EvidenceFindUniqueArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evidence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvidenceFindUniqueOrThrowArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenceFindUniqueOrThrowArgs>(args: SelectSubset<T, EvidenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evidence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindFirstArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenceFindFirstArgs>(args?: SelectSubset<T, EvidenceFindFirstArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evidence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindFirstOrThrowArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenceFindFirstOrThrowArgs>(args?: SelectSubset<T, EvidenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evidences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evidences
     * const evidences = await prisma.evidence.findMany()
     * 
     * // Get first 10 Evidences
     * const evidences = await prisma.evidence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evidenceWithIdOnly = await prisma.evidence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvidenceFindManyArgs>(args?: SelectSubset<T, EvidenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evidence.
     * @param {EvidenceCreateArgs} args - Arguments to create a Evidence.
     * @example
     * // Create one Evidence
     * const Evidence = await prisma.evidence.create({
     *   data: {
     *     // ... data to create a Evidence
     *   }
     * })
     * 
     */
    create<T extends EvidenceCreateArgs>(args: SelectSubset<T, EvidenceCreateArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evidences.
     * @param {EvidenceCreateManyArgs} args - Arguments to create many Evidences.
     * @example
     * // Create many Evidences
     * const evidence = await prisma.evidence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvidenceCreateManyArgs>(args?: SelectSubset<T, EvidenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evidences and returns the data saved in the database.
     * @param {EvidenceCreateManyAndReturnArgs} args - Arguments to create many Evidences.
     * @example
     * // Create many Evidences
     * const evidence = await prisma.evidence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evidences and only return the `id`
     * const evidenceWithIdOnly = await prisma.evidence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvidenceCreateManyAndReturnArgs>(args?: SelectSubset<T, EvidenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Evidence.
     * @param {EvidenceDeleteArgs} args - Arguments to delete one Evidence.
     * @example
     * // Delete one Evidence
     * const Evidence = await prisma.evidence.delete({
     *   where: {
     *     // ... filter to delete one Evidence
     *   }
     * })
     * 
     */
    delete<T extends EvidenceDeleteArgs>(args: SelectSubset<T, EvidenceDeleteArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evidence.
     * @param {EvidenceUpdateArgs} args - Arguments to update one Evidence.
     * @example
     * // Update one Evidence
     * const evidence = await prisma.evidence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvidenceUpdateArgs>(args: SelectSubset<T, EvidenceUpdateArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evidences.
     * @param {EvidenceDeleteManyArgs} args - Arguments to filter Evidences to delete.
     * @example
     * // Delete a few Evidences
     * const { count } = await prisma.evidence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvidenceDeleteManyArgs>(args?: SelectSubset<T, EvidenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evidences
     * const evidence = await prisma.evidence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvidenceUpdateManyArgs>(args: SelectSubset<T, EvidenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evidences and returns the data updated in the database.
     * @param {EvidenceUpdateManyAndReturnArgs} args - Arguments to update many Evidences.
     * @example
     * // Update many Evidences
     * const evidence = await prisma.evidence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Evidences and only return the `id`
     * const evidenceWithIdOnly = await prisma.evidence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvidenceUpdateManyAndReturnArgs>(args: SelectSubset<T, EvidenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Evidence.
     * @param {EvidenceUpsertArgs} args - Arguments to update or create a Evidence.
     * @example
     * // Update or create a Evidence
     * const evidence = await prisma.evidence.upsert({
     *   create: {
     *     // ... data to create a Evidence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evidence we want to update
     *   }
     * })
     */
    upsert<T extends EvidenceUpsertArgs>(args: SelectSubset<T, EvidenceUpsertArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceCountArgs} args - Arguments to filter Evidences to count.
     * @example
     * // Count the number of Evidences
     * const count = await prisma.evidence.count({
     *   where: {
     *     // ... the filter for the Evidences we want to count
     *   }
     * })
    **/
    count<T extends EvidenceCountArgs>(
      args?: Subset<T, EvidenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvidenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvidenceAggregateArgs>(args: Subset<T, EvidenceAggregateArgs>): Prisma.PrismaPromise<GetEvidenceAggregateType<T>>

    /**
     * Group by Evidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvidenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenceGroupByArgs['orderBy'] }
        : { orderBy?: EvidenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvidenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvidenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evidence model
   */
  readonly fields: EvidenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evidence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case<T extends CaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaseDefaultArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    custodies<T extends Evidence$custodiesArgs<ExtArgs> = {}>(args?: Subset<T, Evidence$custodiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evidence model
   */
  interface EvidenceFieldRefs {
    readonly id: FieldRef<"Evidence", 'String'>
    readonly tipo: FieldRef<"Evidence", 'String'>
    readonly caminho: FieldRef<"Evidence", 'String'>
    readonly hashSha256: FieldRef<"Evidence", 'String'>
    readonly coletadoEm: FieldRef<"Evidence", 'DateTime'>
    readonly tamanho: FieldRef<"Evidence", 'Int'>
    readonly caseId: FieldRef<"Evidence", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Evidence findUnique
   */
  export type EvidenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence findUniqueOrThrow
   */
  export type EvidenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence findFirst
   */
  export type EvidenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidences.
     */
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence findFirstOrThrow
   */
  export type EvidenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidences.
     */
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence findMany
   */
  export type EvidenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidences to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence create
   */
  export type EvidenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Evidence.
     */
    data: XOR<EvidenceCreateInput, EvidenceUncheckedCreateInput>
  }

  /**
   * Evidence createMany
   */
  export type EvidenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evidences.
     */
    data: EvidenceCreateManyInput | EvidenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evidence createManyAndReturn
   */
  export type EvidenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * The data used to create many Evidences.
     */
    data: EvidenceCreateManyInput | EvidenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evidence update
   */
  export type EvidenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Evidence.
     */
    data: XOR<EvidenceUpdateInput, EvidenceUncheckedUpdateInput>
    /**
     * Choose, which Evidence to update.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence updateMany
   */
  export type EvidenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evidences.
     */
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyInput>
    /**
     * Filter which Evidences to update
     */
    where?: EvidenceWhereInput
    /**
     * Limit how many Evidences to update.
     */
    limit?: number
  }

  /**
   * Evidence updateManyAndReturn
   */
  export type EvidenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * The data used to update Evidences.
     */
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyInput>
    /**
     * Filter which Evidences to update
     */
    where?: EvidenceWhereInput
    /**
     * Limit how many Evidences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evidence upsert
   */
  export type EvidenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Evidence to update in case it exists.
     */
    where: EvidenceWhereUniqueInput
    /**
     * In case the Evidence found by the `where` argument doesn't exist, create a new Evidence with this data.
     */
    create: XOR<EvidenceCreateInput, EvidenceUncheckedCreateInput>
    /**
     * In case the Evidence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenceUpdateInput, EvidenceUncheckedUpdateInput>
  }

  /**
   * Evidence delete
   */
  export type EvidenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter which Evidence to delete.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence deleteMany
   */
  export type EvidenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidences to delete
     */
    where?: EvidenceWhereInput
    /**
     * Limit how many Evidences to delete.
     */
    limit?: number
  }

  /**
   * Evidence.custodies
   */
  export type Evidence$custodiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyInclude<ExtArgs> | null
    where?: CustodyWhereInput
    orderBy?: CustodyOrderByWithRelationInput | CustodyOrderByWithRelationInput[]
    cursor?: CustodyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustodyScalarFieldEnum | CustodyScalarFieldEnum[]
  }

  /**
   * Evidence without action
   */
  export type EvidenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
  }


  /**
   * Model Custody
   */

  export type AggregateCustody = {
    _count: CustodyCountAggregateOutputType | null
    _min: CustodyMinAggregateOutputType | null
    _max: CustodyMaxAggregateOutputType | null
  }

  export type CustodyMinAggregateOutputType = {
    id: string | null
    acao: string | null
    ator: string | null
    local: string | null
    ts: Date | null
    assinatura: string | null
    evidenceId: string | null
  }

  export type CustodyMaxAggregateOutputType = {
    id: string | null
    acao: string | null
    ator: string | null
    local: string | null
    ts: Date | null
    assinatura: string | null
    evidenceId: string | null
  }

  export type CustodyCountAggregateOutputType = {
    id: number
    acao: number
    ator: number
    local: number
    ts: number
    assinatura: number
    evidenceId: number
    _all: number
  }


  export type CustodyMinAggregateInputType = {
    id?: true
    acao?: true
    ator?: true
    local?: true
    ts?: true
    assinatura?: true
    evidenceId?: true
  }

  export type CustodyMaxAggregateInputType = {
    id?: true
    acao?: true
    ator?: true
    local?: true
    ts?: true
    assinatura?: true
    evidenceId?: true
  }

  export type CustodyCountAggregateInputType = {
    id?: true
    acao?: true
    ator?: true
    local?: true
    ts?: true
    assinatura?: true
    evidenceId?: true
    _all?: true
  }

  export type CustodyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Custody to aggregate.
     */
    where?: CustodyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Custodies to fetch.
     */
    orderBy?: CustodyOrderByWithRelationInput | CustodyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustodyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Custodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Custodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Custodies
    **/
    _count?: true | CustodyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustodyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustodyMaxAggregateInputType
  }

  export type GetCustodyAggregateType<T extends CustodyAggregateArgs> = {
        [P in keyof T & keyof AggregateCustody]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustody[P]>
      : GetScalarType<T[P], AggregateCustody[P]>
  }




  export type CustodyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustodyWhereInput
    orderBy?: CustodyOrderByWithAggregationInput | CustodyOrderByWithAggregationInput[]
    by: CustodyScalarFieldEnum[] | CustodyScalarFieldEnum
    having?: CustodyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustodyCountAggregateInputType | true
    _min?: CustodyMinAggregateInputType
    _max?: CustodyMaxAggregateInputType
  }

  export type CustodyGroupByOutputType = {
    id: string
    acao: string
    ator: string
    local: string | null
    ts: Date
    assinatura: string | null
    evidenceId: string
    _count: CustodyCountAggregateOutputType | null
    _min: CustodyMinAggregateOutputType | null
    _max: CustodyMaxAggregateOutputType | null
  }

  type GetCustodyGroupByPayload<T extends CustodyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustodyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustodyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustodyGroupByOutputType[P]>
            : GetScalarType<T[P], CustodyGroupByOutputType[P]>
        }
      >
    >


  export type CustodySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acao?: boolean
    ator?: boolean
    local?: boolean
    ts?: boolean
    assinatura?: boolean
    evidenceId?: boolean
    evidence?: boolean | EvidenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["custody"]>

  export type CustodySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acao?: boolean
    ator?: boolean
    local?: boolean
    ts?: boolean
    assinatura?: boolean
    evidenceId?: boolean
    evidence?: boolean | EvidenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["custody"]>

  export type CustodySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acao?: boolean
    ator?: boolean
    local?: boolean
    ts?: boolean
    assinatura?: boolean
    evidenceId?: boolean
    evidence?: boolean | EvidenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["custody"]>

  export type CustodySelectScalar = {
    id?: boolean
    acao?: boolean
    ator?: boolean
    local?: boolean
    ts?: boolean
    assinatura?: boolean
    evidenceId?: boolean
  }

  export type CustodyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "acao" | "ator" | "local" | "ts" | "assinatura" | "evidenceId", ExtArgs["result"]["custody"]>
  export type CustodyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidence?: boolean | EvidenceDefaultArgs<ExtArgs>
  }
  export type CustodyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidence?: boolean | EvidenceDefaultArgs<ExtArgs>
  }
  export type CustodyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidence?: boolean | EvidenceDefaultArgs<ExtArgs>
  }

  export type $CustodyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Custody"
    objects: {
      evidence: Prisma.$EvidencePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      acao: string
      ator: string
      local: string | null
      ts: Date
      assinatura: string | null
      evidenceId: string
    }, ExtArgs["result"]["custody"]>
    composites: {}
  }

  type CustodyGetPayload<S extends boolean | null | undefined | CustodyDefaultArgs> = $Result.GetResult<Prisma.$CustodyPayload, S>

  type CustodyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustodyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustodyCountAggregateInputType | true
    }

  export interface CustodyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Custody'], meta: { name: 'Custody' } }
    /**
     * Find zero or one Custody that matches the filter.
     * @param {CustodyFindUniqueArgs} args - Arguments to find a Custody
     * @example
     * // Get one Custody
     * const custody = await prisma.custody.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustodyFindUniqueArgs>(args: SelectSubset<T, CustodyFindUniqueArgs<ExtArgs>>): Prisma__CustodyClient<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Custody that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustodyFindUniqueOrThrowArgs} args - Arguments to find a Custody
     * @example
     * // Get one Custody
     * const custody = await prisma.custody.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustodyFindUniqueOrThrowArgs>(args: SelectSubset<T, CustodyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustodyClient<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Custody that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyFindFirstArgs} args - Arguments to find a Custody
     * @example
     * // Get one Custody
     * const custody = await prisma.custody.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustodyFindFirstArgs>(args?: SelectSubset<T, CustodyFindFirstArgs<ExtArgs>>): Prisma__CustodyClient<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Custody that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyFindFirstOrThrowArgs} args - Arguments to find a Custody
     * @example
     * // Get one Custody
     * const custody = await prisma.custody.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustodyFindFirstOrThrowArgs>(args?: SelectSubset<T, CustodyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustodyClient<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Custodies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Custodies
     * const custodies = await prisma.custody.findMany()
     * 
     * // Get first 10 Custodies
     * const custodies = await prisma.custody.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const custodyWithIdOnly = await prisma.custody.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustodyFindManyArgs>(args?: SelectSubset<T, CustodyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Custody.
     * @param {CustodyCreateArgs} args - Arguments to create a Custody.
     * @example
     * // Create one Custody
     * const Custody = await prisma.custody.create({
     *   data: {
     *     // ... data to create a Custody
     *   }
     * })
     * 
     */
    create<T extends CustodyCreateArgs>(args: SelectSubset<T, CustodyCreateArgs<ExtArgs>>): Prisma__CustodyClient<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Custodies.
     * @param {CustodyCreateManyArgs} args - Arguments to create many Custodies.
     * @example
     * // Create many Custodies
     * const custody = await prisma.custody.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustodyCreateManyArgs>(args?: SelectSubset<T, CustodyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Custodies and returns the data saved in the database.
     * @param {CustodyCreateManyAndReturnArgs} args - Arguments to create many Custodies.
     * @example
     * // Create many Custodies
     * const custody = await prisma.custody.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Custodies and only return the `id`
     * const custodyWithIdOnly = await prisma.custody.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustodyCreateManyAndReturnArgs>(args?: SelectSubset<T, CustodyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Custody.
     * @param {CustodyDeleteArgs} args - Arguments to delete one Custody.
     * @example
     * // Delete one Custody
     * const Custody = await prisma.custody.delete({
     *   where: {
     *     // ... filter to delete one Custody
     *   }
     * })
     * 
     */
    delete<T extends CustodyDeleteArgs>(args: SelectSubset<T, CustodyDeleteArgs<ExtArgs>>): Prisma__CustodyClient<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Custody.
     * @param {CustodyUpdateArgs} args - Arguments to update one Custody.
     * @example
     * // Update one Custody
     * const custody = await prisma.custody.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustodyUpdateArgs>(args: SelectSubset<T, CustodyUpdateArgs<ExtArgs>>): Prisma__CustodyClient<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Custodies.
     * @param {CustodyDeleteManyArgs} args - Arguments to filter Custodies to delete.
     * @example
     * // Delete a few Custodies
     * const { count } = await prisma.custody.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustodyDeleteManyArgs>(args?: SelectSubset<T, CustodyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Custodies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Custodies
     * const custody = await prisma.custody.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustodyUpdateManyArgs>(args: SelectSubset<T, CustodyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Custodies and returns the data updated in the database.
     * @param {CustodyUpdateManyAndReturnArgs} args - Arguments to update many Custodies.
     * @example
     * // Update many Custodies
     * const custody = await prisma.custody.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Custodies and only return the `id`
     * const custodyWithIdOnly = await prisma.custody.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustodyUpdateManyAndReturnArgs>(args: SelectSubset<T, CustodyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Custody.
     * @param {CustodyUpsertArgs} args - Arguments to update or create a Custody.
     * @example
     * // Update or create a Custody
     * const custody = await prisma.custody.upsert({
     *   create: {
     *     // ... data to create a Custody
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Custody we want to update
     *   }
     * })
     */
    upsert<T extends CustodyUpsertArgs>(args: SelectSubset<T, CustodyUpsertArgs<ExtArgs>>): Prisma__CustodyClient<$Result.GetResult<Prisma.$CustodyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Custodies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyCountArgs} args - Arguments to filter Custodies to count.
     * @example
     * // Count the number of Custodies
     * const count = await prisma.custody.count({
     *   where: {
     *     // ... the filter for the Custodies we want to count
     *   }
     * })
    **/
    count<T extends CustodyCountArgs>(
      args?: Subset<T, CustodyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustodyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Custody.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustodyAggregateArgs>(args: Subset<T, CustodyAggregateArgs>): Prisma.PrismaPromise<GetCustodyAggregateType<T>>

    /**
     * Group by Custody.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustodyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustodyGroupByArgs['orderBy'] }
        : { orderBy?: CustodyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustodyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustodyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Custody model
   */
  readonly fields: CustodyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Custody.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustodyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evidence<T extends EvidenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvidenceDefaultArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Custody model
   */
  interface CustodyFieldRefs {
    readonly id: FieldRef<"Custody", 'String'>
    readonly acao: FieldRef<"Custody", 'String'>
    readonly ator: FieldRef<"Custody", 'String'>
    readonly local: FieldRef<"Custody", 'String'>
    readonly ts: FieldRef<"Custody", 'DateTime'>
    readonly assinatura: FieldRef<"Custody", 'String'>
    readonly evidenceId: FieldRef<"Custody", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Custody findUnique
   */
  export type CustodyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyInclude<ExtArgs> | null
    /**
     * Filter, which Custody to fetch.
     */
    where: CustodyWhereUniqueInput
  }

  /**
   * Custody findUniqueOrThrow
   */
  export type CustodyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyInclude<ExtArgs> | null
    /**
     * Filter, which Custody to fetch.
     */
    where: CustodyWhereUniqueInput
  }

  /**
   * Custody findFirst
   */
  export type CustodyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyInclude<ExtArgs> | null
    /**
     * Filter, which Custody to fetch.
     */
    where?: CustodyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Custodies to fetch.
     */
    orderBy?: CustodyOrderByWithRelationInput | CustodyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Custodies.
     */
    cursor?: CustodyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Custodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Custodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Custodies.
     */
    distinct?: CustodyScalarFieldEnum | CustodyScalarFieldEnum[]
  }

  /**
   * Custody findFirstOrThrow
   */
  export type CustodyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyInclude<ExtArgs> | null
    /**
     * Filter, which Custody to fetch.
     */
    where?: CustodyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Custodies to fetch.
     */
    orderBy?: CustodyOrderByWithRelationInput | CustodyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Custodies.
     */
    cursor?: CustodyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Custodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Custodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Custodies.
     */
    distinct?: CustodyScalarFieldEnum | CustodyScalarFieldEnum[]
  }

  /**
   * Custody findMany
   */
  export type CustodyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyInclude<ExtArgs> | null
    /**
     * Filter, which Custodies to fetch.
     */
    where?: CustodyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Custodies to fetch.
     */
    orderBy?: CustodyOrderByWithRelationInput | CustodyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Custodies.
     */
    cursor?: CustodyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Custodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Custodies.
     */
    skip?: number
    distinct?: CustodyScalarFieldEnum | CustodyScalarFieldEnum[]
  }

  /**
   * Custody create
   */
  export type CustodyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyInclude<ExtArgs> | null
    /**
     * The data needed to create a Custody.
     */
    data: XOR<CustodyCreateInput, CustodyUncheckedCreateInput>
  }

  /**
   * Custody createMany
   */
  export type CustodyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Custodies.
     */
    data: CustodyCreateManyInput | CustodyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Custody createManyAndReturn
   */
  export type CustodyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * The data used to create many Custodies.
     */
    data: CustodyCreateManyInput | CustodyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Custody update
   */
  export type CustodyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyInclude<ExtArgs> | null
    /**
     * The data needed to update a Custody.
     */
    data: XOR<CustodyUpdateInput, CustodyUncheckedUpdateInput>
    /**
     * Choose, which Custody to update.
     */
    where: CustodyWhereUniqueInput
  }

  /**
   * Custody updateMany
   */
  export type CustodyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Custodies.
     */
    data: XOR<CustodyUpdateManyMutationInput, CustodyUncheckedUpdateManyInput>
    /**
     * Filter which Custodies to update
     */
    where?: CustodyWhereInput
    /**
     * Limit how many Custodies to update.
     */
    limit?: number
  }

  /**
   * Custody updateManyAndReturn
   */
  export type CustodyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * The data used to update Custodies.
     */
    data: XOR<CustodyUpdateManyMutationInput, CustodyUncheckedUpdateManyInput>
    /**
     * Filter which Custodies to update
     */
    where?: CustodyWhereInput
    /**
     * Limit how many Custodies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Custody upsert
   */
  export type CustodyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyInclude<ExtArgs> | null
    /**
     * The filter to search for the Custody to update in case it exists.
     */
    where: CustodyWhereUniqueInput
    /**
     * In case the Custody found by the `where` argument doesn't exist, create a new Custody with this data.
     */
    create: XOR<CustodyCreateInput, CustodyUncheckedCreateInput>
    /**
     * In case the Custody was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustodyUpdateInput, CustodyUncheckedUpdateInput>
  }

  /**
   * Custody delete
   */
  export type CustodyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyInclude<ExtArgs> | null
    /**
     * Filter which Custody to delete.
     */
    where: CustodyWhereUniqueInput
  }

  /**
   * Custody deleteMany
   */
  export type CustodyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Custodies to delete
     */
    where?: CustodyWhereInput
    /**
     * Limit how many Custodies to delete.
     */
    limit?: number
  }

  /**
   * Custody without action
   */
  export type CustodyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custody
     */
    select?: CustodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Custody
     */
    omit?: CustodyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustodyInclude<ExtArgs> | null
  }


  /**
   * Model AttackScenario
   */

  export type AggregateAttackScenario = {
    _count: AttackScenarioCountAggregateOutputType | null
    _min: AttackScenarioMinAggregateOutputType | null
    _max: AttackScenarioMaxAggregateOutputType | null
  }

  export type AttackScenarioMinAggregateOutputType = {
    id: string | null
    nome: string | null
    descricao: string | null
    protocolo: string | null
    tecnicaMITRE: string | null
  }

  export type AttackScenarioMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    descricao: string | null
    protocolo: string | null
    tecnicaMITRE: string | null
  }

  export type AttackScenarioCountAggregateOutputType = {
    id: number
    nome: number
    descricao: number
    protocolo: number
    tecnicaMITRE: number
    _all: number
  }


  export type AttackScenarioMinAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    protocolo?: true
    tecnicaMITRE?: true
  }

  export type AttackScenarioMaxAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    protocolo?: true
    tecnicaMITRE?: true
  }

  export type AttackScenarioCountAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    protocolo?: true
    tecnicaMITRE?: true
    _all?: true
  }

  export type AttackScenarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttackScenario to aggregate.
     */
    where?: AttackScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackScenarios to fetch.
     */
    orderBy?: AttackScenarioOrderByWithRelationInput | AttackScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttackScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackScenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttackScenarios
    **/
    _count?: true | AttackScenarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttackScenarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttackScenarioMaxAggregateInputType
  }

  export type GetAttackScenarioAggregateType<T extends AttackScenarioAggregateArgs> = {
        [P in keyof T & keyof AggregateAttackScenario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttackScenario[P]>
      : GetScalarType<T[P], AggregateAttackScenario[P]>
  }




  export type AttackScenarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttackScenarioWhereInput
    orderBy?: AttackScenarioOrderByWithAggregationInput | AttackScenarioOrderByWithAggregationInput[]
    by: AttackScenarioScalarFieldEnum[] | AttackScenarioScalarFieldEnum
    having?: AttackScenarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttackScenarioCountAggregateInputType | true
    _min?: AttackScenarioMinAggregateInputType
    _max?: AttackScenarioMaxAggregateInputType
  }

  export type AttackScenarioGroupByOutputType = {
    id: string
    nome: string
    descricao: string | null
    protocolo: string | null
    tecnicaMITRE: string | null
    _count: AttackScenarioCountAggregateOutputType | null
    _min: AttackScenarioMinAggregateOutputType | null
    _max: AttackScenarioMaxAggregateOutputType | null
  }

  type GetAttackScenarioGroupByPayload<T extends AttackScenarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttackScenarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttackScenarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttackScenarioGroupByOutputType[P]>
            : GetScalarType<T[P], AttackScenarioGroupByOutputType[P]>
        }
      >
    >


  export type AttackScenarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    protocolo?: boolean
    tecnicaMITRE?: boolean
    runs?: boolean | AttackScenario$runsArgs<ExtArgs>
    _count?: boolean | AttackScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attackScenario"]>

  export type AttackScenarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    protocolo?: boolean
    tecnicaMITRE?: boolean
  }, ExtArgs["result"]["attackScenario"]>

  export type AttackScenarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    protocolo?: boolean
    tecnicaMITRE?: boolean
  }, ExtArgs["result"]["attackScenario"]>

  export type AttackScenarioSelectScalar = {
    id?: boolean
    nome?: boolean
    descricao?: boolean
    protocolo?: boolean
    tecnicaMITRE?: boolean
  }

  export type AttackScenarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "descricao" | "protocolo" | "tecnicaMITRE", ExtArgs["result"]["attackScenario"]>
  export type AttackScenarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runs?: boolean | AttackScenario$runsArgs<ExtArgs>
    _count?: boolean | AttackScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AttackScenarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AttackScenarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AttackScenarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttackScenario"
    objects: {
      runs: Prisma.$AttackRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      descricao: string | null
      protocolo: string | null
      tecnicaMITRE: string | null
    }, ExtArgs["result"]["attackScenario"]>
    composites: {}
  }

  type AttackScenarioGetPayload<S extends boolean | null | undefined | AttackScenarioDefaultArgs> = $Result.GetResult<Prisma.$AttackScenarioPayload, S>

  type AttackScenarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttackScenarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttackScenarioCountAggregateInputType | true
    }

  export interface AttackScenarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttackScenario'], meta: { name: 'AttackScenario' } }
    /**
     * Find zero or one AttackScenario that matches the filter.
     * @param {AttackScenarioFindUniqueArgs} args - Arguments to find a AttackScenario
     * @example
     * // Get one AttackScenario
     * const attackScenario = await prisma.attackScenario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttackScenarioFindUniqueArgs>(args: SelectSubset<T, AttackScenarioFindUniqueArgs<ExtArgs>>): Prisma__AttackScenarioClient<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttackScenario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttackScenarioFindUniqueOrThrowArgs} args - Arguments to find a AttackScenario
     * @example
     * // Get one AttackScenario
     * const attackScenario = await prisma.attackScenario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttackScenarioFindUniqueOrThrowArgs>(args: SelectSubset<T, AttackScenarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttackScenarioClient<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttackScenario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackScenarioFindFirstArgs} args - Arguments to find a AttackScenario
     * @example
     * // Get one AttackScenario
     * const attackScenario = await prisma.attackScenario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttackScenarioFindFirstArgs>(args?: SelectSubset<T, AttackScenarioFindFirstArgs<ExtArgs>>): Prisma__AttackScenarioClient<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttackScenario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackScenarioFindFirstOrThrowArgs} args - Arguments to find a AttackScenario
     * @example
     * // Get one AttackScenario
     * const attackScenario = await prisma.attackScenario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttackScenarioFindFirstOrThrowArgs>(args?: SelectSubset<T, AttackScenarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttackScenarioClient<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttackScenarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackScenarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttackScenarios
     * const attackScenarios = await prisma.attackScenario.findMany()
     * 
     * // Get first 10 AttackScenarios
     * const attackScenarios = await prisma.attackScenario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attackScenarioWithIdOnly = await prisma.attackScenario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttackScenarioFindManyArgs>(args?: SelectSubset<T, AttackScenarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttackScenario.
     * @param {AttackScenarioCreateArgs} args - Arguments to create a AttackScenario.
     * @example
     * // Create one AttackScenario
     * const AttackScenario = await prisma.attackScenario.create({
     *   data: {
     *     // ... data to create a AttackScenario
     *   }
     * })
     * 
     */
    create<T extends AttackScenarioCreateArgs>(args: SelectSubset<T, AttackScenarioCreateArgs<ExtArgs>>): Prisma__AttackScenarioClient<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttackScenarios.
     * @param {AttackScenarioCreateManyArgs} args - Arguments to create many AttackScenarios.
     * @example
     * // Create many AttackScenarios
     * const attackScenario = await prisma.attackScenario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttackScenarioCreateManyArgs>(args?: SelectSubset<T, AttackScenarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttackScenarios and returns the data saved in the database.
     * @param {AttackScenarioCreateManyAndReturnArgs} args - Arguments to create many AttackScenarios.
     * @example
     * // Create many AttackScenarios
     * const attackScenario = await prisma.attackScenario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttackScenarios and only return the `id`
     * const attackScenarioWithIdOnly = await prisma.attackScenario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttackScenarioCreateManyAndReturnArgs>(args?: SelectSubset<T, AttackScenarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttackScenario.
     * @param {AttackScenarioDeleteArgs} args - Arguments to delete one AttackScenario.
     * @example
     * // Delete one AttackScenario
     * const AttackScenario = await prisma.attackScenario.delete({
     *   where: {
     *     // ... filter to delete one AttackScenario
     *   }
     * })
     * 
     */
    delete<T extends AttackScenarioDeleteArgs>(args: SelectSubset<T, AttackScenarioDeleteArgs<ExtArgs>>): Prisma__AttackScenarioClient<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttackScenario.
     * @param {AttackScenarioUpdateArgs} args - Arguments to update one AttackScenario.
     * @example
     * // Update one AttackScenario
     * const attackScenario = await prisma.attackScenario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttackScenarioUpdateArgs>(args: SelectSubset<T, AttackScenarioUpdateArgs<ExtArgs>>): Prisma__AttackScenarioClient<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttackScenarios.
     * @param {AttackScenarioDeleteManyArgs} args - Arguments to filter AttackScenarios to delete.
     * @example
     * // Delete a few AttackScenarios
     * const { count } = await prisma.attackScenario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttackScenarioDeleteManyArgs>(args?: SelectSubset<T, AttackScenarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttackScenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackScenarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttackScenarios
     * const attackScenario = await prisma.attackScenario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttackScenarioUpdateManyArgs>(args: SelectSubset<T, AttackScenarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttackScenarios and returns the data updated in the database.
     * @param {AttackScenarioUpdateManyAndReturnArgs} args - Arguments to update many AttackScenarios.
     * @example
     * // Update many AttackScenarios
     * const attackScenario = await prisma.attackScenario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttackScenarios and only return the `id`
     * const attackScenarioWithIdOnly = await prisma.attackScenario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttackScenarioUpdateManyAndReturnArgs>(args: SelectSubset<T, AttackScenarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttackScenario.
     * @param {AttackScenarioUpsertArgs} args - Arguments to update or create a AttackScenario.
     * @example
     * // Update or create a AttackScenario
     * const attackScenario = await prisma.attackScenario.upsert({
     *   create: {
     *     // ... data to create a AttackScenario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttackScenario we want to update
     *   }
     * })
     */
    upsert<T extends AttackScenarioUpsertArgs>(args: SelectSubset<T, AttackScenarioUpsertArgs<ExtArgs>>): Prisma__AttackScenarioClient<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttackScenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackScenarioCountArgs} args - Arguments to filter AttackScenarios to count.
     * @example
     * // Count the number of AttackScenarios
     * const count = await prisma.attackScenario.count({
     *   where: {
     *     // ... the filter for the AttackScenarios we want to count
     *   }
     * })
    **/
    count<T extends AttackScenarioCountArgs>(
      args?: Subset<T, AttackScenarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttackScenarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttackScenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackScenarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttackScenarioAggregateArgs>(args: Subset<T, AttackScenarioAggregateArgs>): Prisma.PrismaPromise<GetAttackScenarioAggregateType<T>>

    /**
     * Group by AttackScenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackScenarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttackScenarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttackScenarioGroupByArgs['orderBy'] }
        : { orderBy?: AttackScenarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttackScenarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttackScenarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttackScenario model
   */
  readonly fields: AttackScenarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttackScenario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttackScenarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runs<T extends AttackScenario$runsArgs<ExtArgs> = {}>(args?: Subset<T, AttackScenario$runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttackScenario model
   */
  interface AttackScenarioFieldRefs {
    readonly id: FieldRef<"AttackScenario", 'String'>
    readonly nome: FieldRef<"AttackScenario", 'String'>
    readonly descricao: FieldRef<"AttackScenario", 'String'>
    readonly protocolo: FieldRef<"AttackScenario", 'String'>
    readonly tecnicaMITRE: FieldRef<"AttackScenario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AttackScenario findUnique
   */
  export type AttackScenarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackScenarioInclude<ExtArgs> | null
    /**
     * Filter, which AttackScenario to fetch.
     */
    where: AttackScenarioWhereUniqueInput
  }

  /**
   * AttackScenario findUniqueOrThrow
   */
  export type AttackScenarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackScenarioInclude<ExtArgs> | null
    /**
     * Filter, which AttackScenario to fetch.
     */
    where: AttackScenarioWhereUniqueInput
  }

  /**
   * AttackScenario findFirst
   */
  export type AttackScenarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackScenarioInclude<ExtArgs> | null
    /**
     * Filter, which AttackScenario to fetch.
     */
    where?: AttackScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackScenarios to fetch.
     */
    orderBy?: AttackScenarioOrderByWithRelationInput | AttackScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackScenarios.
     */
    cursor?: AttackScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackScenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackScenarios.
     */
    distinct?: AttackScenarioScalarFieldEnum | AttackScenarioScalarFieldEnum[]
  }

  /**
   * AttackScenario findFirstOrThrow
   */
  export type AttackScenarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackScenarioInclude<ExtArgs> | null
    /**
     * Filter, which AttackScenario to fetch.
     */
    where?: AttackScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackScenarios to fetch.
     */
    orderBy?: AttackScenarioOrderByWithRelationInput | AttackScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackScenarios.
     */
    cursor?: AttackScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackScenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackScenarios.
     */
    distinct?: AttackScenarioScalarFieldEnum | AttackScenarioScalarFieldEnum[]
  }

  /**
   * AttackScenario findMany
   */
  export type AttackScenarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackScenarioInclude<ExtArgs> | null
    /**
     * Filter, which AttackScenarios to fetch.
     */
    where?: AttackScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackScenarios to fetch.
     */
    orderBy?: AttackScenarioOrderByWithRelationInput | AttackScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttackScenarios.
     */
    cursor?: AttackScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackScenarios.
     */
    skip?: number
    distinct?: AttackScenarioScalarFieldEnum | AttackScenarioScalarFieldEnum[]
  }

  /**
   * AttackScenario create
   */
  export type AttackScenarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackScenarioInclude<ExtArgs> | null
    /**
     * The data needed to create a AttackScenario.
     */
    data: XOR<AttackScenarioCreateInput, AttackScenarioUncheckedCreateInput>
  }

  /**
   * AttackScenario createMany
   */
  export type AttackScenarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttackScenarios.
     */
    data: AttackScenarioCreateManyInput | AttackScenarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttackScenario createManyAndReturn
   */
  export type AttackScenarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * The data used to create many AttackScenarios.
     */
    data: AttackScenarioCreateManyInput | AttackScenarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttackScenario update
   */
  export type AttackScenarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackScenarioInclude<ExtArgs> | null
    /**
     * The data needed to update a AttackScenario.
     */
    data: XOR<AttackScenarioUpdateInput, AttackScenarioUncheckedUpdateInput>
    /**
     * Choose, which AttackScenario to update.
     */
    where: AttackScenarioWhereUniqueInput
  }

  /**
   * AttackScenario updateMany
   */
  export type AttackScenarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttackScenarios.
     */
    data: XOR<AttackScenarioUpdateManyMutationInput, AttackScenarioUncheckedUpdateManyInput>
    /**
     * Filter which AttackScenarios to update
     */
    where?: AttackScenarioWhereInput
    /**
     * Limit how many AttackScenarios to update.
     */
    limit?: number
  }

  /**
   * AttackScenario updateManyAndReturn
   */
  export type AttackScenarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * The data used to update AttackScenarios.
     */
    data: XOR<AttackScenarioUpdateManyMutationInput, AttackScenarioUncheckedUpdateManyInput>
    /**
     * Filter which AttackScenarios to update
     */
    where?: AttackScenarioWhereInput
    /**
     * Limit how many AttackScenarios to update.
     */
    limit?: number
  }

  /**
   * AttackScenario upsert
   */
  export type AttackScenarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackScenarioInclude<ExtArgs> | null
    /**
     * The filter to search for the AttackScenario to update in case it exists.
     */
    where: AttackScenarioWhereUniqueInput
    /**
     * In case the AttackScenario found by the `where` argument doesn't exist, create a new AttackScenario with this data.
     */
    create: XOR<AttackScenarioCreateInput, AttackScenarioUncheckedCreateInput>
    /**
     * In case the AttackScenario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttackScenarioUpdateInput, AttackScenarioUncheckedUpdateInput>
  }

  /**
   * AttackScenario delete
   */
  export type AttackScenarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackScenarioInclude<ExtArgs> | null
    /**
     * Filter which AttackScenario to delete.
     */
    where: AttackScenarioWhereUniqueInput
  }

  /**
   * AttackScenario deleteMany
   */
  export type AttackScenarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttackScenarios to delete
     */
    where?: AttackScenarioWhereInput
    /**
     * Limit how many AttackScenarios to delete.
     */
    limit?: number
  }

  /**
   * AttackScenario.runs
   */
  export type AttackScenario$runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    where?: AttackRunWhereInput
    orderBy?: AttackRunOrderByWithRelationInput | AttackRunOrderByWithRelationInput[]
    cursor?: AttackRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttackRunScalarFieldEnum | AttackRunScalarFieldEnum[]
  }

  /**
   * AttackScenario without action
   */
  export type AttackScenarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackScenario
     */
    select?: AttackScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackScenario
     */
    omit?: AttackScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackScenarioInclude<ExtArgs> | null
  }


  /**
   * Model AttackRun
   */

  export type AggregateAttackRun = {
    _count: AttackRunCountAggregateOutputType | null
    _min: AttackRunMinAggregateOutputType | null
    _max: AttackRunMaxAggregateOutputType | null
  }

  export type AttackRunMinAggregateOutputType = {
    id: string | null
    tsInicio: Date | null
    tsFim: Date | null
    status: string | null
    scenarioId: string | null
    userId: string | null
    assetId: string | null
  }

  export type AttackRunMaxAggregateOutputType = {
    id: string | null
    tsInicio: Date | null
    tsFim: Date | null
    status: string | null
    scenarioId: string | null
    userId: string | null
    assetId: string | null
  }

  export type AttackRunCountAggregateOutputType = {
    id: number
    tsInicio: number
    tsFim: number
    status: number
    scenarioId: number
    userId: number
    assetId: number
    _all: number
  }


  export type AttackRunMinAggregateInputType = {
    id?: true
    tsInicio?: true
    tsFim?: true
    status?: true
    scenarioId?: true
    userId?: true
    assetId?: true
  }

  export type AttackRunMaxAggregateInputType = {
    id?: true
    tsInicio?: true
    tsFim?: true
    status?: true
    scenarioId?: true
    userId?: true
    assetId?: true
  }

  export type AttackRunCountAggregateInputType = {
    id?: true
    tsInicio?: true
    tsFim?: true
    status?: true
    scenarioId?: true
    userId?: true
    assetId?: true
    _all?: true
  }

  export type AttackRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttackRun to aggregate.
     */
    where?: AttackRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackRuns to fetch.
     */
    orderBy?: AttackRunOrderByWithRelationInput | AttackRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttackRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttackRuns
    **/
    _count?: true | AttackRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttackRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttackRunMaxAggregateInputType
  }

  export type GetAttackRunAggregateType<T extends AttackRunAggregateArgs> = {
        [P in keyof T & keyof AggregateAttackRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttackRun[P]>
      : GetScalarType<T[P], AggregateAttackRun[P]>
  }




  export type AttackRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttackRunWhereInput
    orderBy?: AttackRunOrderByWithAggregationInput | AttackRunOrderByWithAggregationInput[]
    by: AttackRunScalarFieldEnum[] | AttackRunScalarFieldEnum
    having?: AttackRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttackRunCountAggregateInputType | true
    _min?: AttackRunMinAggregateInputType
    _max?: AttackRunMaxAggregateInputType
  }

  export type AttackRunGroupByOutputType = {
    id: string
    tsInicio: Date
    tsFim: Date | null
    status: string | null
    scenarioId: string
    userId: string
    assetId: string
    _count: AttackRunCountAggregateOutputType | null
    _min: AttackRunMinAggregateOutputType | null
    _max: AttackRunMaxAggregateOutputType | null
  }

  type GetAttackRunGroupByPayload<T extends AttackRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttackRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttackRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttackRunGroupByOutputType[P]>
            : GetScalarType<T[P], AttackRunGroupByOutputType[P]>
        }
      >
    >


  export type AttackRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tsInicio?: boolean
    tsFim?: boolean
    status?: boolean
    scenarioId?: boolean
    userId?: boolean
    assetId?: boolean
    scenario?: boolean | AttackScenarioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    results?: boolean | AttackRun$resultsArgs<ExtArgs>
    _count?: boolean | AttackRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attackRun"]>

  export type AttackRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tsInicio?: boolean
    tsFim?: boolean
    status?: boolean
    scenarioId?: boolean
    userId?: boolean
    assetId?: boolean
    scenario?: boolean | AttackScenarioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attackRun"]>

  export type AttackRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tsInicio?: boolean
    tsFim?: boolean
    status?: boolean
    scenarioId?: boolean
    userId?: boolean
    assetId?: boolean
    scenario?: boolean | AttackScenarioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attackRun"]>

  export type AttackRunSelectScalar = {
    id?: boolean
    tsInicio?: boolean
    tsFim?: boolean
    status?: boolean
    scenarioId?: boolean
    userId?: boolean
    assetId?: boolean
  }

  export type AttackRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tsInicio" | "tsFim" | "status" | "scenarioId" | "userId" | "assetId", ExtArgs["result"]["attackRun"]>
  export type AttackRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | AttackScenarioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    results?: boolean | AttackRun$resultsArgs<ExtArgs>
    _count?: boolean | AttackRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AttackRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | AttackScenarioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }
  export type AttackRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | AttackScenarioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    asset?: boolean | AssetDefaultArgs<ExtArgs>
  }

  export type $AttackRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttackRun"
    objects: {
      scenario: Prisma.$AttackScenarioPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      asset: Prisma.$AssetPayload<ExtArgs>
      results: Prisma.$AttackResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tsInicio: Date
      tsFim: Date | null
      status: string | null
      scenarioId: string
      userId: string
      assetId: string
    }, ExtArgs["result"]["attackRun"]>
    composites: {}
  }

  type AttackRunGetPayload<S extends boolean | null | undefined | AttackRunDefaultArgs> = $Result.GetResult<Prisma.$AttackRunPayload, S>

  type AttackRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttackRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttackRunCountAggregateInputType | true
    }

  export interface AttackRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttackRun'], meta: { name: 'AttackRun' } }
    /**
     * Find zero or one AttackRun that matches the filter.
     * @param {AttackRunFindUniqueArgs} args - Arguments to find a AttackRun
     * @example
     * // Get one AttackRun
     * const attackRun = await prisma.attackRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttackRunFindUniqueArgs>(args: SelectSubset<T, AttackRunFindUniqueArgs<ExtArgs>>): Prisma__AttackRunClient<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttackRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttackRunFindUniqueOrThrowArgs} args - Arguments to find a AttackRun
     * @example
     * // Get one AttackRun
     * const attackRun = await prisma.attackRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttackRunFindUniqueOrThrowArgs>(args: SelectSubset<T, AttackRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttackRunClient<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttackRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackRunFindFirstArgs} args - Arguments to find a AttackRun
     * @example
     * // Get one AttackRun
     * const attackRun = await prisma.attackRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttackRunFindFirstArgs>(args?: SelectSubset<T, AttackRunFindFirstArgs<ExtArgs>>): Prisma__AttackRunClient<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttackRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackRunFindFirstOrThrowArgs} args - Arguments to find a AttackRun
     * @example
     * // Get one AttackRun
     * const attackRun = await prisma.attackRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttackRunFindFirstOrThrowArgs>(args?: SelectSubset<T, AttackRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttackRunClient<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttackRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttackRuns
     * const attackRuns = await prisma.attackRun.findMany()
     * 
     * // Get first 10 AttackRuns
     * const attackRuns = await prisma.attackRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attackRunWithIdOnly = await prisma.attackRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttackRunFindManyArgs>(args?: SelectSubset<T, AttackRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttackRun.
     * @param {AttackRunCreateArgs} args - Arguments to create a AttackRun.
     * @example
     * // Create one AttackRun
     * const AttackRun = await prisma.attackRun.create({
     *   data: {
     *     // ... data to create a AttackRun
     *   }
     * })
     * 
     */
    create<T extends AttackRunCreateArgs>(args: SelectSubset<T, AttackRunCreateArgs<ExtArgs>>): Prisma__AttackRunClient<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttackRuns.
     * @param {AttackRunCreateManyArgs} args - Arguments to create many AttackRuns.
     * @example
     * // Create many AttackRuns
     * const attackRun = await prisma.attackRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttackRunCreateManyArgs>(args?: SelectSubset<T, AttackRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttackRuns and returns the data saved in the database.
     * @param {AttackRunCreateManyAndReturnArgs} args - Arguments to create many AttackRuns.
     * @example
     * // Create many AttackRuns
     * const attackRun = await prisma.attackRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttackRuns and only return the `id`
     * const attackRunWithIdOnly = await prisma.attackRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttackRunCreateManyAndReturnArgs>(args?: SelectSubset<T, AttackRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttackRun.
     * @param {AttackRunDeleteArgs} args - Arguments to delete one AttackRun.
     * @example
     * // Delete one AttackRun
     * const AttackRun = await prisma.attackRun.delete({
     *   where: {
     *     // ... filter to delete one AttackRun
     *   }
     * })
     * 
     */
    delete<T extends AttackRunDeleteArgs>(args: SelectSubset<T, AttackRunDeleteArgs<ExtArgs>>): Prisma__AttackRunClient<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttackRun.
     * @param {AttackRunUpdateArgs} args - Arguments to update one AttackRun.
     * @example
     * // Update one AttackRun
     * const attackRun = await prisma.attackRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttackRunUpdateArgs>(args: SelectSubset<T, AttackRunUpdateArgs<ExtArgs>>): Prisma__AttackRunClient<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttackRuns.
     * @param {AttackRunDeleteManyArgs} args - Arguments to filter AttackRuns to delete.
     * @example
     * // Delete a few AttackRuns
     * const { count } = await prisma.attackRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttackRunDeleteManyArgs>(args?: SelectSubset<T, AttackRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttackRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttackRuns
     * const attackRun = await prisma.attackRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttackRunUpdateManyArgs>(args: SelectSubset<T, AttackRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttackRuns and returns the data updated in the database.
     * @param {AttackRunUpdateManyAndReturnArgs} args - Arguments to update many AttackRuns.
     * @example
     * // Update many AttackRuns
     * const attackRun = await prisma.attackRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttackRuns and only return the `id`
     * const attackRunWithIdOnly = await prisma.attackRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttackRunUpdateManyAndReturnArgs>(args: SelectSubset<T, AttackRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttackRun.
     * @param {AttackRunUpsertArgs} args - Arguments to update or create a AttackRun.
     * @example
     * // Update or create a AttackRun
     * const attackRun = await prisma.attackRun.upsert({
     *   create: {
     *     // ... data to create a AttackRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttackRun we want to update
     *   }
     * })
     */
    upsert<T extends AttackRunUpsertArgs>(args: SelectSubset<T, AttackRunUpsertArgs<ExtArgs>>): Prisma__AttackRunClient<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttackRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackRunCountArgs} args - Arguments to filter AttackRuns to count.
     * @example
     * // Count the number of AttackRuns
     * const count = await prisma.attackRun.count({
     *   where: {
     *     // ... the filter for the AttackRuns we want to count
     *   }
     * })
    **/
    count<T extends AttackRunCountArgs>(
      args?: Subset<T, AttackRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttackRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttackRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttackRunAggregateArgs>(args: Subset<T, AttackRunAggregateArgs>): Prisma.PrismaPromise<GetAttackRunAggregateType<T>>

    /**
     * Group by AttackRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttackRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttackRunGroupByArgs['orderBy'] }
        : { orderBy?: AttackRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttackRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttackRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttackRun model
   */
  readonly fields: AttackRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttackRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttackRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scenario<T extends AttackScenarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttackScenarioDefaultArgs<ExtArgs>>): Prisma__AttackScenarioClient<$Result.GetResult<Prisma.$AttackScenarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    results<T extends AttackRun$resultsArgs<ExtArgs> = {}>(args?: Subset<T, AttackRun$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttackRun model
   */
  interface AttackRunFieldRefs {
    readonly id: FieldRef<"AttackRun", 'String'>
    readonly tsInicio: FieldRef<"AttackRun", 'DateTime'>
    readonly tsFim: FieldRef<"AttackRun", 'DateTime'>
    readonly status: FieldRef<"AttackRun", 'String'>
    readonly scenarioId: FieldRef<"AttackRun", 'String'>
    readonly userId: FieldRef<"AttackRun", 'String'>
    readonly assetId: FieldRef<"AttackRun", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AttackRun findUnique
   */
  export type AttackRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    /**
     * Filter, which AttackRun to fetch.
     */
    where: AttackRunWhereUniqueInput
  }

  /**
   * AttackRun findUniqueOrThrow
   */
  export type AttackRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    /**
     * Filter, which AttackRun to fetch.
     */
    where: AttackRunWhereUniqueInput
  }

  /**
   * AttackRun findFirst
   */
  export type AttackRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    /**
     * Filter, which AttackRun to fetch.
     */
    where?: AttackRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackRuns to fetch.
     */
    orderBy?: AttackRunOrderByWithRelationInput | AttackRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackRuns.
     */
    cursor?: AttackRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackRuns.
     */
    distinct?: AttackRunScalarFieldEnum | AttackRunScalarFieldEnum[]
  }

  /**
   * AttackRun findFirstOrThrow
   */
  export type AttackRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    /**
     * Filter, which AttackRun to fetch.
     */
    where?: AttackRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackRuns to fetch.
     */
    orderBy?: AttackRunOrderByWithRelationInput | AttackRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackRuns.
     */
    cursor?: AttackRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackRuns.
     */
    distinct?: AttackRunScalarFieldEnum | AttackRunScalarFieldEnum[]
  }

  /**
   * AttackRun findMany
   */
  export type AttackRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    /**
     * Filter, which AttackRuns to fetch.
     */
    where?: AttackRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackRuns to fetch.
     */
    orderBy?: AttackRunOrderByWithRelationInput | AttackRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttackRuns.
     */
    cursor?: AttackRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackRuns.
     */
    skip?: number
    distinct?: AttackRunScalarFieldEnum | AttackRunScalarFieldEnum[]
  }

  /**
   * AttackRun create
   */
  export type AttackRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    /**
     * The data needed to create a AttackRun.
     */
    data: XOR<AttackRunCreateInput, AttackRunUncheckedCreateInput>
  }

  /**
   * AttackRun createMany
   */
  export type AttackRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttackRuns.
     */
    data: AttackRunCreateManyInput | AttackRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttackRun createManyAndReturn
   */
  export type AttackRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * The data used to create many AttackRuns.
     */
    data: AttackRunCreateManyInput | AttackRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttackRun update
   */
  export type AttackRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    /**
     * The data needed to update a AttackRun.
     */
    data: XOR<AttackRunUpdateInput, AttackRunUncheckedUpdateInput>
    /**
     * Choose, which AttackRun to update.
     */
    where: AttackRunWhereUniqueInput
  }

  /**
   * AttackRun updateMany
   */
  export type AttackRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttackRuns.
     */
    data: XOR<AttackRunUpdateManyMutationInput, AttackRunUncheckedUpdateManyInput>
    /**
     * Filter which AttackRuns to update
     */
    where?: AttackRunWhereInput
    /**
     * Limit how many AttackRuns to update.
     */
    limit?: number
  }

  /**
   * AttackRun updateManyAndReturn
   */
  export type AttackRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * The data used to update AttackRuns.
     */
    data: XOR<AttackRunUpdateManyMutationInput, AttackRunUncheckedUpdateManyInput>
    /**
     * Filter which AttackRuns to update
     */
    where?: AttackRunWhereInput
    /**
     * Limit how many AttackRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttackRun upsert
   */
  export type AttackRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    /**
     * The filter to search for the AttackRun to update in case it exists.
     */
    where: AttackRunWhereUniqueInput
    /**
     * In case the AttackRun found by the `where` argument doesn't exist, create a new AttackRun with this data.
     */
    create: XOR<AttackRunCreateInput, AttackRunUncheckedCreateInput>
    /**
     * In case the AttackRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttackRunUpdateInput, AttackRunUncheckedUpdateInput>
  }

  /**
   * AttackRun delete
   */
  export type AttackRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
    /**
     * Filter which AttackRun to delete.
     */
    where: AttackRunWhereUniqueInput
  }

  /**
   * AttackRun deleteMany
   */
  export type AttackRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttackRuns to delete
     */
    where?: AttackRunWhereInput
    /**
     * Limit how many AttackRuns to delete.
     */
    limit?: number
  }

  /**
   * AttackRun.results
   */
  export type AttackRun$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultInclude<ExtArgs> | null
    where?: AttackResultWhereInput
    orderBy?: AttackResultOrderByWithRelationInput | AttackResultOrderByWithRelationInput[]
    cursor?: AttackResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttackResultScalarFieldEnum | AttackResultScalarFieldEnum[]
  }

  /**
   * AttackRun without action
   */
  export type AttackRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackRun
     */
    select?: AttackRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackRun
     */
    omit?: AttackRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackRunInclude<ExtArgs> | null
  }


  /**
   * Model AttackResult
   */

  export type AggregateAttackResult = {
    _count: AttackResultCountAggregateOutputType | null
    _min: AttackResultMinAggregateOutputType | null
    _max: AttackResultMaxAggregateOutputType | null
  }

  export type AttackResultMinAggregateOutputType = {
    id: string | null
    sucesso: boolean | null
    impacto: string | null
    logs: string | null
    iocsGerados: string | null
    runId: string | null
  }

  export type AttackResultMaxAggregateOutputType = {
    id: string | null
    sucesso: boolean | null
    impacto: string | null
    logs: string | null
    iocsGerados: string | null
    runId: string | null
  }

  export type AttackResultCountAggregateOutputType = {
    id: number
    sucesso: number
    impacto: number
    logs: number
    iocsGerados: number
    runId: number
    _all: number
  }


  export type AttackResultMinAggregateInputType = {
    id?: true
    sucesso?: true
    impacto?: true
    logs?: true
    iocsGerados?: true
    runId?: true
  }

  export type AttackResultMaxAggregateInputType = {
    id?: true
    sucesso?: true
    impacto?: true
    logs?: true
    iocsGerados?: true
    runId?: true
  }

  export type AttackResultCountAggregateInputType = {
    id?: true
    sucesso?: true
    impacto?: true
    logs?: true
    iocsGerados?: true
    runId?: true
    _all?: true
  }

  export type AttackResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttackResult to aggregate.
     */
    where?: AttackResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackResults to fetch.
     */
    orderBy?: AttackResultOrderByWithRelationInput | AttackResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttackResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttackResults
    **/
    _count?: true | AttackResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttackResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttackResultMaxAggregateInputType
  }

  export type GetAttackResultAggregateType<T extends AttackResultAggregateArgs> = {
        [P in keyof T & keyof AggregateAttackResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttackResult[P]>
      : GetScalarType<T[P], AggregateAttackResult[P]>
  }




  export type AttackResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttackResultWhereInput
    orderBy?: AttackResultOrderByWithAggregationInput | AttackResultOrderByWithAggregationInput[]
    by: AttackResultScalarFieldEnum[] | AttackResultScalarFieldEnum
    having?: AttackResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttackResultCountAggregateInputType | true
    _min?: AttackResultMinAggregateInputType
    _max?: AttackResultMaxAggregateInputType
  }

  export type AttackResultGroupByOutputType = {
    id: string
    sucesso: boolean
    impacto: string | null
    logs: string | null
    iocsGerados: string | null
    runId: string
    _count: AttackResultCountAggregateOutputType | null
    _min: AttackResultMinAggregateOutputType | null
    _max: AttackResultMaxAggregateOutputType | null
  }

  type GetAttackResultGroupByPayload<T extends AttackResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttackResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttackResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttackResultGroupByOutputType[P]>
            : GetScalarType<T[P], AttackResultGroupByOutputType[P]>
        }
      >
    >


  export type AttackResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sucesso?: boolean
    impacto?: boolean
    logs?: boolean
    iocsGerados?: boolean
    runId?: boolean
    run?: boolean | AttackRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attackResult"]>

  export type AttackResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sucesso?: boolean
    impacto?: boolean
    logs?: boolean
    iocsGerados?: boolean
    runId?: boolean
    run?: boolean | AttackRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attackResult"]>

  export type AttackResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sucesso?: boolean
    impacto?: boolean
    logs?: boolean
    iocsGerados?: boolean
    runId?: boolean
    run?: boolean | AttackRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attackResult"]>

  export type AttackResultSelectScalar = {
    id?: boolean
    sucesso?: boolean
    impacto?: boolean
    logs?: boolean
    iocsGerados?: boolean
    runId?: boolean
  }

  export type AttackResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sucesso" | "impacto" | "logs" | "iocsGerados" | "runId", ExtArgs["result"]["attackResult"]>
  export type AttackResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | AttackRunDefaultArgs<ExtArgs>
  }
  export type AttackResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | AttackRunDefaultArgs<ExtArgs>
  }
  export type AttackResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | AttackRunDefaultArgs<ExtArgs>
  }

  export type $AttackResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttackResult"
    objects: {
      run: Prisma.$AttackRunPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sucesso: boolean
      impacto: string | null
      logs: string | null
      iocsGerados: string | null
      runId: string
    }, ExtArgs["result"]["attackResult"]>
    composites: {}
  }

  type AttackResultGetPayload<S extends boolean | null | undefined | AttackResultDefaultArgs> = $Result.GetResult<Prisma.$AttackResultPayload, S>

  type AttackResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttackResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttackResultCountAggregateInputType | true
    }

  export interface AttackResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttackResult'], meta: { name: 'AttackResult' } }
    /**
     * Find zero or one AttackResult that matches the filter.
     * @param {AttackResultFindUniqueArgs} args - Arguments to find a AttackResult
     * @example
     * // Get one AttackResult
     * const attackResult = await prisma.attackResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttackResultFindUniqueArgs>(args: SelectSubset<T, AttackResultFindUniqueArgs<ExtArgs>>): Prisma__AttackResultClient<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttackResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttackResultFindUniqueOrThrowArgs} args - Arguments to find a AttackResult
     * @example
     * // Get one AttackResult
     * const attackResult = await prisma.attackResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttackResultFindUniqueOrThrowArgs>(args: SelectSubset<T, AttackResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttackResultClient<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttackResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackResultFindFirstArgs} args - Arguments to find a AttackResult
     * @example
     * // Get one AttackResult
     * const attackResult = await prisma.attackResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttackResultFindFirstArgs>(args?: SelectSubset<T, AttackResultFindFirstArgs<ExtArgs>>): Prisma__AttackResultClient<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttackResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackResultFindFirstOrThrowArgs} args - Arguments to find a AttackResult
     * @example
     * // Get one AttackResult
     * const attackResult = await prisma.attackResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttackResultFindFirstOrThrowArgs>(args?: SelectSubset<T, AttackResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttackResultClient<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttackResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttackResults
     * const attackResults = await prisma.attackResult.findMany()
     * 
     * // Get first 10 AttackResults
     * const attackResults = await prisma.attackResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attackResultWithIdOnly = await prisma.attackResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttackResultFindManyArgs>(args?: SelectSubset<T, AttackResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttackResult.
     * @param {AttackResultCreateArgs} args - Arguments to create a AttackResult.
     * @example
     * // Create one AttackResult
     * const AttackResult = await prisma.attackResult.create({
     *   data: {
     *     // ... data to create a AttackResult
     *   }
     * })
     * 
     */
    create<T extends AttackResultCreateArgs>(args: SelectSubset<T, AttackResultCreateArgs<ExtArgs>>): Prisma__AttackResultClient<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttackResults.
     * @param {AttackResultCreateManyArgs} args - Arguments to create many AttackResults.
     * @example
     * // Create many AttackResults
     * const attackResult = await prisma.attackResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttackResultCreateManyArgs>(args?: SelectSubset<T, AttackResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttackResults and returns the data saved in the database.
     * @param {AttackResultCreateManyAndReturnArgs} args - Arguments to create many AttackResults.
     * @example
     * // Create many AttackResults
     * const attackResult = await prisma.attackResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttackResults and only return the `id`
     * const attackResultWithIdOnly = await prisma.attackResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttackResultCreateManyAndReturnArgs>(args?: SelectSubset<T, AttackResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttackResult.
     * @param {AttackResultDeleteArgs} args - Arguments to delete one AttackResult.
     * @example
     * // Delete one AttackResult
     * const AttackResult = await prisma.attackResult.delete({
     *   where: {
     *     // ... filter to delete one AttackResult
     *   }
     * })
     * 
     */
    delete<T extends AttackResultDeleteArgs>(args: SelectSubset<T, AttackResultDeleteArgs<ExtArgs>>): Prisma__AttackResultClient<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttackResult.
     * @param {AttackResultUpdateArgs} args - Arguments to update one AttackResult.
     * @example
     * // Update one AttackResult
     * const attackResult = await prisma.attackResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttackResultUpdateArgs>(args: SelectSubset<T, AttackResultUpdateArgs<ExtArgs>>): Prisma__AttackResultClient<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttackResults.
     * @param {AttackResultDeleteManyArgs} args - Arguments to filter AttackResults to delete.
     * @example
     * // Delete a few AttackResults
     * const { count } = await prisma.attackResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttackResultDeleteManyArgs>(args?: SelectSubset<T, AttackResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttackResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttackResults
     * const attackResult = await prisma.attackResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttackResultUpdateManyArgs>(args: SelectSubset<T, AttackResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttackResults and returns the data updated in the database.
     * @param {AttackResultUpdateManyAndReturnArgs} args - Arguments to update many AttackResults.
     * @example
     * // Update many AttackResults
     * const attackResult = await prisma.attackResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttackResults and only return the `id`
     * const attackResultWithIdOnly = await prisma.attackResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttackResultUpdateManyAndReturnArgs>(args: SelectSubset<T, AttackResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttackResult.
     * @param {AttackResultUpsertArgs} args - Arguments to update or create a AttackResult.
     * @example
     * // Update or create a AttackResult
     * const attackResult = await prisma.attackResult.upsert({
     *   create: {
     *     // ... data to create a AttackResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttackResult we want to update
     *   }
     * })
     */
    upsert<T extends AttackResultUpsertArgs>(args: SelectSubset<T, AttackResultUpsertArgs<ExtArgs>>): Prisma__AttackResultClient<$Result.GetResult<Prisma.$AttackResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttackResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackResultCountArgs} args - Arguments to filter AttackResults to count.
     * @example
     * // Count the number of AttackResults
     * const count = await prisma.attackResult.count({
     *   where: {
     *     // ... the filter for the AttackResults we want to count
     *   }
     * })
    **/
    count<T extends AttackResultCountArgs>(
      args?: Subset<T, AttackResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttackResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttackResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttackResultAggregateArgs>(args: Subset<T, AttackResultAggregateArgs>): Prisma.PrismaPromise<GetAttackResultAggregateType<T>>

    /**
     * Group by AttackResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttackResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttackResultGroupByArgs['orderBy'] }
        : { orderBy?: AttackResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttackResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttackResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttackResult model
   */
  readonly fields: AttackResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttackResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttackResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    run<T extends AttackRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttackRunDefaultArgs<ExtArgs>>): Prisma__AttackRunClient<$Result.GetResult<Prisma.$AttackRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttackResult model
   */
  interface AttackResultFieldRefs {
    readonly id: FieldRef<"AttackResult", 'String'>
    readonly sucesso: FieldRef<"AttackResult", 'Boolean'>
    readonly impacto: FieldRef<"AttackResult", 'String'>
    readonly logs: FieldRef<"AttackResult", 'String'>
    readonly iocsGerados: FieldRef<"AttackResult", 'String'>
    readonly runId: FieldRef<"AttackResult", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AttackResult findUnique
   */
  export type AttackResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultInclude<ExtArgs> | null
    /**
     * Filter, which AttackResult to fetch.
     */
    where: AttackResultWhereUniqueInput
  }

  /**
   * AttackResult findUniqueOrThrow
   */
  export type AttackResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultInclude<ExtArgs> | null
    /**
     * Filter, which AttackResult to fetch.
     */
    where: AttackResultWhereUniqueInput
  }

  /**
   * AttackResult findFirst
   */
  export type AttackResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultInclude<ExtArgs> | null
    /**
     * Filter, which AttackResult to fetch.
     */
    where?: AttackResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackResults to fetch.
     */
    orderBy?: AttackResultOrderByWithRelationInput | AttackResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackResults.
     */
    cursor?: AttackResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackResults.
     */
    distinct?: AttackResultScalarFieldEnum | AttackResultScalarFieldEnum[]
  }

  /**
   * AttackResult findFirstOrThrow
   */
  export type AttackResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultInclude<ExtArgs> | null
    /**
     * Filter, which AttackResult to fetch.
     */
    where?: AttackResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackResults to fetch.
     */
    orderBy?: AttackResultOrderByWithRelationInput | AttackResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackResults.
     */
    cursor?: AttackResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackResults.
     */
    distinct?: AttackResultScalarFieldEnum | AttackResultScalarFieldEnum[]
  }

  /**
   * AttackResult findMany
   */
  export type AttackResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultInclude<ExtArgs> | null
    /**
     * Filter, which AttackResults to fetch.
     */
    where?: AttackResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackResults to fetch.
     */
    orderBy?: AttackResultOrderByWithRelationInput | AttackResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttackResults.
     */
    cursor?: AttackResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackResults.
     */
    skip?: number
    distinct?: AttackResultScalarFieldEnum | AttackResultScalarFieldEnum[]
  }

  /**
   * AttackResult create
   */
  export type AttackResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultInclude<ExtArgs> | null
    /**
     * The data needed to create a AttackResult.
     */
    data: XOR<AttackResultCreateInput, AttackResultUncheckedCreateInput>
  }

  /**
   * AttackResult createMany
   */
  export type AttackResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttackResults.
     */
    data: AttackResultCreateManyInput | AttackResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttackResult createManyAndReturn
   */
  export type AttackResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * The data used to create many AttackResults.
     */
    data: AttackResultCreateManyInput | AttackResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttackResult update
   */
  export type AttackResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultInclude<ExtArgs> | null
    /**
     * The data needed to update a AttackResult.
     */
    data: XOR<AttackResultUpdateInput, AttackResultUncheckedUpdateInput>
    /**
     * Choose, which AttackResult to update.
     */
    where: AttackResultWhereUniqueInput
  }

  /**
   * AttackResult updateMany
   */
  export type AttackResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttackResults.
     */
    data: XOR<AttackResultUpdateManyMutationInput, AttackResultUncheckedUpdateManyInput>
    /**
     * Filter which AttackResults to update
     */
    where?: AttackResultWhereInput
    /**
     * Limit how many AttackResults to update.
     */
    limit?: number
  }

  /**
   * AttackResult updateManyAndReturn
   */
  export type AttackResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * The data used to update AttackResults.
     */
    data: XOR<AttackResultUpdateManyMutationInput, AttackResultUncheckedUpdateManyInput>
    /**
     * Filter which AttackResults to update
     */
    where?: AttackResultWhereInput
    /**
     * Limit how many AttackResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttackResult upsert
   */
  export type AttackResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultInclude<ExtArgs> | null
    /**
     * The filter to search for the AttackResult to update in case it exists.
     */
    where: AttackResultWhereUniqueInput
    /**
     * In case the AttackResult found by the `where` argument doesn't exist, create a new AttackResult with this data.
     */
    create: XOR<AttackResultCreateInput, AttackResultUncheckedCreateInput>
    /**
     * In case the AttackResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttackResultUpdateInput, AttackResultUncheckedUpdateInput>
  }

  /**
   * AttackResult delete
   */
  export type AttackResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultInclude<ExtArgs> | null
    /**
     * Filter which AttackResult to delete.
     */
    where: AttackResultWhereUniqueInput
  }

  /**
   * AttackResult deleteMany
   */
  export type AttackResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttackResults to delete
     */
    where?: AttackResultWhereInput
    /**
     * Limit how many AttackResults to delete.
     */
    limit?: number
  }

  /**
   * AttackResult without action
   */
  export type AttackResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttackResult
     */
    select?: AttackResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttackResult
     */
    omit?: AttackResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttackResultInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    papel: 'papel',
    senhaHash: 'senhaHash'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    tipo: 'tipo',
    fabricante: 'fabricante',
    modelo: 'modelo',
    ip: 'ip',
    zona: 'zona',
    criticidade: 'criticidade'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const IndicatorScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    pattern: 'pattern',
    severidade: 'severidade',
    fonte: 'fonte',
    validadeInicio: 'validadeInicio',
    validadeFim: 'validadeFim'
  };

  export type IndicatorScalarFieldEnum = (typeof IndicatorScalarFieldEnum)[keyof typeof IndicatorScalarFieldEnum]


  export const ThreatEntityScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    nome: 'nome',
    descricao: 'descricao'
  };

  export type ThreatEntityScalarFieldEnum = (typeof ThreatEntityScalarFieldEnum)[keyof typeof ThreatEntityScalarFieldEnum]


  export const IndicatorThreatScalarFieldEnum: {
    id: 'id',
    indicatorId: 'indicatorId',
    threatId: 'threatId'
  };

  export type IndicatorThreatScalarFieldEnum = (typeof IndicatorThreatScalarFieldEnum)[keyof typeof IndicatorThreatScalarFieldEnum]


  export const OT_EventScalarFieldEnum: {
    id: 'id',
    ts: 'ts',
    protocolo: 'protocolo',
    srcIp: 'srcIp',
    dstIp: 'dstIp',
    funcao: 'funcao',
    valor: 'valor',
    anomalia: 'anomalia',
    assetId: 'assetId'
  };

  export type OT_EventScalarFieldEnum = (typeof OT_EventScalarFieldEnum)[keyof typeof OT_EventScalarFieldEnum]


  export const SightingScalarFieldEnum: {
    id: 'id',
    ts: 'ts',
    count: 'count',
    indicatorId: 'indicatorId',
    assetId: 'assetId'
  };

  export type SightingScalarFieldEnum = (typeof SightingScalarFieldEnum)[keyof typeof SightingScalarFieldEnum]


  export const CaseScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    status: 'status',
    responsavel: 'responsavel',
    criadoEm: 'criadoEm'
  };

  export type CaseScalarFieldEnum = (typeof CaseScalarFieldEnum)[keyof typeof CaseScalarFieldEnum]


  export const EvidenceScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    caminho: 'caminho',
    hashSha256: 'hashSha256',
    coletadoEm: 'coletadoEm',
    tamanho: 'tamanho',
    caseId: 'caseId'
  };

  export type EvidenceScalarFieldEnum = (typeof EvidenceScalarFieldEnum)[keyof typeof EvidenceScalarFieldEnum]


  export const CustodyScalarFieldEnum: {
    id: 'id',
    acao: 'acao',
    ator: 'ator',
    local: 'local',
    ts: 'ts',
    assinatura: 'assinatura',
    evidenceId: 'evidenceId'
  };

  export type CustodyScalarFieldEnum = (typeof CustodyScalarFieldEnum)[keyof typeof CustodyScalarFieldEnum]


  export const AttackScenarioScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    descricao: 'descricao',
    protocolo: 'protocolo',
    tecnicaMITRE: 'tecnicaMITRE'
  };

  export type AttackScenarioScalarFieldEnum = (typeof AttackScenarioScalarFieldEnum)[keyof typeof AttackScenarioScalarFieldEnum]


  export const AttackRunScalarFieldEnum: {
    id: 'id',
    tsInicio: 'tsInicio',
    tsFim: 'tsFim',
    status: 'status',
    scenarioId: 'scenarioId',
    userId: 'userId',
    assetId: 'assetId'
  };

  export type AttackRunScalarFieldEnum = (typeof AttackRunScalarFieldEnum)[keyof typeof AttackRunScalarFieldEnum]


  export const AttackResultScalarFieldEnum: {
    id: 'id',
    sucesso: 'sucesso',
    impacto: 'impacto',
    logs: 'logs',
    iocsGerados: 'iocsGerados',
    runId: 'runId'
  };

  export type AttackResultScalarFieldEnum = (typeof AttackResultScalarFieldEnum)[keyof typeof AttackResultScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    nome?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    papel?: StringFilter<"User"> | string
    senhaHash?: StringFilter<"User"> | string
    attackRuns?: AttackRunListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    papel?: SortOrder
    senhaHash?: SortOrder
    attackRuns?: AttackRunOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    nome?: StringFilter<"User"> | string
    papel?: StringFilter<"User"> | string
    senhaHash?: StringFilter<"User"> | string
    attackRuns?: AttackRunListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    papel?: SortOrder
    senhaHash?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    nome?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    papel?: StringWithAggregatesFilter<"User"> | string
    senhaHash?: StringWithAggregatesFilter<"User"> | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: StringFilter<"Asset"> | string
    nome?: StringFilter<"Asset"> | string
    tipo?: StringFilter<"Asset"> | string
    fabricante?: StringNullableFilter<"Asset"> | string | null
    modelo?: StringNullableFilter<"Asset"> | string | null
    ip?: StringNullableFilter<"Asset"> | string | null
    zona?: StringNullableFilter<"Asset"> | string | null
    criticidade?: IntNullableFilter<"Asset"> | number | null
    events?: OT_EventListRelationFilter
    sightings?: SightingListRelationFilter
    attackRuns?: AttackRunListRelationFilter
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    fabricante?: SortOrderInput | SortOrder
    modelo?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    zona?: SortOrderInput | SortOrder
    criticidade?: SortOrderInput | SortOrder
    events?: OT_EventOrderByRelationAggregateInput
    sightings?: SightingOrderByRelationAggregateInput
    attackRuns?: AttackRunOrderByRelationAggregateInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    nome?: StringFilter<"Asset"> | string
    tipo?: StringFilter<"Asset"> | string
    fabricante?: StringNullableFilter<"Asset"> | string | null
    modelo?: StringNullableFilter<"Asset"> | string | null
    ip?: StringNullableFilter<"Asset"> | string | null
    zona?: StringNullableFilter<"Asset"> | string | null
    criticidade?: IntNullableFilter<"Asset"> | number | null
    events?: OT_EventListRelationFilter
    sightings?: SightingListRelationFilter
    attackRuns?: AttackRunListRelationFilter
  }, "id">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    fabricante?: SortOrderInput | SortOrder
    modelo?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    zona?: SortOrderInput | SortOrder
    criticidade?: SortOrderInput | SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asset"> | string
    nome?: StringWithAggregatesFilter<"Asset"> | string
    tipo?: StringWithAggregatesFilter<"Asset"> | string
    fabricante?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    modelo?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    ip?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    zona?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    criticidade?: IntNullableWithAggregatesFilter<"Asset"> | number | null
  }

  export type IndicatorWhereInput = {
    AND?: IndicatorWhereInput | IndicatorWhereInput[]
    OR?: IndicatorWhereInput[]
    NOT?: IndicatorWhereInput | IndicatorWhereInput[]
    id?: StringFilter<"Indicator"> | string
    tipo?: StringFilter<"Indicator"> | string
    pattern?: StringFilter<"Indicator"> | string
    severidade?: IntNullableFilter<"Indicator"> | number | null
    fonte?: StringNullableFilter<"Indicator"> | string | null
    validadeInicio?: DateTimeNullableFilter<"Indicator"> | Date | string | null
    validadeFim?: DateTimeNullableFilter<"Indicator"> | Date | string | null
    sightings?: SightingListRelationFilter
    threats?: IndicatorThreatListRelationFilter
  }

  export type IndicatorOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    pattern?: SortOrder
    severidade?: SortOrderInput | SortOrder
    fonte?: SortOrderInput | SortOrder
    validadeInicio?: SortOrderInput | SortOrder
    validadeFim?: SortOrderInput | SortOrder
    sightings?: SightingOrderByRelationAggregateInput
    threats?: IndicatorThreatOrderByRelationAggregateInput
  }

  export type IndicatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IndicatorWhereInput | IndicatorWhereInput[]
    OR?: IndicatorWhereInput[]
    NOT?: IndicatorWhereInput | IndicatorWhereInput[]
    tipo?: StringFilter<"Indicator"> | string
    pattern?: StringFilter<"Indicator"> | string
    severidade?: IntNullableFilter<"Indicator"> | number | null
    fonte?: StringNullableFilter<"Indicator"> | string | null
    validadeInicio?: DateTimeNullableFilter<"Indicator"> | Date | string | null
    validadeFim?: DateTimeNullableFilter<"Indicator"> | Date | string | null
    sightings?: SightingListRelationFilter
    threats?: IndicatorThreatListRelationFilter
  }, "id">

  export type IndicatorOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    pattern?: SortOrder
    severidade?: SortOrderInput | SortOrder
    fonte?: SortOrderInput | SortOrder
    validadeInicio?: SortOrderInput | SortOrder
    validadeFim?: SortOrderInput | SortOrder
    _count?: IndicatorCountOrderByAggregateInput
    _avg?: IndicatorAvgOrderByAggregateInput
    _max?: IndicatorMaxOrderByAggregateInput
    _min?: IndicatorMinOrderByAggregateInput
    _sum?: IndicatorSumOrderByAggregateInput
  }

  export type IndicatorScalarWhereWithAggregatesInput = {
    AND?: IndicatorScalarWhereWithAggregatesInput | IndicatorScalarWhereWithAggregatesInput[]
    OR?: IndicatorScalarWhereWithAggregatesInput[]
    NOT?: IndicatorScalarWhereWithAggregatesInput | IndicatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Indicator"> | string
    tipo?: StringWithAggregatesFilter<"Indicator"> | string
    pattern?: StringWithAggregatesFilter<"Indicator"> | string
    severidade?: IntNullableWithAggregatesFilter<"Indicator"> | number | null
    fonte?: StringNullableWithAggregatesFilter<"Indicator"> | string | null
    validadeInicio?: DateTimeNullableWithAggregatesFilter<"Indicator"> | Date | string | null
    validadeFim?: DateTimeNullableWithAggregatesFilter<"Indicator"> | Date | string | null
  }

  export type ThreatEntityWhereInput = {
    AND?: ThreatEntityWhereInput | ThreatEntityWhereInput[]
    OR?: ThreatEntityWhereInput[]
    NOT?: ThreatEntityWhereInput | ThreatEntityWhereInput[]
    id?: StringFilter<"ThreatEntity"> | string
    tipo?: StringFilter<"ThreatEntity"> | string
    nome?: StringFilter<"ThreatEntity"> | string
    descricao?: StringNullableFilter<"ThreatEntity"> | string | null
    indicators?: IndicatorThreatListRelationFilter
  }

  export type ThreatEntityOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    indicators?: IndicatorThreatOrderByRelationAggregateInput
  }

  export type ThreatEntityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ThreatEntityWhereInput | ThreatEntityWhereInput[]
    OR?: ThreatEntityWhereInput[]
    NOT?: ThreatEntityWhereInput | ThreatEntityWhereInput[]
    tipo?: StringFilter<"ThreatEntity"> | string
    nome?: StringFilter<"ThreatEntity"> | string
    descricao?: StringNullableFilter<"ThreatEntity"> | string | null
    indicators?: IndicatorThreatListRelationFilter
  }, "id">

  export type ThreatEntityOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    _count?: ThreatEntityCountOrderByAggregateInput
    _max?: ThreatEntityMaxOrderByAggregateInput
    _min?: ThreatEntityMinOrderByAggregateInput
  }

  export type ThreatEntityScalarWhereWithAggregatesInput = {
    AND?: ThreatEntityScalarWhereWithAggregatesInput | ThreatEntityScalarWhereWithAggregatesInput[]
    OR?: ThreatEntityScalarWhereWithAggregatesInput[]
    NOT?: ThreatEntityScalarWhereWithAggregatesInput | ThreatEntityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ThreatEntity"> | string
    tipo?: StringWithAggregatesFilter<"ThreatEntity"> | string
    nome?: StringWithAggregatesFilter<"ThreatEntity"> | string
    descricao?: StringNullableWithAggregatesFilter<"ThreatEntity"> | string | null
  }

  export type IndicatorThreatWhereInput = {
    AND?: IndicatorThreatWhereInput | IndicatorThreatWhereInput[]
    OR?: IndicatorThreatWhereInput[]
    NOT?: IndicatorThreatWhereInput | IndicatorThreatWhereInput[]
    id?: StringFilter<"IndicatorThreat"> | string
    indicatorId?: StringFilter<"IndicatorThreat"> | string
    threatId?: StringFilter<"IndicatorThreat"> | string
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
    threat?: XOR<ThreatEntityScalarRelationFilter, ThreatEntityWhereInput>
  }

  export type IndicatorThreatOrderByWithRelationInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    threatId?: SortOrder
    indicator?: IndicatorOrderByWithRelationInput
    threat?: ThreatEntityOrderByWithRelationInput
  }

  export type IndicatorThreatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IndicatorThreatWhereInput | IndicatorThreatWhereInput[]
    OR?: IndicatorThreatWhereInput[]
    NOT?: IndicatorThreatWhereInput | IndicatorThreatWhereInput[]
    indicatorId?: StringFilter<"IndicatorThreat"> | string
    threatId?: StringFilter<"IndicatorThreat"> | string
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
    threat?: XOR<ThreatEntityScalarRelationFilter, ThreatEntityWhereInput>
  }, "id">

  export type IndicatorThreatOrderByWithAggregationInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    threatId?: SortOrder
    _count?: IndicatorThreatCountOrderByAggregateInput
    _max?: IndicatorThreatMaxOrderByAggregateInput
    _min?: IndicatorThreatMinOrderByAggregateInput
  }

  export type IndicatorThreatScalarWhereWithAggregatesInput = {
    AND?: IndicatorThreatScalarWhereWithAggregatesInput | IndicatorThreatScalarWhereWithAggregatesInput[]
    OR?: IndicatorThreatScalarWhereWithAggregatesInput[]
    NOT?: IndicatorThreatScalarWhereWithAggregatesInput | IndicatorThreatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IndicatorThreat"> | string
    indicatorId?: StringWithAggregatesFilter<"IndicatorThreat"> | string
    threatId?: StringWithAggregatesFilter<"IndicatorThreat"> | string
  }

  export type OT_EventWhereInput = {
    AND?: OT_EventWhereInput | OT_EventWhereInput[]
    OR?: OT_EventWhereInput[]
    NOT?: OT_EventWhereInput | OT_EventWhereInput[]
    id?: StringFilter<"OT_Event"> | string
    ts?: DateTimeFilter<"OT_Event"> | Date | string
    protocolo?: StringFilter<"OT_Event"> | string
    srcIp?: StringNullableFilter<"OT_Event"> | string | null
    dstIp?: StringNullableFilter<"OT_Event"> | string | null
    funcao?: StringNullableFilter<"OT_Event"> | string | null
    valor?: StringNullableFilter<"OT_Event"> | string | null
    anomalia?: BoolNullableFilter<"OT_Event"> | boolean | null
    assetId?: StringFilter<"OT_Event"> | string
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
  }

  export type OT_EventOrderByWithRelationInput = {
    id?: SortOrder
    ts?: SortOrder
    protocolo?: SortOrder
    srcIp?: SortOrderInput | SortOrder
    dstIp?: SortOrderInput | SortOrder
    funcao?: SortOrderInput | SortOrder
    valor?: SortOrderInput | SortOrder
    anomalia?: SortOrderInput | SortOrder
    assetId?: SortOrder
    asset?: AssetOrderByWithRelationInput
  }

  export type OT_EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OT_EventWhereInput | OT_EventWhereInput[]
    OR?: OT_EventWhereInput[]
    NOT?: OT_EventWhereInput | OT_EventWhereInput[]
    ts?: DateTimeFilter<"OT_Event"> | Date | string
    protocolo?: StringFilter<"OT_Event"> | string
    srcIp?: StringNullableFilter<"OT_Event"> | string | null
    dstIp?: StringNullableFilter<"OT_Event"> | string | null
    funcao?: StringNullableFilter<"OT_Event"> | string | null
    valor?: StringNullableFilter<"OT_Event"> | string | null
    anomalia?: BoolNullableFilter<"OT_Event"> | boolean | null
    assetId?: StringFilter<"OT_Event"> | string
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
  }, "id">

  export type OT_EventOrderByWithAggregationInput = {
    id?: SortOrder
    ts?: SortOrder
    protocolo?: SortOrder
    srcIp?: SortOrderInput | SortOrder
    dstIp?: SortOrderInput | SortOrder
    funcao?: SortOrderInput | SortOrder
    valor?: SortOrderInput | SortOrder
    anomalia?: SortOrderInput | SortOrder
    assetId?: SortOrder
    _count?: OT_EventCountOrderByAggregateInput
    _max?: OT_EventMaxOrderByAggregateInput
    _min?: OT_EventMinOrderByAggregateInput
  }

  export type OT_EventScalarWhereWithAggregatesInput = {
    AND?: OT_EventScalarWhereWithAggregatesInput | OT_EventScalarWhereWithAggregatesInput[]
    OR?: OT_EventScalarWhereWithAggregatesInput[]
    NOT?: OT_EventScalarWhereWithAggregatesInput | OT_EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OT_Event"> | string
    ts?: DateTimeWithAggregatesFilter<"OT_Event"> | Date | string
    protocolo?: StringWithAggregatesFilter<"OT_Event"> | string
    srcIp?: StringNullableWithAggregatesFilter<"OT_Event"> | string | null
    dstIp?: StringNullableWithAggregatesFilter<"OT_Event"> | string | null
    funcao?: StringNullableWithAggregatesFilter<"OT_Event"> | string | null
    valor?: StringNullableWithAggregatesFilter<"OT_Event"> | string | null
    anomalia?: BoolNullableWithAggregatesFilter<"OT_Event"> | boolean | null
    assetId?: StringWithAggregatesFilter<"OT_Event"> | string
  }

  export type SightingWhereInput = {
    AND?: SightingWhereInput | SightingWhereInput[]
    OR?: SightingWhereInput[]
    NOT?: SightingWhereInput | SightingWhereInput[]
    id?: StringFilter<"Sighting"> | string
    ts?: DateTimeFilter<"Sighting"> | Date | string
    count?: IntFilter<"Sighting"> | number
    indicatorId?: StringFilter<"Sighting"> | string
    assetId?: StringFilter<"Sighting"> | string
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
  }

  export type SightingOrderByWithRelationInput = {
    id?: SortOrder
    ts?: SortOrder
    count?: SortOrder
    indicatorId?: SortOrder
    assetId?: SortOrder
    indicator?: IndicatorOrderByWithRelationInput
    asset?: AssetOrderByWithRelationInput
  }

  export type SightingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SightingWhereInput | SightingWhereInput[]
    OR?: SightingWhereInput[]
    NOT?: SightingWhereInput | SightingWhereInput[]
    ts?: DateTimeFilter<"Sighting"> | Date | string
    count?: IntFilter<"Sighting"> | number
    indicatorId?: StringFilter<"Sighting"> | string
    assetId?: StringFilter<"Sighting"> | string
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
  }, "id">

  export type SightingOrderByWithAggregationInput = {
    id?: SortOrder
    ts?: SortOrder
    count?: SortOrder
    indicatorId?: SortOrder
    assetId?: SortOrder
    _count?: SightingCountOrderByAggregateInput
    _avg?: SightingAvgOrderByAggregateInput
    _max?: SightingMaxOrderByAggregateInput
    _min?: SightingMinOrderByAggregateInput
    _sum?: SightingSumOrderByAggregateInput
  }

  export type SightingScalarWhereWithAggregatesInput = {
    AND?: SightingScalarWhereWithAggregatesInput | SightingScalarWhereWithAggregatesInput[]
    OR?: SightingScalarWhereWithAggregatesInput[]
    NOT?: SightingScalarWhereWithAggregatesInput | SightingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sighting"> | string
    ts?: DateTimeWithAggregatesFilter<"Sighting"> | Date | string
    count?: IntWithAggregatesFilter<"Sighting"> | number
    indicatorId?: StringWithAggregatesFilter<"Sighting"> | string
    assetId?: StringWithAggregatesFilter<"Sighting"> | string
  }

  export type CaseWhereInput = {
    AND?: CaseWhereInput | CaseWhereInput[]
    OR?: CaseWhereInput[]
    NOT?: CaseWhereInput | CaseWhereInput[]
    id?: StringFilter<"Case"> | string
    titulo?: StringFilter<"Case"> | string
    status?: StringFilter<"Case"> | string
    responsavel?: StringNullableFilter<"Case"> | string | null
    criadoEm?: DateTimeFilter<"Case"> | Date | string
    evidencias?: EvidenceListRelationFilter
  }

  export type CaseOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    status?: SortOrder
    responsavel?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    evidencias?: EvidenceOrderByRelationAggregateInput
  }

  export type CaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CaseWhereInput | CaseWhereInput[]
    OR?: CaseWhereInput[]
    NOT?: CaseWhereInput | CaseWhereInput[]
    titulo?: StringFilter<"Case"> | string
    status?: StringFilter<"Case"> | string
    responsavel?: StringNullableFilter<"Case"> | string | null
    criadoEm?: DateTimeFilter<"Case"> | Date | string
    evidencias?: EvidenceListRelationFilter
  }, "id">

  export type CaseOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    status?: SortOrder
    responsavel?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    _count?: CaseCountOrderByAggregateInput
    _max?: CaseMaxOrderByAggregateInput
    _min?: CaseMinOrderByAggregateInput
  }

  export type CaseScalarWhereWithAggregatesInput = {
    AND?: CaseScalarWhereWithAggregatesInput | CaseScalarWhereWithAggregatesInput[]
    OR?: CaseScalarWhereWithAggregatesInput[]
    NOT?: CaseScalarWhereWithAggregatesInput | CaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Case"> | string
    titulo?: StringWithAggregatesFilter<"Case"> | string
    status?: StringWithAggregatesFilter<"Case"> | string
    responsavel?: StringNullableWithAggregatesFilter<"Case"> | string | null
    criadoEm?: DateTimeWithAggregatesFilter<"Case"> | Date | string
  }

  export type EvidenceWhereInput = {
    AND?: EvidenceWhereInput | EvidenceWhereInput[]
    OR?: EvidenceWhereInput[]
    NOT?: EvidenceWhereInput | EvidenceWhereInput[]
    id?: StringFilter<"Evidence"> | string
    tipo?: StringFilter<"Evidence"> | string
    caminho?: StringFilter<"Evidence"> | string
    hashSha256?: StringFilter<"Evidence"> | string
    coletadoEm?: DateTimeFilter<"Evidence"> | Date | string
    tamanho?: IntNullableFilter<"Evidence"> | number | null
    caseId?: StringFilter<"Evidence"> | string
    case?: XOR<CaseScalarRelationFilter, CaseWhereInput>
    custodies?: CustodyListRelationFilter
  }

  export type EvidenceOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    caminho?: SortOrder
    hashSha256?: SortOrder
    coletadoEm?: SortOrder
    tamanho?: SortOrderInput | SortOrder
    caseId?: SortOrder
    case?: CaseOrderByWithRelationInput
    custodies?: CustodyOrderByRelationAggregateInput
  }

  export type EvidenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvidenceWhereInput | EvidenceWhereInput[]
    OR?: EvidenceWhereInput[]
    NOT?: EvidenceWhereInput | EvidenceWhereInput[]
    tipo?: StringFilter<"Evidence"> | string
    caminho?: StringFilter<"Evidence"> | string
    hashSha256?: StringFilter<"Evidence"> | string
    coletadoEm?: DateTimeFilter<"Evidence"> | Date | string
    tamanho?: IntNullableFilter<"Evidence"> | number | null
    caseId?: StringFilter<"Evidence"> | string
    case?: XOR<CaseScalarRelationFilter, CaseWhereInput>
    custodies?: CustodyListRelationFilter
  }, "id">

  export type EvidenceOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    caminho?: SortOrder
    hashSha256?: SortOrder
    coletadoEm?: SortOrder
    tamanho?: SortOrderInput | SortOrder
    caseId?: SortOrder
    _count?: EvidenceCountOrderByAggregateInput
    _avg?: EvidenceAvgOrderByAggregateInput
    _max?: EvidenceMaxOrderByAggregateInput
    _min?: EvidenceMinOrderByAggregateInput
    _sum?: EvidenceSumOrderByAggregateInput
  }

  export type EvidenceScalarWhereWithAggregatesInput = {
    AND?: EvidenceScalarWhereWithAggregatesInput | EvidenceScalarWhereWithAggregatesInput[]
    OR?: EvidenceScalarWhereWithAggregatesInput[]
    NOT?: EvidenceScalarWhereWithAggregatesInput | EvidenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evidence"> | string
    tipo?: StringWithAggregatesFilter<"Evidence"> | string
    caminho?: StringWithAggregatesFilter<"Evidence"> | string
    hashSha256?: StringWithAggregatesFilter<"Evidence"> | string
    coletadoEm?: DateTimeWithAggregatesFilter<"Evidence"> | Date | string
    tamanho?: IntNullableWithAggregatesFilter<"Evidence"> | number | null
    caseId?: StringWithAggregatesFilter<"Evidence"> | string
  }

  export type CustodyWhereInput = {
    AND?: CustodyWhereInput | CustodyWhereInput[]
    OR?: CustodyWhereInput[]
    NOT?: CustodyWhereInput | CustodyWhereInput[]
    id?: StringFilter<"Custody"> | string
    acao?: StringFilter<"Custody"> | string
    ator?: StringFilter<"Custody"> | string
    local?: StringNullableFilter<"Custody"> | string | null
    ts?: DateTimeFilter<"Custody"> | Date | string
    assinatura?: StringNullableFilter<"Custody"> | string | null
    evidenceId?: StringFilter<"Custody"> | string
    evidence?: XOR<EvidenceScalarRelationFilter, EvidenceWhereInput>
  }

  export type CustodyOrderByWithRelationInput = {
    id?: SortOrder
    acao?: SortOrder
    ator?: SortOrder
    local?: SortOrderInput | SortOrder
    ts?: SortOrder
    assinatura?: SortOrderInput | SortOrder
    evidenceId?: SortOrder
    evidence?: EvidenceOrderByWithRelationInput
  }

  export type CustodyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustodyWhereInput | CustodyWhereInput[]
    OR?: CustodyWhereInput[]
    NOT?: CustodyWhereInput | CustodyWhereInput[]
    acao?: StringFilter<"Custody"> | string
    ator?: StringFilter<"Custody"> | string
    local?: StringNullableFilter<"Custody"> | string | null
    ts?: DateTimeFilter<"Custody"> | Date | string
    assinatura?: StringNullableFilter<"Custody"> | string | null
    evidenceId?: StringFilter<"Custody"> | string
    evidence?: XOR<EvidenceScalarRelationFilter, EvidenceWhereInput>
  }, "id">

  export type CustodyOrderByWithAggregationInput = {
    id?: SortOrder
    acao?: SortOrder
    ator?: SortOrder
    local?: SortOrderInput | SortOrder
    ts?: SortOrder
    assinatura?: SortOrderInput | SortOrder
    evidenceId?: SortOrder
    _count?: CustodyCountOrderByAggregateInput
    _max?: CustodyMaxOrderByAggregateInput
    _min?: CustodyMinOrderByAggregateInput
  }

  export type CustodyScalarWhereWithAggregatesInput = {
    AND?: CustodyScalarWhereWithAggregatesInput | CustodyScalarWhereWithAggregatesInput[]
    OR?: CustodyScalarWhereWithAggregatesInput[]
    NOT?: CustodyScalarWhereWithAggregatesInput | CustodyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Custody"> | string
    acao?: StringWithAggregatesFilter<"Custody"> | string
    ator?: StringWithAggregatesFilter<"Custody"> | string
    local?: StringNullableWithAggregatesFilter<"Custody"> | string | null
    ts?: DateTimeWithAggregatesFilter<"Custody"> | Date | string
    assinatura?: StringNullableWithAggregatesFilter<"Custody"> | string | null
    evidenceId?: StringWithAggregatesFilter<"Custody"> | string
  }

  export type AttackScenarioWhereInput = {
    AND?: AttackScenarioWhereInput | AttackScenarioWhereInput[]
    OR?: AttackScenarioWhereInput[]
    NOT?: AttackScenarioWhereInput | AttackScenarioWhereInput[]
    id?: StringFilter<"AttackScenario"> | string
    nome?: StringFilter<"AttackScenario"> | string
    descricao?: StringNullableFilter<"AttackScenario"> | string | null
    protocolo?: StringNullableFilter<"AttackScenario"> | string | null
    tecnicaMITRE?: StringNullableFilter<"AttackScenario"> | string | null
    runs?: AttackRunListRelationFilter
  }

  export type AttackScenarioOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    protocolo?: SortOrderInput | SortOrder
    tecnicaMITRE?: SortOrderInput | SortOrder
    runs?: AttackRunOrderByRelationAggregateInput
  }

  export type AttackScenarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttackScenarioWhereInput | AttackScenarioWhereInput[]
    OR?: AttackScenarioWhereInput[]
    NOT?: AttackScenarioWhereInput | AttackScenarioWhereInput[]
    nome?: StringFilter<"AttackScenario"> | string
    descricao?: StringNullableFilter<"AttackScenario"> | string | null
    protocolo?: StringNullableFilter<"AttackScenario"> | string | null
    tecnicaMITRE?: StringNullableFilter<"AttackScenario"> | string | null
    runs?: AttackRunListRelationFilter
  }, "id">

  export type AttackScenarioOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    protocolo?: SortOrderInput | SortOrder
    tecnicaMITRE?: SortOrderInput | SortOrder
    _count?: AttackScenarioCountOrderByAggregateInput
    _max?: AttackScenarioMaxOrderByAggregateInput
    _min?: AttackScenarioMinOrderByAggregateInput
  }

  export type AttackScenarioScalarWhereWithAggregatesInput = {
    AND?: AttackScenarioScalarWhereWithAggregatesInput | AttackScenarioScalarWhereWithAggregatesInput[]
    OR?: AttackScenarioScalarWhereWithAggregatesInput[]
    NOT?: AttackScenarioScalarWhereWithAggregatesInput | AttackScenarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttackScenario"> | string
    nome?: StringWithAggregatesFilter<"AttackScenario"> | string
    descricao?: StringNullableWithAggregatesFilter<"AttackScenario"> | string | null
    protocolo?: StringNullableWithAggregatesFilter<"AttackScenario"> | string | null
    tecnicaMITRE?: StringNullableWithAggregatesFilter<"AttackScenario"> | string | null
  }

  export type AttackRunWhereInput = {
    AND?: AttackRunWhereInput | AttackRunWhereInput[]
    OR?: AttackRunWhereInput[]
    NOT?: AttackRunWhereInput | AttackRunWhereInput[]
    id?: StringFilter<"AttackRun"> | string
    tsInicio?: DateTimeFilter<"AttackRun"> | Date | string
    tsFim?: DateTimeNullableFilter<"AttackRun"> | Date | string | null
    status?: StringNullableFilter<"AttackRun"> | string | null
    scenarioId?: StringFilter<"AttackRun"> | string
    userId?: StringFilter<"AttackRun"> | string
    assetId?: StringFilter<"AttackRun"> | string
    scenario?: XOR<AttackScenarioScalarRelationFilter, AttackScenarioWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    results?: AttackResultListRelationFilter
  }

  export type AttackRunOrderByWithRelationInput = {
    id?: SortOrder
    tsInicio?: SortOrder
    tsFim?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    scenarioId?: SortOrder
    userId?: SortOrder
    assetId?: SortOrder
    scenario?: AttackScenarioOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    asset?: AssetOrderByWithRelationInput
    results?: AttackResultOrderByRelationAggregateInput
  }

  export type AttackRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttackRunWhereInput | AttackRunWhereInput[]
    OR?: AttackRunWhereInput[]
    NOT?: AttackRunWhereInput | AttackRunWhereInput[]
    tsInicio?: DateTimeFilter<"AttackRun"> | Date | string
    tsFim?: DateTimeNullableFilter<"AttackRun"> | Date | string | null
    status?: StringNullableFilter<"AttackRun"> | string | null
    scenarioId?: StringFilter<"AttackRun"> | string
    userId?: StringFilter<"AttackRun"> | string
    assetId?: StringFilter<"AttackRun"> | string
    scenario?: XOR<AttackScenarioScalarRelationFilter, AttackScenarioWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>
    results?: AttackResultListRelationFilter
  }, "id">

  export type AttackRunOrderByWithAggregationInput = {
    id?: SortOrder
    tsInicio?: SortOrder
    tsFim?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    scenarioId?: SortOrder
    userId?: SortOrder
    assetId?: SortOrder
    _count?: AttackRunCountOrderByAggregateInput
    _max?: AttackRunMaxOrderByAggregateInput
    _min?: AttackRunMinOrderByAggregateInput
  }

  export type AttackRunScalarWhereWithAggregatesInput = {
    AND?: AttackRunScalarWhereWithAggregatesInput | AttackRunScalarWhereWithAggregatesInput[]
    OR?: AttackRunScalarWhereWithAggregatesInput[]
    NOT?: AttackRunScalarWhereWithAggregatesInput | AttackRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttackRun"> | string
    tsInicio?: DateTimeWithAggregatesFilter<"AttackRun"> | Date | string
    tsFim?: DateTimeNullableWithAggregatesFilter<"AttackRun"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"AttackRun"> | string | null
    scenarioId?: StringWithAggregatesFilter<"AttackRun"> | string
    userId?: StringWithAggregatesFilter<"AttackRun"> | string
    assetId?: StringWithAggregatesFilter<"AttackRun"> | string
  }

  export type AttackResultWhereInput = {
    AND?: AttackResultWhereInput | AttackResultWhereInput[]
    OR?: AttackResultWhereInput[]
    NOT?: AttackResultWhereInput | AttackResultWhereInput[]
    id?: StringFilter<"AttackResult"> | string
    sucesso?: BoolFilter<"AttackResult"> | boolean
    impacto?: StringNullableFilter<"AttackResult"> | string | null
    logs?: StringNullableFilter<"AttackResult"> | string | null
    iocsGerados?: StringNullableFilter<"AttackResult"> | string | null
    runId?: StringFilter<"AttackResult"> | string
    run?: XOR<AttackRunScalarRelationFilter, AttackRunWhereInput>
  }

  export type AttackResultOrderByWithRelationInput = {
    id?: SortOrder
    sucesso?: SortOrder
    impacto?: SortOrderInput | SortOrder
    logs?: SortOrderInput | SortOrder
    iocsGerados?: SortOrderInput | SortOrder
    runId?: SortOrder
    run?: AttackRunOrderByWithRelationInput
  }

  export type AttackResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttackResultWhereInput | AttackResultWhereInput[]
    OR?: AttackResultWhereInput[]
    NOT?: AttackResultWhereInput | AttackResultWhereInput[]
    sucesso?: BoolFilter<"AttackResult"> | boolean
    impacto?: StringNullableFilter<"AttackResult"> | string | null
    logs?: StringNullableFilter<"AttackResult"> | string | null
    iocsGerados?: StringNullableFilter<"AttackResult"> | string | null
    runId?: StringFilter<"AttackResult"> | string
    run?: XOR<AttackRunScalarRelationFilter, AttackRunWhereInput>
  }, "id">

  export type AttackResultOrderByWithAggregationInput = {
    id?: SortOrder
    sucesso?: SortOrder
    impacto?: SortOrderInput | SortOrder
    logs?: SortOrderInput | SortOrder
    iocsGerados?: SortOrderInput | SortOrder
    runId?: SortOrder
    _count?: AttackResultCountOrderByAggregateInput
    _max?: AttackResultMaxOrderByAggregateInput
    _min?: AttackResultMinOrderByAggregateInput
  }

  export type AttackResultScalarWhereWithAggregatesInput = {
    AND?: AttackResultScalarWhereWithAggregatesInput | AttackResultScalarWhereWithAggregatesInput[]
    OR?: AttackResultScalarWhereWithAggregatesInput[]
    NOT?: AttackResultScalarWhereWithAggregatesInput | AttackResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttackResult"> | string
    sucesso?: BoolWithAggregatesFilter<"AttackResult"> | boolean
    impacto?: StringNullableWithAggregatesFilter<"AttackResult"> | string | null
    logs?: StringNullableWithAggregatesFilter<"AttackResult"> | string | null
    iocsGerados?: StringNullableWithAggregatesFilter<"AttackResult"> | string | null
    runId?: StringWithAggregatesFilter<"AttackResult"> | string
  }

  export type UserCreateInput = {
    id?: string
    nome: string
    email: string
    papel: string
    senhaHash: string
    attackRuns?: AttackRunCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    nome: string
    email: string
    papel: string
    senhaHash: string
    attackRuns?: AttackRunUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    attackRuns?: AttackRunUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    attackRuns?: AttackRunUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    nome: string
    email: string
    papel: string
    senhaHash: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
  }

  export type AssetCreateInput = {
    id?: string
    nome: string
    tipo: string
    fabricante?: string | null
    modelo?: string | null
    ip?: string | null
    zona?: string | null
    criticidade?: number | null
    events?: OT_EventCreateNestedManyWithoutAssetInput
    sightings?: SightingCreateNestedManyWithoutAssetInput
    attackRuns?: AttackRunCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    nome: string
    tipo: string
    fabricante?: string | null
    modelo?: string | null
    ip?: string | null
    zona?: string | null
    criticidade?: number | null
    events?: OT_EventUncheckedCreateNestedManyWithoutAssetInput
    sightings?: SightingUncheckedCreateNestedManyWithoutAssetInput
    attackRuns?: AttackRunUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableStringFieldUpdateOperationsInput | string | null
    criticidade?: NullableIntFieldUpdateOperationsInput | number | null
    events?: OT_EventUpdateManyWithoutAssetNestedInput
    sightings?: SightingUpdateManyWithoutAssetNestedInput
    attackRuns?: AttackRunUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableStringFieldUpdateOperationsInput | string | null
    criticidade?: NullableIntFieldUpdateOperationsInput | number | null
    events?: OT_EventUncheckedUpdateManyWithoutAssetNestedInput
    sightings?: SightingUncheckedUpdateManyWithoutAssetNestedInput
    attackRuns?: AttackRunUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetCreateManyInput = {
    id?: string
    nome: string
    tipo: string
    fabricante?: string | null
    modelo?: string | null
    ip?: string | null
    zona?: string | null
    criticidade?: number | null
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableStringFieldUpdateOperationsInput | string | null
    criticidade?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableStringFieldUpdateOperationsInput | string | null
    criticidade?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IndicatorCreateInput = {
    id?: string
    tipo: string
    pattern: string
    severidade?: number | null
    fonte?: string | null
    validadeInicio?: Date | string | null
    validadeFim?: Date | string | null
    sightings?: SightingCreateNestedManyWithoutIndicatorInput
    threats?: IndicatorThreatCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateInput = {
    id?: string
    tipo: string
    pattern: string
    severidade?: number | null
    fonte?: string | null
    validadeInicio?: Date | string | null
    validadeFim?: Date | string | null
    sightings?: SightingUncheckedCreateNestedManyWithoutIndicatorInput
    threats?: IndicatorThreatUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    severidade?: NullableIntFieldUpdateOperationsInput | number | null
    fonte?: NullableStringFieldUpdateOperationsInput | string | null
    validadeInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadeFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sightings?: SightingUpdateManyWithoutIndicatorNestedInput
    threats?: IndicatorThreatUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    severidade?: NullableIntFieldUpdateOperationsInput | number | null
    fonte?: NullableStringFieldUpdateOperationsInput | string | null
    validadeInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadeFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sightings?: SightingUncheckedUpdateManyWithoutIndicatorNestedInput
    threats?: IndicatorThreatUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorCreateManyInput = {
    id?: string
    tipo: string
    pattern: string
    severidade?: number | null
    fonte?: string | null
    validadeInicio?: Date | string | null
    validadeFim?: Date | string | null
  }

  export type IndicatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    severidade?: NullableIntFieldUpdateOperationsInput | number | null
    fonte?: NullableStringFieldUpdateOperationsInput | string | null
    validadeInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadeFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IndicatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    severidade?: NullableIntFieldUpdateOperationsInput | number | null
    fonte?: NullableStringFieldUpdateOperationsInput | string | null
    validadeInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadeFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ThreatEntityCreateInput = {
    id?: string
    tipo: string
    nome: string
    descricao?: string | null
    indicators?: IndicatorThreatCreateNestedManyWithoutThreatInput
  }

  export type ThreatEntityUncheckedCreateInput = {
    id?: string
    tipo: string
    nome: string
    descricao?: string | null
    indicators?: IndicatorThreatUncheckedCreateNestedManyWithoutThreatInput
  }

  export type ThreatEntityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    indicators?: IndicatorThreatUpdateManyWithoutThreatNestedInput
  }

  export type ThreatEntityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    indicators?: IndicatorThreatUncheckedUpdateManyWithoutThreatNestedInput
  }

  export type ThreatEntityCreateManyInput = {
    id?: string
    tipo: string
    nome: string
    descricao?: string | null
  }

  export type ThreatEntityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThreatEntityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IndicatorThreatCreateInput = {
    id?: string
    indicator: IndicatorCreateNestedOneWithoutThreatsInput
    threat: ThreatEntityCreateNestedOneWithoutIndicatorsInput
  }

  export type IndicatorThreatUncheckedCreateInput = {
    id?: string
    indicatorId: string
    threatId: string
  }

  export type IndicatorThreatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicator?: IndicatorUpdateOneRequiredWithoutThreatsNestedInput
    threat?: ThreatEntityUpdateOneRequiredWithoutIndicatorsNestedInput
  }

  export type IndicatorThreatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    threatId?: StringFieldUpdateOperationsInput | string
  }

  export type IndicatorThreatCreateManyInput = {
    id?: string
    indicatorId: string
    threatId: string
  }

  export type IndicatorThreatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type IndicatorThreatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
    threatId?: StringFieldUpdateOperationsInput | string
  }

  export type OT_EventCreateInput = {
    id?: string
    ts: Date | string
    protocolo: string
    srcIp?: string | null
    dstIp?: string | null
    funcao?: string | null
    valor?: string | null
    anomalia?: boolean | null
    asset: AssetCreateNestedOneWithoutEventsInput
  }

  export type OT_EventUncheckedCreateInput = {
    id?: string
    ts: Date | string
    protocolo: string
    srcIp?: string | null
    dstIp?: string | null
    funcao?: string | null
    valor?: string | null
    anomalia?: boolean | null
    assetId: string
  }

  export type OT_EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolo?: StringFieldUpdateOperationsInput | string
    srcIp?: NullableStringFieldUpdateOperationsInput | string | null
    dstIp?: NullableStringFieldUpdateOperationsInput | string | null
    funcao?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    anomalia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    asset?: AssetUpdateOneRequiredWithoutEventsNestedInput
  }

  export type OT_EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolo?: StringFieldUpdateOperationsInput | string
    srcIp?: NullableStringFieldUpdateOperationsInput | string | null
    dstIp?: NullableStringFieldUpdateOperationsInput | string | null
    funcao?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    anomalia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assetId?: StringFieldUpdateOperationsInput | string
  }

  export type OT_EventCreateManyInput = {
    id?: string
    ts: Date | string
    protocolo: string
    srcIp?: string | null
    dstIp?: string | null
    funcao?: string | null
    valor?: string | null
    anomalia?: boolean | null
    assetId: string
  }

  export type OT_EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolo?: StringFieldUpdateOperationsInput | string
    srcIp?: NullableStringFieldUpdateOperationsInput | string | null
    dstIp?: NullableStringFieldUpdateOperationsInput | string | null
    funcao?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    anomalia?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OT_EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolo?: StringFieldUpdateOperationsInput | string
    srcIp?: NullableStringFieldUpdateOperationsInput | string | null
    dstIp?: NullableStringFieldUpdateOperationsInput | string | null
    funcao?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    anomalia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assetId?: StringFieldUpdateOperationsInput | string
  }

  export type SightingCreateInput = {
    id?: string
    ts: Date | string
    count?: number
    indicator: IndicatorCreateNestedOneWithoutSightingsInput
    asset: AssetCreateNestedOneWithoutSightingsInput
  }

  export type SightingUncheckedCreateInput = {
    id?: string
    ts: Date | string
    count?: number
    indicatorId: string
    assetId: string
  }

  export type SightingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    indicator?: IndicatorUpdateOneRequiredWithoutSightingsNestedInput
    asset?: AssetUpdateOneRequiredWithoutSightingsNestedInput
  }

  export type SightingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    indicatorId?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
  }

  export type SightingCreateManyInput = {
    id?: string
    ts: Date | string
    count?: number
    indicatorId: string
    assetId: string
  }

  export type SightingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
  }

  export type SightingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    indicatorId?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
  }

  export type CaseCreateInput = {
    id?: string
    titulo: string
    status: string
    responsavel?: string | null
    criadoEm?: Date | string
    evidencias?: EvidenceCreateNestedManyWithoutCaseInput
  }

  export type CaseUncheckedCreateInput = {
    id?: string
    titulo: string
    status: string
    responsavel?: string | null
    criadoEm?: Date | string
    evidencias?: EvidenceUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    evidencias?: EvidenceUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    evidencias?: EvidenceUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type CaseCreateManyInput = {
    id?: string
    titulo: string
    status: string
    responsavel?: string | null
    criadoEm?: Date | string
  }

  export type CaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceCreateInput = {
    id?: string
    tipo: string
    caminho: string
    hashSha256: string
    coletadoEm?: Date | string
    tamanho?: number | null
    case: CaseCreateNestedOneWithoutEvidenciasInput
    custodies?: CustodyCreateNestedManyWithoutEvidenceInput
  }

  export type EvidenceUncheckedCreateInput = {
    id?: string
    tipo: string
    caminho: string
    hashSha256: string
    coletadoEm?: Date | string
    tamanho?: number | null
    caseId: string
    custodies?: CustodyUncheckedCreateNestedManyWithoutEvidenceInput
  }

  export type EvidenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    caminho?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    coletadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tamanho?: NullableIntFieldUpdateOperationsInput | number | null
    case?: CaseUpdateOneRequiredWithoutEvidenciasNestedInput
    custodies?: CustodyUpdateManyWithoutEvidenceNestedInput
  }

  export type EvidenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    caminho?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    coletadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tamanho?: NullableIntFieldUpdateOperationsInput | number | null
    caseId?: StringFieldUpdateOperationsInput | string
    custodies?: CustodyUncheckedUpdateManyWithoutEvidenceNestedInput
  }

  export type EvidenceCreateManyInput = {
    id?: string
    tipo: string
    caminho: string
    hashSha256: string
    coletadoEm?: Date | string
    tamanho?: number | null
    caseId: string
  }

  export type EvidenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    caminho?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    coletadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tamanho?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EvidenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    caminho?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    coletadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tamanho?: NullableIntFieldUpdateOperationsInput | number | null
    caseId?: StringFieldUpdateOperationsInput | string
  }

  export type CustodyCreateInput = {
    id?: string
    acao: string
    ator: string
    local?: string | null
    ts: Date | string
    assinatura?: string | null
    evidence: EvidenceCreateNestedOneWithoutCustodiesInput
  }

  export type CustodyUncheckedCreateInput = {
    id?: string
    acao: string
    ator: string
    local?: string | null
    ts: Date | string
    assinatura?: string | null
    evidenceId: string
  }

  export type CustodyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acao?: StringFieldUpdateOperationsInput | string
    ator?: StringFieldUpdateOperationsInput | string
    local?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    assinatura?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: EvidenceUpdateOneRequiredWithoutCustodiesNestedInput
  }

  export type CustodyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acao?: StringFieldUpdateOperationsInput | string
    ator?: StringFieldUpdateOperationsInput | string
    local?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    assinatura?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceId?: StringFieldUpdateOperationsInput | string
  }

  export type CustodyCreateManyInput = {
    id?: string
    acao: string
    ator: string
    local?: string | null
    ts: Date | string
    assinatura?: string | null
    evidenceId: string
  }

  export type CustodyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    acao?: StringFieldUpdateOperationsInput | string
    ator?: StringFieldUpdateOperationsInput | string
    local?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    assinatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustodyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    acao?: StringFieldUpdateOperationsInput | string
    ator?: StringFieldUpdateOperationsInput | string
    local?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    assinatura?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceId?: StringFieldUpdateOperationsInput | string
  }

  export type AttackScenarioCreateInput = {
    id?: string
    nome: string
    descricao?: string | null
    protocolo?: string | null
    tecnicaMITRE?: string | null
    runs?: AttackRunCreateNestedManyWithoutScenarioInput
  }

  export type AttackScenarioUncheckedCreateInput = {
    id?: string
    nome: string
    descricao?: string | null
    protocolo?: string | null
    tecnicaMITRE?: string | null
    runs?: AttackRunUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type AttackScenarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicaMITRE?: NullableStringFieldUpdateOperationsInput | string | null
    runs?: AttackRunUpdateManyWithoutScenarioNestedInput
  }

  export type AttackScenarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicaMITRE?: NullableStringFieldUpdateOperationsInput | string | null
    runs?: AttackRunUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type AttackScenarioCreateManyInput = {
    id?: string
    nome: string
    descricao?: string | null
    protocolo?: string | null
    tecnicaMITRE?: string | null
  }

  export type AttackScenarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicaMITRE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttackScenarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicaMITRE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttackRunCreateInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    scenario: AttackScenarioCreateNestedOneWithoutRunsInput
    user: UserCreateNestedOneWithoutAttackRunsInput
    asset: AssetCreateNestedOneWithoutAttackRunsInput
    results?: AttackResultCreateNestedManyWithoutRunInput
  }

  export type AttackRunUncheckedCreateInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    scenarioId: string
    userId: string
    assetId: string
    results?: AttackResultUncheckedCreateNestedManyWithoutRunInput
  }

  export type AttackRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    scenario?: AttackScenarioUpdateOneRequiredWithoutRunsNestedInput
    user?: UserUpdateOneRequiredWithoutAttackRunsNestedInput
    asset?: AssetUpdateOneRequiredWithoutAttackRunsNestedInput
    results?: AttackResultUpdateManyWithoutRunNestedInput
  }

  export type AttackRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    results?: AttackResultUncheckedUpdateManyWithoutRunNestedInput
  }

  export type AttackRunCreateManyInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    scenarioId: string
    userId: string
    assetId: string
  }

  export type AttackRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttackRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
  }

  export type AttackResultCreateInput = {
    id?: string
    sucesso: boolean
    impacto?: string | null
    logs?: string | null
    iocsGerados?: string | null
    run: AttackRunCreateNestedOneWithoutResultsInput
  }

  export type AttackResultUncheckedCreateInput = {
    id?: string
    sucesso: boolean
    impacto?: string | null
    logs?: string | null
    iocsGerados?: string | null
    runId: string
  }

  export type AttackResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sucesso?: BoolFieldUpdateOperationsInput | boolean
    impacto?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    iocsGerados?: NullableStringFieldUpdateOperationsInput | string | null
    run?: AttackRunUpdateOneRequiredWithoutResultsNestedInput
  }

  export type AttackResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sucesso?: BoolFieldUpdateOperationsInput | boolean
    impacto?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    iocsGerados?: NullableStringFieldUpdateOperationsInput | string | null
    runId?: StringFieldUpdateOperationsInput | string
  }

  export type AttackResultCreateManyInput = {
    id?: string
    sucesso: boolean
    impacto?: string | null
    logs?: string | null
    iocsGerados?: string | null
    runId: string
  }

  export type AttackResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sucesso?: BoolFieldUpdateOperationsInput | boolean
    impacto?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    iocsGerados?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttackResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sucesso?: BoolFieldUpdateOperationsInput | boolean
    impacto?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    iocsGerados?: NullableStringFieldUpdateOperationsInput | string | null
    runId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AttackRunListRelationFilter = {
    every?: AttackRunWhereInput
    some?: AttackRunWhereInput
    none?: AttackRunWhereInput
  }

  export type AttackRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    papel?: SortOrder
    senhaHash?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    papel?: SortOrder
    senhaHash?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    papel?: SortOrder
    senhaHash?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type OT_EventListRelationFilter = {
    every?: OT_EventWhereInput
    some?: OT_EventWhereInput
    none?: OT_EventWhereInput
  }

  export type SightingListRelationFilter = {
    every?: SightingWhereInput
    some?: SightingWhereInput
    none?: SightingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OT_EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SightingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    fabricante?: SortOrder
    modelo?: SortOrder
    ip?: SortOrder
    zona?: SortOrder
    criticidade?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    criticidade?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    fabricante?: SortOrder
    modelo?: SortOrder
    ip?: SortOrder
    zona?: SortOrder
    criticidade?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    fabricante?: SortOrder
    modelo?: SortOrder
    ip?: SortOrder
    zona?: SortOrder
    criticidade?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    criticidade?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IndicatorThreatListRelationFilter = {
    every?: IndicatorThreatWhereInput
    some?: IndicatorThreatWhereInput
    none?: IndicatorThreatWhereInput
  }

  export type IndicatorThreatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IndicatorCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    pattern?: SortOrder
    severidade?: SortOrder
    fonte?: SortOrder
    validadeInicio?: SortOrder
    validadeFim?: SortOrder
  }

  export type IndicatorAvgOrderByAggregateInput = {
    severidade?: SortOrder
  }

  export type IndicatorMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    pattern?: SortOrder
    severidade?: SortOrder
    fonte?: SortOrder
    validadeInicio?: SortOrder
    validadeFim?: SortOrder
  }

  export type IndicatorMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    pattern?: SortOrder
    severidade?: SortOrder
    fonte?: SortOrder
    validadeInicio?: SortOrder
    validadeFim?: SortOrder
  }

  export type IndicatorSumOrderByAggregateInput = {
    severidade?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ThreatEntityCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type ThreatEntityMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type ThreatEntityMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type IndicatorScalarRelationFilter = {
    is?: IndicatorWhereInput
    isNot?: IndicatorWhereInput
  }

  export type ThreatEntityScalarRelationFilter = {
    is?: ThreatEntityWhereInput
    isNot?: ThreatEntityWhereInput
  }

  export type IndicatorThreatCountOrderByAggregateInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    threatId?: SortOrder
  }

  export type IndicatorThreatMaxOrderByAggregateInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    threatId?: SortOrder
  }

  export type IndicatorThreatMinOrderByAggregateInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    threatId?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type AssetScalarRelationFilter = {
    is?: AssetWhereInput
    isNot?: AssetWhereInput
  }

  export type OT_EventCountOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    protocolo?: SortOrder
    srcIp?: SortOrder
    dstIp?: SortOrder
    funcao?: SortOrder
    valor?: SortOrder
    anomalia?: SortOrder
    assetId?: SortOrder
  }

  export type OT_EventMaxOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    protocolo?: SortOrder
    srcIp?: SortOrder
    dstIp?: SortOrder
    funcao?: SortOrder
    valor?: SortOrder
    anomalia?: SortOrder
    assetId?: SortOrder
  }

  export type OT_EventMinOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    protocolo?: SortOrder
    srcIp?: SortOrder
    dstIp?: SortOrder
    funcao?: SortOrder
    valor?: SortOrder
    anomalia?: SortOrder
    assetId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SightingCountOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    count?: SortOrder
    indicatorId?: SortOrder
    assetId?: SortOrder
  }

  export type SightingAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type SightingMaxOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    count?: SortOrder
    indicatorId?: SortOrder
    assetId?: SortOrder
  }

  export type SightingMinOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    count?: SortOrder
    indicatorId?: SortOrder
    assetId?: SortOrder
  }

  export type SightingSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EvidenceListRelationFilter = {
    every?: EvidenceWhereInput
    some?: EvidenceWhereInput
    none?: EvidenceWhereInput
  }

  export type EvidenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaseCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    status?: SortOrder
    responsavel?: SortOrder
    criadoEm?: SortOrder
  }

  export type CaseMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    status?: SortOrder
    responsavel?: SortOrder
    criadoEm?: SortOrder
  }

  export type CaseMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    status?: SortOrder
    responsavel?: SortOrder
    criadoEm?: SortOrder
  }

  export type CaseScalarRelationFilter = {
    is?: CaseWhereInput
    isNot?: CaseWhereInput
  }

  export type CustodyListRelationFilter = {
    every?: CustodyWhereInput
    some?: CustodyWhereInput
    none?: CustodyWhereInput
  }

  export type CustodyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvidenceCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    caminho?: SortOrder
    hashSha256?: SortOrder
    coletadoEm?: SortOrder
    tamanho?: SortOrder
    caseId?: SortOrder
  }

  export type EvidenceAvgOrderByAggregateInput = {
    tamanho?: SortOrder
  }

  export type EvidenceMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    caminho?: SortOrder
    hashSha256?: SortOrder
    coletadoEm?: SortOrder
    tamanho?: SortOrder
    caseId?: SortOrder
  }

  export type EvidenceMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    caminho?: SortOrder
    hashSha256?: SortOrder
    coletadoEm?: SortOrder
    tamanho?: SortOrder
    caseId?: SortOrder
  }

  export type EvidenceSumOrderByAggregateInput = {
    tamanho?: SortOrder
  }

  export type EvidenceScalarRelationFilter = {
    is?: EvidenceWhereInput
    isNot?: EvidenceWhereInput
  }

  export type CustodyCountOrderByAggregateInput = {
    id?: SortOrder
    acao?: SortOrder
    ator?: SortOrder
    local?: SortOrder
    ts?: SortOrder
    assinatura?: SortOrder
    evidenceId?: SortOrder
  }

  export type CustodyMaxOrderByAggregateInput = {
    id?: SortOrder
    acao?: SortOrder
    ator?: SortOrder
    local?: SortOrder
    ts?: SortOrder
    assinatura?: SortOrder
    evidenceId?: SortOrder
  }

  export type CustodyMinOrderByAggregateInput = {
    id?: SortOrder
    acao?: SortOrder
    ator?: SortOrder
    local?: SortOrder
    ts?: SortOrder
    assinatura?: SortOrder
    evidenceId?: SortOrder
  }

  export type AttackScenarioCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    protocolo?: SortOrder
    tecnicaMITRE?: SortOrder
  }

  export type AttackScenarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    protocolo?: SortOrder
    tecnicaMITRE?: SortOrder
  }

  export type AttackScenarioMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    protocolo?: SortOrder
    tecnicaMITRE?: SortOrder
  }

  export type AttackScenarioScalarRelationFilter = {
    is?: AttackScenarioWhereInput
    isNot?: AttackScenarioWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AttackResultListRelationFilter = {
    every?: AttackResultWhereInput
    some?: AttackResultWhereInput
    none?: AttackResultWhereInput
  }

  export type AttackResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttackRunCountOrderByAggregateInput = {
    id?: SortOrder
    tsInicio?: SortOrder
    tsFim?: SortOrder
    status?: SortOrder
    scenarioId?: SortOrder
    userId?: SortOrder
    assetId?: SortOrder
  }

  export type AttackRunMaxOrderByAggregateInput = {
    id?: SortOrder
    tsInicio?: SortOrder
    tsFim?: SortOrder
    status?: SortOrder
    scenarioId?: SortOrder
    userId?: SortOrder
    assetId?: SortOrder
  }

  export type AttackRunMinOrderByAggregateInput = {
    id?: SortOrder
    tsInicio?: SortOrder
    tsFim?: SortOrder
    status?: SortOrder
    scenarioId?: SortOrder
    userId?: SortOrder
    assetId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AttackRunScalarRelationFilter = {
    is?: AttackRunWhereInput
    isNot?: AttackRunWhereInput
  }

  export type AttackResultCountOrderByAggregateInput = {
    id?: SortOrder
    sucesso?: SortOrder
    impacto?: SortOrder
    logs?: SortOrder
    iocsGerados?: SortOrder
    runId?: SortOrder
  }

  export type AttackResultMaxOrderByAggregateInput = {
    id?: SortOrder
    sucesso?: SortOrder
    impacto?: SortOrder
    logs?: SortOrder
    iocsGerados?: SortOrder
    runId?: SortOrder
  }

  export type AttackResultMinOrderByAggregateInput = {
    id?: SortOrder
    sucesso?: SortOrder
    impacto?: SortOrder
    logs?: SortOrder
    iocsGerados?: SortOrder
    runId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AttackRunCreateNestedManyWithoutUserInput = {
    create?: XOR<AttackRunCreateWithoutUserInput, AttackRunUncheckedCreateWithoutUserInput> | AttackRunCreateWithoutUserInput[] | AttackRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutUserInput | AttackRunCreateOrConnectWithoutUserInput[]
    createMany?: AttackRunCreateManyUserInputEnvelope
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
  }

  export type AttackRunUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttackRunCreateWithoutUserInput, AttackRunUncheckedCreateWithoutUserInput> | AttackRunCreateWithoutUserInput[] | AttackRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutUserInput | AttackRunCreateOrConnectWithoutUserInput[]
    createMany?: AttackRunCreateManyUserInputEnvelope
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type AttackRunUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttackRunCreateWithoutUserInput, AttackRunUncheckedCreateWithoutUserInput> | AttackRunCreateWithoutUserInput[] | AttackRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutUserInput | AttackRunCreateOrConnectWithoutUserInput[]
    upsert?: AttackRunUpsertWithWhereUniqueWithoutUserInput | AttackRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttackRunCreateManyUserInputEnvelope
    set?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    disconnect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    delete?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    update?: AttackRunUpdateWithWhereUniqueWithoutUserInput | AttackRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttackRunUpdateManyWithWhereWithoutUserInput | AttackRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttackRunScalarWhereInput | AttackRunScalarWhereInput[]
  }

  export type AttackRunUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttackRunCreateWithoutUserInput, AttackRunUncheckedCreateWithoutUserInput> | AttackRunCreateWithoutUserInput[] | AttackRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutUserInput | AttackRunCreateOrConnectWithoutUserInput[]
    upsert?: AttackRunUpsertWithWhereUniqueWithoutUserInput | AttackRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttackRunCreateManyUserInputEnvelope
    set?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    disconnect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    delete?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    update?: AttackRunUpdateWithWhereUniqueWithoutUserInput | AttackRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttackRunUpdateManyWithWhereWithoutUserInput | AttackRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttackRunScalarWhereInput | AttackRunScalarWhereInput[]
  }

  export type OT_EventCreateNestedManyWithoutAssetInput = {
    create?: XOR<OT_EventCreateWithoutAssetInput, OT_EventUncheckedCreateWithoutAssetInput> | OT_EventCreateWithoutAssetInput[] | OT_EventUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: OT_EventCreateOrConnectWithoutAssetInput | OT_EventCreateOrConnectWithoutAssetInput[]
    createMany?: OT_EventCreateManyAssetInputEnvelope
    connect?: OT_EventWhereUniqueInput | OT_EventWhereUniqueInput[]
  }

  export type SightingCreateNestedManyWithoutAssetInput = {
    create?: XOR<SightingCreateWithoutAssetInput, SightingUncheckedCreateWithoutAssetInput> | SightingCreateWithoutAssetInput[] | SightingUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: SightingCreateOrConnectWithoutAssetInput | SightingCreateOrConnectWithoutAssetInput[]
    createMany?: SightingCreateManyAssetInputEnvelope
    connect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
  }

  export type AttackRunCreateNestedManyWithoutAssetInput = {
    create?: XOR<AttackRunCreateWithoutAssetInput, AttackRunUncheckedCreateWithoutAssetInput> | AttackRunCreateWithoutAssetInput[] | AttackRunUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutAssetInput | AttackRunCreateOrConnectWithoutAssetInput[]
    createMany?: AttackRunCreateManyAssetInputEnvelope
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
  }

  export type OT_EventUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<OT_EventCreateWithoutAssetInput, OT_EventUncheckedCreateWithoutAssetInput> | OT_EventCreateWithoutAssetInput[] | OT_EventUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: OT_EventCreateOrConnectWithoutAssetInput | OT_EventCreateOrConnectWithoutAssetInput[]
    createMany?: OT_EventCreateManyAssetInputEnvelope
    connect?: OT_EventWhereUniqueInput | OT_EventWhereUniqueInput[]
  }

  export type SightingUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<SightingCreateWithoutAssetInput, SightingUncheckedCreateWithoutAssetInput> | SightingCreateWithoutAssetInput[] | SightingUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: SightingCreateOrConnectWithoutAssetInput | SightingCreateOrConnectWithoutAssetInput[]
    createMany?: SightingCreateManyAssetInputEnvelope
    connect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
  }

  export type AttackRunUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AttackRunCreateWithoutAssetInput, AttackRunUncheckedCreateWithoutAssetInput> | AttackRunCreateWithoutAssetInput[] | AttackRunUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutAssetInput | AttackRunCreateOrConnectWithoutAssetInput[]
    createMany?: AttackRunCreateManyAssetInputEnvelope
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OT_EventUpdateManyWithoutAssetNestedInput = {
    create?: XOR<OT_EventCreateWithoutAssetInput, OT_EventUncheckedCreateWithoutAssetInput> | OT_EventCreateWithoutAssetInput[] | OT_EventUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: OT_EventCreateOrConnectWithoutAssetInput | OT_EventCreateOrConnectWithoutAssetInput[]
    upsert?: OT_EventUpsertWithWhereUniqueWithoutAssetInput | OT_EventUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: OT_EventCreateManyAssetInputEnvelope
    set?: OT_EventWhereUniqueInput | OT_EventWhereUniqueInput[]
    disconnect?: OT_EventWhereUniqueInput | OT_EventWhereUniqueInput[]
    delete?: OT_EventWhereUniqueInput | OT_EventWhereUniqueInput[]
    connect?: OT_EventWhereUniqueInput | OT_EventWhereUniqueInput[]
    update?: OT_EventUpdateWithWhereUniqueWithoutAssetInput | OT_EventUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: OT_EventUpdateManyWithWhereWithoutAssetInput | OT_EventUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: OT_EventScalarWhereInput | OT_EventScalarWhereInput[]
  }

  export type SightingUpdateManyWithoutAssetNestedInput = {
    create?: XOR<SightingCreateWithoutAssetInput, SightingUncheckedCreateWithoutAssetInput> | SightingCreateWithoutAssetInput[] | SightingUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: SightingCreateOrConnectWithoutAssetInput | SightingCreateOrConnectWithoutAssetInput[]
    upsert?: SightingUpsertWithWhereUniqueWithoutAssetInput | SightingUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: SightingCreateManyAssetInputEnvelope
    set?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    disconnect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    delete?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    connect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    update?: SightingUpdateWithWhereUniqueWithoutAssetInput | SightingUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: SightingUpdateManyWithWhereWithoutAssetInput | SightingUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: SightingScalarWhereInput | SightingScalarWhereInput[]
  }

  export type AttackRunUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AttackRunCreateWithoutAssetInput, AttackRunUncheckedCreateWithoutAssetInput> | AttackRunCreateWithoutAssetInput[] | AttackRunUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutAssetInput | AttackRunCreateOrConnectWithoutAssetInput[]
    upsert?: AttackRunUpsertWithWhereUniqueWithoutAssetInput | AttackRunUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AttackRunCreateManyAssetInputEnvelope
    set?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    disconnect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    delete?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    update?: AttackRunUpdateWithWhereUniqueWithoutAssetInput | AttackRunUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AttackRunUpdateManyWithWhereWithoutAssetInput | AttackRunUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AttackRunScalarWhereInput | AttackRunScalarWhereInput[]
  }

  export type OT_EventUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<OT_EventCreateWithoutAssetInput, OT_EventUncheckedCreateWithoutAssetInput> | OT_EventCreateWithoutAssetInput[] | OT_EventUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: OT_EventCreateOrConnectWithoutAssetInput | OT_EventCreateOrConnectWithoutAssetInput[]
    upsert?: OT_EventUpsertWithWhereUniqueWithoutAssetInput | OT_EventUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: OT_EventCreateManyAssetInputEnvelope
    set?: OT_EventWhereUniqueInput | OT_EventWhereUniqueInput[]
    disconnect?: OT_EventWhereUniqueInput | OT_EventWhereUniqueInput[]
    delete?: OT_EventWhereUniqueInput | OT_EventWhereUniqueInput[]
    connect?: OT_EventWhereUniqueInput | OT_EventWhereUniqueInput[]
    update?: OT_EventUpdateWithWhereUniqueWithoutAssetInput | OT_EventUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: OT_EventUpdateManyWithWhereWithoutAssetInput | OT_EventUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: OT_EventScalarWhereInput | OT_EventScalarWhereInput[]
  }

  export type SightingUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<SightingCreateWithoutAssetInput, SightingUncheckedCreateWithoutAssetInput> | SightingCreateWithoutAssetInput[] | SightingUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: SightingCreateOrConnectWithoutAssetInput | SightingCreateOrConnectWithoutAssetInput[]
    upsert?: SightingUpsertWithWhereUniqueWithoutAssetInput | SightingUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: SightingCreateManyAssetInputEnvelope
    set?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    disconnect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    delete?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    connect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    update?: SightingUpdateWithWhereUniqueWithoutAssetInput | SightingUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: SightingUpdateManyWithWhereWithoutAssetInput | SightingUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: SightingScalarWhereInput | SightingScalarWhereInput[]
  }

  export type AttackRunUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AttackRunCreateWithoutAssetInput, AttackRunUncheckedCreateWithoutAssetInput> | AttackRunCreateWithoutAssetInput[] | AttackRunUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutAssetInput | AttackRunCreateOrConnectWithoutAssetInput[]
    upsert?: AttackRunUpsertWithWhereUniqueWithoutAssetInput | AttackRunUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AttackRunCreateManyAssetInputEnvelope
    set?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    disconnect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    delete?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    update?: AttackRunUpdateWithWhereUniqueWithoutAssetInput | AttackRunUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AttackRunUpdateManyWithWhereWithoutAssetInput | AttackRunUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AttackRunScalarWhereInput | AttackRunScalarWhereInput[]
  }

  export type SightingCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<SightingCreateWithoutIndicatorInput, SightingUncheckedCreateWithoutIndicatorInput> | SightingCreateWithoutIndicatorInput[] | SightingUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: SightingCreateOrConnectWithoutIndicatorInput | SightingCreateOrConnectWithoutIndicatorInput[]
    createMany?: SightingCreateManyIndicatorInputEnvelope
    connect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
  }

  export type IndicatorThreatCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<IndicatorThreatCreateWithoutIndicatorInput, IndicatorThreatUncheckedCreateWithoutIndicatorInput> | IndicatorThreatCreateWithoutIndicatorInput[] | IndicatorThreatUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorThreatCreateOrConnectWithoutIndicatorInput | IndicatorThreatCreateOrConnectWithoutIndicatorInput[]
    createMany?: IndicatorThreatCreateManyIndicatorInputEnvelope
    connect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
  }

  export type SightingUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<SightingCreateWithoutIndicatorInput, SightingUncheckedCreateWithoutIndicatorInput> | SightingCreateWithoutIndicatorInput[] | SightingUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: SightingCreateOrConnectWithoutIndicatorInput | SightingCreateOrConnectWithoutIndicatorInput[]
    createMany?: SightingCreateManyIndicatorInputEnvelope
    connect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
  }

  export type IndicatorThreatUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<IndicatorThreatCreateWithoutIndicatorInput, IndicatorThreatUncheckedCreateWithoutIndicatorInput> | IndicatorThreatCreateWithoutIndicatorInput[] | IndicatorThreatUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorThreatCreateOrConnectWithoutIndicatorInput | IndicatorThreatCreateOrConnectWithoutIndicatorInput[]
    createMany?: IndicatorThreatCreateManyIndicatorInputEnvelope
    connect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SightingUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<SightingCreateWithoutIndicatorInput, SightingUncheckedCreateWithoutIndicatorInput> | SightingCreateWithoutIndicatorInput[] | SightingUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: SightingCreateOrConnectWithoutIndicatorInput | SightingCreateOrConnectWithoutIndicatorInput[]
    upsert?: SightingUpsertWithWhereUniqueWithoutIndicatorInput | SightingUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: SightingCreateManyIndicatorInputEnvelope
    set?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    disconnect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    delete?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    connect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    update?: SightingUpdateWithWhereUniqueWithoutIndicatorInput | SightingUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: SightingUpdateManyWithWhereWithoutIndicatorInput | SightingUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: SightingScalarWhereInput | SightingScalarWhereInput[]
  }

  export type IndicatorThreatUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<IndicatorThreatCreateWithoutIndicatorInput, IndicatorThreatUncheckedCreateWithoutIndicatorInput> | IndicatorThreatCreateWithoutIndicatorInput[] | IndicatorThreatUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorThreatCreateOrConnectWithoutIndicatorInput | IndicatorThreatCreateOrConnectWithoutIndicatorInput[]
    upsert?: IndicatorThreatUpsertWithWhereUniqueWithoutIndicatorInput | IndicatorThreatUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: IndicatorThreatCreateManyIndicatorInputEnvelope
    set?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    disconnect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    delete?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    connect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    update?: IndicatorThreatUpdateWithWhereUniqueWithoutIndicatorInput | IndicatorThreatUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: IndicatorThreatUpdateManyWithWhereWithoutIndicatorInput | IndicatorThreatUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: IndicatorThreatScalarWhereInput | IndicatorThreatScalarWhereInput[]
  }

  export type SightingUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<SightingCreateWithoutIndicatorInput, SightingUncheckedCreateWithoutIndicatorInput> | SightingCreateWithoutIndicatorInput[] | SightingUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: SightingCreateOrConnectWithoutIndicatorInput | SightingCreateOrConnectWithoutIndicatorInput[]
    upsert?: SightingUpsertWithWhereUniqueWithoutIndicatorInput | SightingUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: SightingCreateManyIndicatorInputEnvelope
    set?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    disconnect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    delete?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    connect?: SightingWhereUniqueInput | SightingWhereUniqueInput[]
    update?: SightingUpdateWithWhereUniqueWithoutIndicatorInput | SightingUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: SightingUpdateManyWithWhereWithoutIndicatorInput | SightingUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: SightingScalarWhereInput | SightingScalarWhereInput[]
  }

  export type IndicatorThreatUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<IndicatorThreatCreateWithoutIndicatorInput, IndicatorThreatUncheckedCreateWithoutIndicatorInput> | IndicatorThreatCreateWithoutIndicatorInput[] | IndicatorThreatUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorThreatCreateOrConnectWithoutIndicatorInput | IndicatorThreatCreateOrConnectWithoutIndicatorInput[]
    upsert?: IndicatorThreatUpsertWithWhereUniqueWithoutIndicatorInput | IndicatorThreatUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: IndicatorThreatCreateManyIndicatorInputEnvelope
    set?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    disconnect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    delete?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    connect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    update?: IndicatorThreatUpdateWithWhereUniqueWithoutIndicatorInput | IndicatorThreatUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: IndicatorThreatUpdateManyWithWhereWithoutIndicatorInput | IndicatorThreatUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: IndicatorThreatScalarWhereInput | IndicatorThreatScalarWhereInput[]
  }

  export type IndicatorThreatCreateNestedManyWithoutThreatInput = {
    create?: XOR<IndicatorThreatCreateWithoutThreatInput, IndicatorThreatUncheckedCreateWithoutThreatInput> | IndicatorThreatCreateWithoutThreatInput[] | IndicatorThreatUncheckedCreateWithoutThreatInput[]
    connectOrCreate?: IndicatorThreatCreateOrConnectWithoutThreatInput | IndicatorThreatCreateOrConnectWithoutThreatInput[]
    createMany?: IndicatorThreatCreateManyThreatInputEnvelope
    connect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
  }

  export type IndicatorThreatUncheckedCreateNestedManyWithoutThreatInput = {
    create?: XOR<IndicatorThreatCreateWithoutThreatInput, IndicatorThreatUncheckedCreateWithoutThreatInput> | IndicatorThreatCreateWithoutThreatInput[] | IndicatorThreatUncheckedCreateWithoutThreatInput[]
    connectOrCreate?: IndicatorThreatCreateOrConnectWithoutThreatInput | IndicatorThreatCreateOrConnectWithoutThreatInput[]
    createMany?: IndicatorThreatCreateManyThreatInputEnvelope
    connect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
  }

  export type IndicatorThreatUpdateManyWithoutThreatNestedInput = {
    create?: XOR<IndicatorThreatCreateWithoutThreatInput, IndicatorThreatUncheckedCreateWithoutThreatInput> | IndicatorThreatCreateWithoutThreatInput[] | IndicatorThreatUncheckedCreateWithoutThreatInput[]
    connectOrCreate?: IndicatorThreatCreateOrConnectWithoutThreatInput | IndicatorThreatCreateOrConnectWithoutThreatInput[]
    upsert?: IndicatorThreatUpsertWithWhereUniqueWithoutThreatInput | IndicatorThreatUpsertWithWhereUniqueWithoutThreatInput[]
    createMany?: IndicatorThreatCreateManyThreatInputEnvelope
    set?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    disconnect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    delete?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    connect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    update?: IndicatorThreatUpdateWithWhereUniqueWithoutThreatInput | IndicatorThreatUpdateWithWhereUniqueWithoutThreatInput[]
    updateMany?: IndicatorThreatUpdateManyWithWhereWithoutThreatInput | IndicatorThreatUpdateManyWithWhereWithoutThreatInput[]
    deleteMany?: IndicatorThreatScalarWhereInput | IndicatorThreatScalarWhereInput[]
  }

  export type IndicatorThreatUncheckedUpdateManyWithoutThreatNestedInput = {
    create?: XOR<IndicatorThreatCreateWithoutThreatInput, IndicatorThreatUncheckedCreateWithoutThreatInput> | IndicatorThreatCreateWithoutThreatInput[] | IndicatorThreatUncheckedCreateWithoutThreatInput[]
    connectOrCreate?: IndicatorThreatCreateOrConnectWithoutThreatInput | IndicatorThreatCreateOrConnectWithoutThreatInput[]
    upsert?: IndicatorThreatUpsertWithWhereUniqueWithoutThreatInput | IndicatorThreatUpsertWithWhereUniqueWithoutThreatInput[]
    createMany?: IndicatorThreatCreateManyThreatInputEnvelope
    set?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    disconnect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    delete?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    connect?: IndicatorThreatWhereUniqueInput | IndicatorThreatWhereUniqueInput[]
    update?: IndicatorThreatUpdateWithWhereUniqueWithoutThreatInput | IndicatorThreatUpdateWithWhereUniqueWithoutThreatInput[]
    updateMany?: IndicatorThreatUpdateManyWithWhereWithoutThreatInput | IndicatorThreatUpdateManyWithWhereWithoutThreatInput[]
    deleteMany?: IndicatorThreatScalarWhereInput | IndicatorThreatScalarWhereInput[]
  }

  export type IndicatorCreateNestedOneWithoutThreatsInput = {
    create?: XOR<IndicatorCreateWithoutThreatsInput, IndicatorUncheckedCreateWithoutThreatsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutThreatsInput
    connect?: IndicatorWhereUniqueInput
  }

  export type ThreatEntityCreateNestedOneWithoutIndicatorsInput = {
    create?: XOR<ThreatEntityCreateWithoutIndicatorsInput, ThreatEntityUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: ThreatEntityCreateOrConnectWithoutIndicatorsInput
    connect?: ThreatEntityWhereUniqueInput
  }

  export type IndicatorUpdateOneRequiredWithoutThreatsNestedInput = {
    create?: XOR<IndicatorCreateWithoutThreatsInput, IndicatorUncheckedCreateWithoutThreatsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutThreatsInput
    upsert?: IndicatorUpsertWithoutThreatsInput
    connect?: IndicatorWhereUniqueInput
    update?: XOR<XOR<IndicatorUpdateToOneWithWhereWithoutThreatsInput, IndicatorUpdateWithoutThreatsInput>, IndicatorUncheckedUpdateWithoutThreatsInput>
  }

  export type ThreatEntityUpdateOneRequiredWithoutIndicatorsNestedInput = {
    create?: XOR<ThreatEntityCreateWithoutIndicatorsInput, ThreatEntityUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: ThreatEntityCreateOrConnectWithoutIndicatorsInput
    upsert?: ThreatEntityUpsertWithoutIndicatorsInput
    connect?: ThreatEntityWhereUniqueInput
    update?: XOR<XOR<ThreatEntityUpdateToOneWithWhereWithoutIndicatorsInput, ThreatEntityUpdateWithoutIndicatorsInput>, ThreatEntityUncheckedUpdateWithoutIndicatorsInput>
  }

  export type AssetCreateNestedOneWithoutEventsInput = {
    create?: XOR<AssetCreateWithoutEventsInput, AssetUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutEventsInput
    connect?: AssetWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type AssetUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<AssetCreateWithoutEventsInput, AssetUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutEventsInput
    upsert?: AssetUpsertWithoutEventsInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutEventsInput, AssetUpdateWithoutEventsInput>, AssetUncheckedUpdateWithoutEventsInput>
  }

  export type IndicatorCreateNestedOneWithoutSightingsInput = {
    create?: XOR<IndicatorCreateWithoutSightingsInput, IndicatorUncheckedCreateWithoutSightingsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutSightingsInput
    connect?: IndicatorWhereUniqueInput
  }

  export type AssetCreateNestedOneWithoutSightingsInput = {
    create?: XOR<AssetCreateWithoutSightingsInput, AssetUncheckedCreateWithoutSightingsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutSightingsInput
    connect?: AssetWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IndicatorUpdateOneRequiredWithoutSightingsNestedInput = {
    create?: XOR<IndicatorCreateWithoutSightingsInput, IndicatorUncheckedCreateWithoutSightingsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutSightingsInput
    upsert?: IndicatorUpsertWithoutSightingsInput
    connect?: IndicatorWhereUniqueInput
    update?: XOR<XOR<IndicatorUpdateToOneWithWhereWithoutSightingsInput, IndicatorUpdateWithoutSightingsInput>, IndicatorUncheckedUpdateWithoutSightingsInput>
  }

  export type AssetUpdateOneRequiredWithoutSightingsNestedInput = {
    create?: XOR<AssetCreateWithoutSightingsInput, AssetUncheckedCreateWithoutSightingsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutSightingsInput
    upsert?: AssetUpsertWithoutSightingsInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutSightingsInput, AssetUpdateWithoutSightingsInput>, AssetUncheckedUpdateWithoutSightingsInput>
  }

  export type EvidenceCreateNestedManyWithoutCaseInput = {
    create?: XOR<EvidenceCreateWithoutCaseInput, EvidenceUncheckedCreateWithoutCaseInput> | EvidenceCreateWithoutCaseInput[] | EvidenceUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutCaseInput | EvidenceCreateOrConnectWithoutCaseInput[]
    createMany?: EvidenceCreateManyCaseInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type EvidenceUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<EvidenceCreateWithoutCaseInput, EvidenceUncheckedCreateWithoutCaseInput> | EvidenceCreateWithoutCaseInput[] | EvidenceUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutCaseInput | EvidenceCreateOrConnectWithoutCaseInput[]
    createMany?: EvidenceCreateManyCaseInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type EvidenceUpdateManyWithoutCaseNestedInput = {
    create?: XOR<EvidenceCreateWithoutCaseInput, EvidenceUncheckedCreateWithoutCaseInput> | EvidenceCreateWithoutCaseInput[] | EvidenceUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutCaseInput | EvidenceCreateOrConnectWithoutCaseInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutCaseInput | EvidenceUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: EvidenceCreateManyCaseInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutCaseInput | EvidenceUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutCaseInput | EvidenceUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type EvidenceUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<EvidenceCreateWithoutCaseInput, EvidenceUncheckedCreateWithoutCaseInput> | EvidenceCreateWithoutCaseInput[] | EvidenceUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutCaseInput | EvidenceCreateOrConnectWithoutCaseInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutCaseInput | EvidenceUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: EvidenceCreateManyCaseInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutCaseInput | EvidenceUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutCaseInput | EvidenceUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type CaseCreateNestedOneWithoutEvidenciasInput = {
    create?: XOR<CaseCreateWithoutEvidenciasInput, CaseUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: CaseCreateOrConnectWithoutEvidenciasInput
    connect?: CaseWhereUniqueInput
  }

  export type CustodyCreateNestedManyWithoutEvidenceInput = {
    create?: XOR<CustodyCreateWithoutEvidenceInput, CustodyUncheckedCreateWithoutEvidenceInput> | CustodyCreateWithoutEvidenceInput[] | CustodyUncheckedCreateWithoutEvidenceInput[]
    connectOrCreate?: CustodyCreateOrConnectWithoutEvidenceInput | CustodyCreateOrConnectWithoutEvidenceInput[]
    createMany?: CustodyCreateManyEvidenceInputEnvelope
    connect?: CustodyWhereUniqueInput | CustodyWhereUniqueInput[]
  }

  export type CustodyUncheckedCreateNestedManyWithoutEvidenceInput = {
    create?: XOR<CustodyCreateWithoutEvidenceInput, CustodyUncheckedCreateWithoutEvidenceInput> | CustodyCreateWithoutEvidenceInput[] | CustodyUncheckedCreateWithoutEvidenceInput[]
    connectOrCreate?: CustodyCreateOrConnectWithoutEvidenceInput | CustodyCreateOrConnectWithoutEvidenceInput[]
    createMany?: CustodyCreateManyEvidenceInputEnvelope
    connect?: CustodyWhereUniqueInput | CustodyWhereUniqueInput[]
  }

  export type CaseUpdateOneRequiredWithoutEvidenciasNestedInput = {
    create?: XOR<CaseCreateWithoutEvidenciasInput, CaseUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: CaseCreateOrConnectWithoutEvidenciasInput
    upsert?: CaseUpsertWithoutEvidenciasInput
    connect?: CaseWhereUniqueInput
    update?: XOR<XOR<CaseUpdateToOneWithWhereWithoutEvidenciasInput, CaseUpdateWithoutEvidenciasInput>, CaseUncheckedUpdateWithoutEvidenciasInput>
  }

  export type CustodyUpdateManyWithoutEvidenceNestedInput = {
    create?: XOR<CustodyCreateWithoutEvidenceInput, CustodyUncheckedCreateWithoutEvidenceInput> | CustodyCreateWithoutEvidenceInput[] | CustodyUncheckedCreateWithoutEvidenceInput[]
    connectOrCreate?: CustodyCreateOrConnectWithoutEvidenceInput | CustodyCreateOrConnectWithoutEvidenceInput[]
    upsert?: CustodyUpsertWithWhereUniqueWithoutEvidenceInput | CustodyUpsertWithWhereUniqueWithoutEvidenceInput[]
    createMany?: CustodyCreateManyEvidenceInputEnvelope
    set?: CustodyWhereUniqueInput | CustodyWhereUniqueInput[]
    disconnect?: CustodyWhereUniqueInput | CustodyWhereUniqueInput[]
    delete?: CustodyWhereUniqueInput | CustodyWhereUniqueInput[]
    connect?: CustodyWhereUniqueInput | CustodyWhereUniqueInput[]
    update?: CustodyUpdateWithWhereUniqueWithoutEvidenceInput | CustodyUpdateWithWhereUniqueWithoutEvidenceInput[]
    updateMany?: CustodyUpdateManyWithWhereWithoutEvidenceInput | CustodyUpdateManyWithWhereWithoutEvidenceInput[]
    deleteMany?: CustodyScalarWhereInput | CustodyScalarWhereInput[]
  }

  export type CustodyUncheckedUpdateManyWithoutEvidenceNestedInput = {
    create?: XOR<CustodyCreateWithoutEvidenceInput, CustodyUncheckedCreateWithoutEvidenceInput> | CustodyCreateWithoutEvidenceInput[] | CustodyUncheckedCreateWithoutEvidenceInput[]
    connectOrCreate?: CustodyCreateOrConnectWithoutEvidenceInput | CustodyCreateOrConnectWithoutEvidenceInput[]
    upsert?: CustodyUpsertWithWhereUniqueWithoutEvidenceInput | CustodyUpsertWithWhereUniqueWithoutEvidenceInput[]
    createMany?: CustodyCreateManyEvidenceInputEnvelope
    set?: CustodyWhereUniqueInput | CustodyWhereUniqueInput[]
    disconnect?: CustodyWhereUniqueInput | CustodyWhereUniqueInput[]
    delete?: CustodyWhereUniqueInput | CustodyWhereUniqueInput[]
    connect?: CustodyWhereUniqueInput | CustodyWhereUniqueInput[]
    update?: CustodyUpdateWithWhereUniqueWithoutEvidenceInput | CustodyUpdateWithWhereUniqueWithoutEvidenceInput[]
    updateMany?: CustodyUpdateManyWithWhereWithoutEvidenceInput | CustodyUpdateManyWithWhereWithoutEvidenceInput[]
    deleteMany?: CustodyScalarWhereInput | CustodyScalarWhereInput[]
  }

  export type EvidenceCreateNestedOneWithoutCustodiesInput = {
    create?: XOR<EvidenceCreateWithoutCustodiesInput, EvidenceUncheckedCreateWithoutCustodiesInput>
    connectOrCreate?: EvidenceCreateOrConnectWithoutCustodiesInput
    connect?: EvidenceWhereUniqueInput
  }

  export type EvidenceUpdateOneRequiredWithoutCustodiesNestedInput = {
    create?: XOR<EvidenceCreateWithoutCustodiesInput, EvidenceUncheckedCreateWithoutCustodiesInput>
    connectOrCreate?: EvidenceCreateOrConnectWithoutCustodiesInput
    upsert?: EvidenceUpsertWithoutCustodiesInput
    connect?: EvidenceWhereUniqueInput
    update?: XOR<XOR<EvidenceUpdateToOneWithWhereWithoutCustodiesInput, EvidenceUpdateWithoutCustodiesInput>, EvidenceUncheckedUpdateWithoutCustodiesInput>
  }

  export type AttackRunCreateNestedManyWithoutScenarioInput = {
    create?: XOR<AttackRunCreateWithoutScenarioInput, AttackRunUncheckedCreateWithoutScenarioInput> | AttackRunCreateWithoutScenarioInput[] | AttackRunUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutScenarioInput | AttackRunCreateOrConnectWithoutScenarioInput[]
    createMany?: AttackRunCreateManyScenarioInputEnvelope
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
  }

  export type AttackRunUncheckedCreateNestedManyWithoutScenarioInput = {
    create?: XOR<AttackRunCreateWithoutScenarioInput, AttackRunUncheckedCreateWithoutScenarioInput> | AttackRunCreateWithoutScenarioInput[] | AttackRunUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutScenarioInput | AttackRunCreateOrConnectWithoutScenarioInput[]
    createMany?: AttackRunCreateManyScenarioInputEnvelope
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
  }

  export type AttackRunUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<AttackRunCreateWithoutScenarioInput, AttackRunUncheckedCreateWithoutScenarioInput> | AttackRunCreateWithoutScenarioInput[] | AttackRunUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutScenarioInput | AttackRunCreateOrConnectWithoutScenarioInput[]
    upsert?: AttackRunUpsertWithWhereUniqueWithoutScenarioInput | AttackRunUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: AttackRunCreateManyScenarioInputEnvelope
    set?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    disconnect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    delete?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    update?: AttackRunUpdateWithWhereUniqueWithoutScenarioInput | AttackRunUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: AttackRunUpdateManyWithWhereWithoutScenarioInput | AttackRunUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: AttackRunScalarWhereInput | AttackRunScalarWhereInput[]
  }

  export type AttackRunUncheckedUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<AttackRunCreateWithoutScenarioInput, AttackRunUncheckedCreateWithoutScenarioInput> | AttackRunCreateWithoutScenarioInput[] | AttackRunUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: AttackRunCreateOrConnectWithoutScenarioInput | AttackRunCreateOrConnectWithoutScenarioInput[]
    upsert?: AttackRunUpsertWithWhereUniqueWithoutScenarioInput | AttackRunUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: AttackRunCreateManyScenarioInputEnvelope
    set?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    disconnect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    delete?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    connect?: AttackRunWhereUniqueInput | AttackRunWhereUniqueInput[]
    update?: AttackRunUpdateWithWhereUniqueWithoutScenarioInput | AttackRunUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: AttackRunUpdateManyWithWhereWithoutScenarioInput | AttackRunUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: AttackRunScalarWhereInput | AttackRunScalarWhereInput[]
  }

  export type AttackScenarioCreateNestedOneWithoutRunsInput = {
    create?: XOR<AttackScenarioCreateWithoutRunsInput, AttackScenarioUncheckedCreateWithoutRunsInput>
    connectOrCreate?: AttackScenarioCreateOrConnectWithoutRunsInput
    connect?: AttackScenarioWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttackRunsInput = {
    create?: XOR<UserCreateWithoutAttackRunsInput, UserUncheckedCreateWithoutAttackRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttackRunsInput
    connect?: UserWhereUniqueInput
  }

  export type AssetCreateNestedOneWithoutAttackRunsInput = {
    create?: XOR<AssetCreateWithoutAttackRunsInput, AssetUncheckedCreateWithoutAttackRunsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAttackRunsInput
    connect?: AssetWhereUniqueInput
  }

  export type AttackResultCreateNestedManyWithoutRunInput = {
    create?: XOR<AttackResultCreateWithoutRunInput, AttackResultUncheckedCreateWithoutRunInput> | AttackResultCreateWithoutRunInput[] | AttackResultUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AttackResultCreateOrConnectWithoutRunInput | AttackResultCreateOrConnectWithoutRunInput[]
    createMany?: AttackResultCreateManyRunInputEnvelope
    connect?: AttackResultWhereUniqueInput | AttackResultWhereUniqueInput[]
  }

  export type AttackResultUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<AttackResultCreateWithoutRunInput, AttackResultUncheckedCreateWithoutRunInput> | AttackResultCreateWithoutRunInput[] | AttackResultUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AttackResultCreateOrConnectWithoutRunInput | AttackResultCreateOrConnectWithoutRunInput[]
    createMany?: AttackResultCreateManyRunInputEnvelope
    connect?: AttackResultWhereUniqueInput | AttackResultWhereUniqueInput[]
  }

  export type AttackScenarioUpdateOneRequiredWithoutRunsNestedInput = {
    create?: XOR<AttackScenarioCreateWithoutRunsInput, AttackScenarioUncheckedCreateWithoutRunsInput>
    connectOrCreate?: AttackScenarioCreateOrConnectWithoutRunsInput
    upsert?: AttackScenarioUpsertWithoutRunsInput
    connect?: AttackScenarioWhereUniqueInput
    update?: XOR<XOR<AttackScenarioUpdateToOneWithWhereWithoutRunsInput, AttackScenarioUpdateWithoutRunsInput>, AttackScenarioUncheckedUpdateWithoutRunsInput>
  }

  export type UserUpdateOneRequiredWithoutAttackRunsNestedInput = {
    create?: XOR<UserCreateWithoutAttackRunsInput, UserUncheckedCreateWithoutAttackRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttackRunsInput
    upsert?: UserUpsertWithoutAttackRunsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttackRunsInput, UserUpdateWithoutAttackRunsInput>, UserUncheckedUpdateWithoutAttackRunsInput>
  }

  export type AssetUpdateOneRequiredWithoutAttackRunsNestedInput = {
    create?: XOR<AssetCreateWithoutAttackRunsInput, AssetUncheckedCreateWithoutAttackRunsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAttackRunsInput
    upsert?: AssetUpsertWithoutAttackRunsInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutAttackRunsInput, AssetUpdateWithoutAttackRunsInput>, AssetUncheckedUpdateWithoutAttackRunsInput>
  }

  export type AttackResultUpdateManyWithoutRunNestedInput = {
    create?: XOR<AttackResultCreateWithoutRunInput, AttackResultUncheckedCreateWithoutRunInput> | AttackResultCreateWithoutRunInput[] | AttackResultUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AttackResultCreateOrConnectWithoutRunInput | AttackResultCreateOrConnectWithoutRunInput[]
    upsert?: AttackResultUpsertWithWhereUniqueWithoutRunInput | AttackResultUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: AttackResultCreateManyRunInputEnvelope
    set?: AttackResultWhereUniqueInput | AttackResultWhereUniqueInput[]
    disconnect?: AttackResultWhereUniqueInput | AttackResultWhereUniqueInput[]
    delete?: AttackResultWhereUniqueInput | AttackResultWhereUniqueInput[]
    connect?: AttackResultWhereUniqueInput | AttackResultWhereUniqueInput[]
    update?: AttackResultUpdateWithWhereUniqueWithoutRunInput | AttackResultUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: AttackResultUpdateManyWithWhereWithoutRunInput | AttackResultUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: AttackResultScalarWhereInput | AttackResultScalarWhereInput[]
  }

  export type AttackResultUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<AttackResultCreateWithoutRunInput, AttackResultUncheckedCreateWithoutRunInput> | AttackResultCreateWithoutRunInput[] | AttackResultUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AttackResultCreateOrConnectWithoutRunInput | AttackResultCreateOrConnectWithoutRunInput[]
    upsert?: AttackResultUpsertWithWhereUniqueWithoutRunInput | AttackResultUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: AttackResultCreateManyRunInputEnvelope
    set?: AttackResultWhereUniqueInput | AttackResultWhereUniqueInput[]
    disconnect?: AttackResultWhereUniqueInput | AttackResultWhereUniqueInput[]
    delete?: AttackResultWhereUniqueInput | AttackResultWhereUniqueInput[]
    connect?: AttackResultWhereUniqueInput | AttackResultWhereUniqueInput[]
    update?: AttackResultUpdateWithWhereUniqueWithoutRunInput | AttackResultUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: AttackResultUpdateManyWithWhereWithoutRunInput | AttackResultUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: AttackResultScalarWhereInput | AttackResultScalarWhereInput[]
  }

  export type AttackRunCreateNestedOneWithoutResultsInput = {
    create?: XOR<AttackRunCreateWithoutResultsInput, AttackRunUncheckedCreateWithoutResultsInput>
    connectOrCreate?: AttackRunCreateOrConnectWithoutResultsInput
    connect?: AttackRunWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AttackRunUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<AttackRunCreateWithoutResultsInput, AttackRunUncheckedCreateWithoutResultsInput>
    connectOrCreate?: AttackRunCreateOrConnectWithoutResultsInput
    upsert?: AttackRunUpsertWithoutResultsInput
    connect?: AttackRunWhereUniqueInput
    update?: XOR<XOR<AttackRunUpdateToOneWithWhereWithoutResultsInput, AttackRunUpdateWithoutResultsInput>, AttackRunUncheckedUpdateWithoutResultsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AttackRunCreateWithoutUserInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    scenario: AttackScenarioCreateNestedOneWithoutRunsInput
    asset: AssetCreateNestedOneWithoutAttackRunsInput
    results?: AttackResultCreateNestedManyWithoutRunInput
  }

  export type AttackRunUncheckedCreateWithoutUserInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    scenarioId: string
    assetId: string
    results?: AttackResultUncheckedCreateNestedManyWithoutRunInput
  }

  export type AttackRunCreateOrConnectWithoutUserInput = {
    where: AttackRunWhereUniqueInput
    create: XOR<AttackRunCreateWithoutUserInput, AttackRunUncheckedCreateWithoutUserInput>
  }

  export type AttackRunCreateManyUserInputEnvelope = {
    data: AttackRunCreateManyUserInput | AttackRunCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttackRunUpsertWithWhereUniqueWithoutUserInput = {
    where: AttackRunWhereUniqueInput
    update: XOR<AttackRunUpdateWithoutUserInput, AttackRunUncheckedUpdateWithoutUserInput>
    create: XOR<AttackRunCreateWithoutUserInput, AttackRunUncheckedCreateWithoutUserInput>
  }

  export type AttackRunUpdateWithWhereUniqueWithoutUserInput = {
    where: AttackRunWhereUniqueInput
    data: XOR<AttackRunUpdateWithoutUserInput, AttackRunUncheckedUpdateWithoutUserInput>
  }

  export type AttackRunUpdateManyWithWhereWithoutUserInput = {
    where: AttackRunScalarWhereInput
    data: XOR<AttackRunUpdateManyMutationInput, AttackRunUncheckedUpdateManyWithoutUserInput>
  }

  export type AttackRunScalarWhereInput = {
    AND?: AttackRunScalarWhereInput | AttackRunScalarWhereInput[]
    OR?: AttackRunScalarWhereInput[]
    NOT?: AttackRunScalarWhereInput | AttackRunScalarWhereInput[]
    id?: StringFilter<"AttackRun"> | string
    tsInicio?: DateTimeFilter<"AttackRun"> | Date | string
    tsFim?: DateTimeNullableFilter<"AttackRun"> | Date | string | null
    status?: StringNullableFilter<"AttackRun"> | string | null
    scenarioId?: StringFilter<"AttackRun"> | string
    userId?: StringFilter<"AttackRun"> | string
    assetId?: StringFilter<"AttackRun"> | string
  }

  export type OT_EventCreateWithoutAssetInput = {
    id?: string
    ts: Date | string
    protocolo: string
    srcIp?: string | null
    dstIp?: string | null
    funcao?: string | null
    valor?: string | null
    anomalia?: boolean | null
  }

  export type OT_EventUncheckedCreateWithoutAssetInput = {
    id?: string
    ts: Date | string
    protocolo: string
    srcIp?: string | null
    dstIp?: string | null
    funcao?: string | null
    valor?: string | null
    anomalia?: boolean | null
  }

  export type OT_EventCreateOrConnectWithoutAssetInput = {
    where: OT_EventWhereUniqueInput
    create: XOR<OT_EventCreateWithoutAssetInput, OT_EventUncheckedCreateWithoutAssetInput>
  }

  export type OT_EventCreateManyAssetInputEnvelope = {
    data: OT_EventCreateManyAssetInput | OT_EventCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type SightingCreateWithoutAssetInput = {
    id?: string
    ts: Date | string
    count?: number
    indicator: IndicatorCreateNestedOneWithoutSightingsInput
  }

  export type SightingUncheckedCreateWithoutAssetInput = {
    id?: string
    ts: Date | string
    count?: number
    indicatorId: string
  }

  export type SightingCreateOrConnectWithoutAssetInput = {
    where: SightingWhereUniqueInput
    create: XOR<SightingCreateWithoutAssetInput, SightingUncheckedCreateWithoutAssetInput>
  }

  export type SightingCreateManyAssetInputEnvelope = {
    data: SightingCreateManyAssetInput | SightingCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type AttackRunCreateWithoutAssetInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    scenario: AttackScenarioCreateNestedOneWithoutRunsInput
    user: UserCreateNestedOneWithoutAttackRunsInput
    results?: AttackResultCreateNestedManyWithoutRunInput
  }

  export type AttackRunUncheckedCreateWithoutAssetInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    scenarioId: string
    userId: string
    results?: AttackResultUncheckedCreateNestedManyWithoutRunInput
  }

  export type AttackRunCreateOrConnectWithoutAssetInput = {
    where: AttackRunWhereUniqueInput
    create: XOR<AttackRunCreateWithoutAssetInput, AttackRunUncheckedCreateWithoutAssetInput>
  }

  export type AttackRunCreateManyAssetInputEnvelope = {
    data: AttackRunCreateManyAssetInput | AttackRunCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type OT_EventUpsertWithWhereUniqueWithoutAssetInput = {
    where: OT_EventWhereUniqueInput
    update: XOR<OT_EventUpdateWithoutAssetInput, OT_EventUncheckedUpdateWithoutAssetInput>
    create: XOR<OT_EventCreateWithoutAssetInput, OT_EventUncheckedCreateWithoutAssetInput>
  }

  export type OT_EventUpdateWithWhereUniqueWithoutAssetInput = {
    where: OT_EventWhereUniqueInput
    data: XOR<OT_EventUpdateWithoutAssetInput, OT_EventUncheckedUpdateWithoutAssetInput>
  }

  export type OT_EventUpdateManyWithWhereWithoutAssetInput = {
    where: OT_EventScalarWhereInput
    data: XOR<OT_EventUpdateManyMutationInput, OT_EventUncheckedUpdateManyWithoutAssetInput>
  }

  export type OT_EventScalarWhereInput = {
    AND?: OT_EventScalarWhereInput | OT_EventScalarWhereInput[]
    OR?: OT_EventScalarWhereInput[]
    NOT?: OT_EventScalarWhereInput | OT_EventScalarWhereInput[]
    id?: StringFilter<"OT_Event"> | string
    ts?: DateTimeFilter<"OT_Event"> | Date | string
    protocolo?: StringFilter<"OT_Event"> | string
    srcIp?: StringNullableFilter<"OT_Event"> | string | null
    dstIp?: StringNullableFilter<"OT_Event"> | string | null
    funcao?: StringNullableFilter<"OT_Event"> | string | null
    valor?: StringNullableFilter<"OT_Event"> | string | null
    anomalia?: BoolNullableFilter<"OT_Event"> | boolean | null
    assetId?: StringFilter<"OT_Event"> | string
  }

  export type SightingUpsertWithWhereUniqueWithoutAssetInput = {
    where: SightingWhereUniqueInput
    update: XOR<SightingUpdateWithoutAssetInput, SightingUncheckedUpdateWithoutAssetInput>
    create: XOR<SightingCreateWithoutAssetInput, SightingUncheckedCreateWithoutAssetInput>
  }

  export type SightingUpdateWithWhereUniqueWithoutAssetInput = {
    where: SightingWhereUniqueInput
    data: XOR<SightingUpdateWithoutAssetInput, SightingUncheckedUpdateWithoutAssetInput>
  }

  export type SightingUpdateManyWithWhereWithoutAssetInput = {
    where: SightingScalarWhereInput
    data: XOR<SightingUpdateManyMutationInput, SightingUncheckedUpdateManyWithoutAssetInput>
  }

  export type SightingScalarWhereInput = {
    AND?: SightingScalarWhereInput | SightingScalarWhereInput[]
    OR?: SightingScalarWhereInput[]
    NOT?: SightingScalarWhereInput | SightingScalarWhereInput[]
    id?: StringFilter<"Sighting"> | string
    ts?: DateTimeFilter<"Sighting"> | Date | string
    count?: IntFilter<"Sighting"> | number
    indicatorId?: StringFilter<"Sighting"> | string
    assetId?: StringFilter<"Sighting"> | string
  }

  export type AttackRunUpsertWithWhereUniqueWithoutAssetInput = {
    where: AttackRunWhereUniqueInput
    update: XOR<AttackRunUpdateWithoutAssetInput, AttackRunUncheckedUpdateWithoutAssetInput>
    create: XOR<AttackRunCreateWithoutAssetInput, AttackRunUncheckedCreateWithoutAssetInput>
  }

  export type AttackRunUpdateWithWhereUniqueWithoutAssetInput = {
    where: AttackRunWhereUniqueInput
    data: XOR<AttackRunUpdateWithoutAssetInput, AttackRunUncheckedUpdateWithoutAssetInput>
  }

  export type AttackRunUpdateManyWithWhereWithoutAssetInput = {
    where: AttackRunScalarWhereInput
    data: XOR<AttackRunUpdateManyMutationInput, AttackRunUncheckedUpdateManyWithoutAssetInput>
  }

  export type SightingCreateWithoutIndicatorInput = {
    id?: string
    ts: Date | string
    count?: number
    asset: AssetCreateNestedOneWithoutSightingsInput
  }

  export type SightingUncheckedCreateWithoutIndicatorInput = {
    id?: string
    ts: Date | string
    count?: number
    assetId: string
  }

  export type SightingCreateOrConnectWithoutIndicatorInput = {
    where: SightingWhereUniqueInput
    create: XOR<SightingCreateWithoutIndicatorInput, SightingUncheckedCreateWithoutIndicatorInput>
  }

  export type SightingCreateManyIndicatorInputEnvelope = {
    data: SightingCreateManyIndicatorInput | SightingCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorThreatCreateWithoutIndicatorInput = {
    id?: string
    threat: ThreatEntityCreateNestedOneWithoutIndicatorsInput
  }

  export type IndicatorThreatUncheckedCreateWithoutIndicatorInput = {
    id?: string
    threatId: string
  }

  export type IndicatorThreatCreateOrConnectWithoutIndicatorInput = {
    where: IndicatorThreatWhereUniqueInput
    create: XOR<IndicatorThreatCreateWithoutIndicatorInput, IndicatorThreatUncheckedCreateWithoutIndicatorInput>
  }

  export type IndicatorThreatCreateManyIndicatorInputEnvelope = {
    data: IndicatorThreatCreateManyIndicatorInput | IndicatorThreatCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type SightingUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: SightingWhereUniqueInput
    update: XOR<SightingUpdateWithoutIndicatorInput, SightingUncheckedUpdateWithoutIndicatorInput>
    create: XOR<SightingCreateWithoutIndicatorInput, SightingUncheckedCreateWithoutIndicatorInput>
  }

  export type SightingUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: SightingWhereUniqueInput
    data: XOR<SightingUpdateWithoutIndicatorInput, SightingUncheckedUpdateWithoutIndicatorInput>
  }

  export type SightingUpdateManyWithWhereWithoutIndicatorInput = {
    where: SightingScalarWhereInput
    data: XOR<SightingUpdateManyMutationInput, SightingUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type IndicatorThreatUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: IndicatorThreatWhereUniqueInput
    update: XOR<IndicatorThreatUpdateWithoutIndicatorInput, IndicatorThreatUncheckedUpdateWithoutIndicatorInput>
    create: XOR<IndicatorThreatCreateWithoutIndicatorInput, IndicatorThreatUncheckedCreateWithoutIndicatorInput>
  }

  export type IndicatorThreatUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: IndicatorThreatWhereUniqueInput
    data: XOR<IndicatorThreatUpdateWithoutIndicatorInput, IndicatorThreatUncheckedUpdateWithoutIndicatorInput>
  }

  export type IndicatorThreatUpdateManyWithWhereWithoutIndicatorInput = {
    where: IndicatorThreatScalarWhereInput
    data: XOR<IndicatorThreatUpdateManyMutationInput, IndicatorThreatUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type IndicatorThreatScalarWhereInput = {
    AND?: IndicatorThreatScalarWhereInput | IndicatorThreatScalarWhereInput[]
    OR?: IndicatorThreatScalarWhereInput[]
    NOT?: IndicatorThreatScalarWhereInput | IndicatorThreatScalarWhereInput[]
    id?: StringFilter<"IndicatorThreat"> | string
    indicatorId?: StringFilter<"IndicatorThreat"> | string
    threatId?: StringFilter<"IndicatorThreat"> | string
  }

  export type IndicatorThreatCreateWithoutThreatInput = {
    id?: string
    indicator: IndicatorCreateNestedOneWithoutThreatsInput
  }

  export type IndicatorThreatUncheckedCreateWithoutThreatInput = {
    id?: string
    indicatorId: string
  }

  export type IndicatorThreatCreateOrConnectWithoutThreatInput = {
    where: IndicatorThreatWhereUniqueInput
    create: XOR<IndicatorThreatCreateWithoutThreatInput, IndicatorThreatUncheckedCreateWithoutThreatInput>
  }

  export type IndicatorThreatCreateManyThreatInputEnvelope = {
    data: IndicatorThreatCreateManyThreatInput | IndicatorThreatCreateManyThreatInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorThreatUpsertWithWhereUniqueWithoutThreatInput = {
    where: IndicatorThreatWhereUniqueInput
    update: XOR<IndicatorThreatUpdateWithoutThreatInput, IndicatorThreatUncheckedUpdateWithoutThreatInput>
    create: XOR<IndicatorThreatCreateWithoutThreatInput, IndicatorThreatUncheckedCreateWithoutThreatInput>
  }

  export type IndicatorThreatUpdateWithWhereUniqueWithoutThreatInput = {
    where: IndicatorThreatWhereUniqueInput
    data: XOR<IndicatorThreatUpdateWithoutThreatInput, IndicatorThreatUncheckedUpdateWithoutThreatInput>
  }

  export type IndicatorThreatUpdateManyWithWhereWithoutThreatInput = {
    where: IndicatorThreatScalarWhereInput
    data: XOR<IndicatorThreatUpdateManyMutationInput, IndicatorThreatUncheckedUpdateManyWithoutThreatInput>
  }

  export type IndicatorCreateWithoutThreatsInput = {
    id?: string
    tipo: string
    pattern: string
    severidade?: number | null
    fonte?: string | null
    validadeInicio?: Date | string | null
    validadeFim?: Date | string | null
    sightings?: SightingCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutThreatsInput = {
    id?: string
    tipo: string
    pattern: string
    severidade?: number | null
    fonte?: string | null
    validadeInicio?: Date | string | null
    validadeFim?: Date | string | null
    sightings?: SightingUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutThreatsInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutThreatsInput, IndicatorUncheckedCreateWithoutThreatsInput>
  }

  export type ThreatEntityCreateWithoutIndicatorsInput = {
    id?: string
    tipo: string
    nome: string
    descricao?: string | null
  }

  export type ThreatEntityUncheckedCreateWithoutIndicatorsInput = {
    id?: string
    tipo: string
    nome: string
    descricao?: string | null
  }

  export type ThreatEntityCreateOrConnectWithoutIndicatorsInput = {
    where: ThreatEntityWhereUniqueInput
    create: XOR<ThreatEntityCreateWithoutIndicatorsInput, ThreatEntityUncheckedCreateWithoutIndicatorsInput>
  }

  export type IndicatorUpsertWithoutThreatsInput = {
    update: XOR<IndicatorUpdateWithoutThreatsInput, IndicatorUncheckedUpdateWithoutThreatsInput>
    create: XOR<IndicatorCreateWithoutThreatsInput, IndicatorUncheckedCreateWithoutThreatsInput>
    where?: IndicatorWhereInput
  }

  export type IndicatorUpdateToOneWithWhereWithoutThreatsInput = {
    where?: IndicatorWhereInput
    data: XOR<IndicatorUpdateWithoutThreatsInput, IndicatorUncheckedUpdateWithoutThreatsInput>
  }

  export type IndicatorUpdateWithoutThreatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    severidade?: NullableIntFieldUpdateOperationsInput | number | null
    fonte?: NullableStringFieldUpdateOperationsInput | string | null
    validadeInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadeFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sightings?: SightingUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutThreatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    severidade?: NullableIntFieldUpdateOperationsInput | number | null
    fonte?: NullableStringFieldUpdateOperationsInput | string | null
    validadeInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadeFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sightings?: SightingUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type ThreatEntityUpsertWithoutIndicatorsInput = {
    update: XOR<ThreatEntityUpdateWithoutIndicatorsInput, ThreatEntityUncheckedUpdateWithoutIndicatorsInput>
    create: XOR<ThreatEntityCreateWithoutIndicatorsInput, ThreatEntityUncheckedCreateWithoutIndicatorsInput>
    where?: ThreatEntityWhereInput
  }

  export type ThreatEntityUpdateToOneWithWhereWithoutIndicatorsInput = {
    where?: ThreatEntityWhereInput
    data: XOR<ThreatEntityUpdateWithoutIndicatorsInput, ThreatEntityUncheckedUpdateWithoutIndicatorsInput>
  }

  export type ThreatEntityUpdateWithoutIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThreatEntityUncheckedUpdateWithoutIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetCreateWithoutEventsInput = {
    id?: string
    nome: string
    tipo: string
    fabricante?: string | null
    modelo?: string | null
    ip?: string | null
    zona?: string | null
    criticidade?: number | null
    sightings?: SightingCreateNestedManyWithoutAssetInput
    attackRuns?: AttackRunCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutEventsInput = {
    id?: string
    nome: string
    tipo: string
    fabricante?: string | null
    modelo?: string | null
    ip?: string | null
    zona?: string | null
    criticidade?: number | null
    sightings?: SightingUncheckedCreateNestedManyWithoutAssetInput
    attackRuns?: AttackRunUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutEventsInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutEventsInput, AssetUncheckedCreateWithoutEventsInput>
  }

  export type AssetUpsertWithoutEventsInput = {
    update: XOR<AssetUpdateWithoutEventsInput, AssetUncheckedUpdateWithoutEventsInput>
    create: XOR<AssetCreateWithoutEventsInput, AssetUncheckedCreateWithoutEventsInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutEventsInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutEventsInput, AssetUncheckedUpdateWithoutEventsInput>
  }

  export type AssetUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableStringFieldUpdateOperationsInput | string | null
    criticidade?: NullableIntFieldUpdateOperationsInput | number | null
    sightings?: SightingUpdateManyWithoutAssetNestedInput
    attackRuns?: AttackRunUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableStringFieldUpdateOperationsInput | string | null
    criticidade?: NullableIntFieldUpdateOperationsInput | number | null
    sightings?: SightingUncheckedUpdateManyWithoutAssetNestedInput
    attackRuns?: AttackRunUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type IndicatorCreateWithoutSightingsInput = {
    id?: string
    tipo: string
    pattern: string
    severidade?: number | null
    fonte?: string | null
    validadeInicio?: Date | string | null
    validadeFim?: Date | string | null
    threats?: IndicatorThreatCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutSightingsInput = {
    id?: string
    tipo: string
    pattern: string
    severidade?: number | null
    fonte?: string | null
    validadeInicio?: Date | string | null
    validadeFim?: Date | string | null
    threats?: IndicatorThreatUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutSightingsInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutSightingsInput, IndicatorUncheckedCreateWithoutSightingsInput>
  }

  export type AssetCreateWithoutSightingsInput = {
    id?: string
    nome: string
    tipo: string
    fabricante?: string | null
    modelo?: string | null
    ip?: string | null
    zona?: string | null
    criticidade?: number | null
    events?: OT_EventCreateNestedManyWithoutAssetInput
    attackRuns?: AttackRunCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutSightingsInput = {
    id?: string
    nome: string
    tipo: string
    fabricante?: string | null
    modelo?: string | null
    ip?: string | null
    zona?: string | null
    criticidade?: number | null
    events?: OT_EventUncheckedCreateNestedManyWithoutAssetInput
    attackRuns?: AttackRunUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutSightingsInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutSightingsInput, AssetUncheckedCreateWithoutSightingsInput>
  }

  export type IndicatorUpsertWithoutSightingsInput = {
    update: XOR<IndicatorUpdateWithoutSightingsInput, IndicatorUncheckedUpdateWithoutSightingsInput>
    create: XOR<IndicatorCreateWithoutSightingsInput, IndicatorUncheckedCreateWithoutSightingsInput>
    where?: IndicatorWhereInput
  }

  export type IndicatorUpdateToOneWithWhereWithoutSightingsInput = {
    where?: IndicatorWhereInput
    data: XOR<IndicatorUpdateWithoutSightingsInput, IndicatorUncheckedUpdateWithoutSightingsInput>
  }

  export type IndicatorUpdateWithoutSightingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    severidade?: NullableIntFieldUpdateOperationsInput | number | null
    fonte?: NullableStringFieldUpdateOperationsInput | string | null
    validadeInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadeFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    threats?: IndicatorThreatUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutSightingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    severidade?: NullableIntFieldUpdateOperationsInput | number | null
    fonte?: NullableStringFieldUpdateOperationsInput | string | null
    validadeInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validadeFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    threats?: IndicatorThreatUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type AssetUpsertWithoutSightingsInput = {
    update: XOR<AssetUpdateWithoutSightingsInput, AssetUncheckedUpdateWithoutSightingsInput>
    create: XOR<AssetCreateWithoutSightingsInput, AssetUncheckedCreateWithoutSightingsInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutSightingsInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutSightingsInput, AssetUncheckedUpdateWithoutSightingsInput>
  }

  export type AssetUpdateWithoutSightingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableStringFieldUpdateOperationsInput | string | null
    criticidade?: NullableIntFieldUpdateOperationsInput | number | null
    events?: OT_EventUpdateManyWithoutAssetNestedInput
    attackRuns?: AttackRunUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutSightingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableStringFieldUpdateOperationsInput | string | null
    criticidade?: NullableIntFieldUpdateOperationsInput | number | null
    events?: OT_EventUncheckedUpdateManyWithoutAssetNestedInput
    attackRuns?: AttackRunUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type EvidenceCreateWithoutCaseInput = {
    id?: string
    tipo: string
    caminho: string
    hashSha256: string
    coletadoEm?: Date | string
    tamanho?: number | null
    custodies?: CustodyCreateNestedManyWithoutEvidenceInput
  }

  export type EvidenceUncheckedCreateWithoutCaseInput = {
    id?: string
    tipo: string
    caminho: string
    hashSha256: string
    coletadoEm?: Date | string
    tamanho?: number | null
    custodies?: CustodyUncheckedCreateNestedManyWithoutEvidenceInput
  }

  export type EvidenceCreateOrConnectWithoutCaseInput = {
    where: EvidenceWhereUniqueInput
    create: XOR<EvidenceCreateWithoutCaseInput, EvidenceUncheckedCreateWithoutCaseInput>
  }

  export type EvidenceCreateManyCaseInputEnvelope = {
    data: EvidenceCreateManyCaseInput | EvidenceCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type EvidenceUpsertWithWhereUniqueWithoutCaseInput = {
    where: EvidenceWhereUniqueInput
    update: XOR<EvidenceUpdateWithoutCaseInput, EvidenceUncheckedUpdateWithoutCaseInput>
    create: XOR<EvidenceCreateWithoutCaseInput, EvidenceUncheckedCreateWithoutCaseInput>
  }

  export type EvidenceUpdateWithWhereUniqueWithoutCaseInput = {
    where: EvidenceWhereUniqueInput
    data: XOR<EvidenceUpdateWithoutCaseInput, EvidenceUncheckedUpdateWithoutCaseInput>
  }

  export type EvidenceUpdateManyWithWhereWithoutCaseInput = {
    where: EvidenceScalarWhereInput
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyWithoutCaseInput>
  }

  export type EvidenceScalarWhereInput = {
    AND?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
    OR?: EvidenceScalarWhereInput[]
    NOT?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
    id?: StringFilter<"Evidence"> | string
    tipo?: StringFilter<"Evidence"> | string
    caminho?: StringFilter<"Evidence"> | string
    hashSha256?: StringFilter<"Evidence"> | string
    coletadoEm?: DateTimeFilter<"Evidence"> | Date | string
    tamanho?: IntNullableFilter<"Evidence"> | number | null
    caseId?: StringFilter<"Evidence"> | string
  }

  export type CaseCreateWithoutEvidenciasInput = {
    id?: string
    titulo: string
    status: string
    responsavel?: string | null
    criadoEm?: Date | string
  }

  export type CaseUncheckedCreateWithoutEvidenciasInput = {
    id?: string
    titulo: string
    status: string
    responsavel?: string | null
    criadoEm?: Date | string
  }

  export type CaseCreateOrConnectWithoutEvidenciasInput = {
    where: CaseWhereUniqueInput
    create: XOR<CaseCreateWithoutEvidenciasInput, CaseUncheckedCreateWithoutEvidenciasInput>
  }

  export type CustodyCreateWithoutEvidenceInput = {
    id?: string
    acao: string
    ator: string
    local?: string | null
    ts: Date | string
    assinatura?: string | null
  }

  export type CustodyUncheckedCreateWithoutEvidenceInput = {
    id?: string
    acao: string
    ator: string
    local?: string | null
    ts: Date | string
    assinatura?: string | null
  }

  export type CustodyCreateOrConnectWithoutEvidenceInput = {
    where: CustodyWhereUniqueInput
    create: XOR<CustodyCreateWithoutEvidenceInput, CustodyUncheckedCreateWithoutEvidenceInput>
  }

  export type CustodyCreateManyEvidenceInputEnvelope = {
    data: CustodyCreateManyEvidenceInput | CustodyCreateManyEvidenceInput[]
    skipDuplicates?: boolean
  }

  export type CaseUpsertWithoutEvidenciasInput = {
    update: XOR<CaseUpdateWithoutEvidenciasInput, CaseUncheckedUpdateWithoutEvidenciasInput>
    create: XOR<CaseCreateWithoutEvidenciasInput, CaseUncheckedCreateWithoutEvidenciasInput>
    where?: CaseWhereInput
  }

  export type CaseUpdateToOneWithWhereWithoutEvidenciasInput = {
    where?: CaseWhereInput
    data: XOR<CaseUpdateWithoutEvidenciasInput, CaseUncheckedUpdateWithoutEvidenciasInput>
  }

  export type CaseUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseUncheckedUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustodyUpsertWithWhereUniqueWithoutEvidenceInput = {
    where: CustodyWhereUniqueInput
    update: XOR<CustodyUpdateWithoutEvidenceInput, CustodyUncheckedUpdateWithoutEvidenceInput>
    create: XOR<CustodyCreateWithoutEvidenceInput, CustodyUncheckedCreateWithoutEvidenceInput>
  }

  export type CustodyUpdateWithWhereUniqueWithoutEvidenceInput = {
    where: CustodyWhereUniqueInput
    data: XOR<CustodyUpdateWithoutEvidenceInput, CustodyUncheckedUpdateWithoutEvidenceInput>
  }

  export type CustodyUpdateManyWithWhereWithoutEvidenceInput = {
    where: CustodyScalarWhereInput
    data: XOR<CustodyUpdateManyMutationInput, CustodyUncheckedUpdateManyWithoutEvidenceInput>
  }

  export type CustodyScalarWhereInput = {
    AND?: CustodyScalarWhereInput | CustodyScalarWhereInput[]
    OR?: CustodyScalarWhereInput[]
    NOT?: CustodyScalarWhereInput | CustodyScalarWhereInput[]
    id?: StringFilter<"Custody"> | string
    acao?: StringFilter<"Custody"> | string
    ator?: StringFilter<"Custody"> | string
    local?: StringNullableFilter<"Custody"> | string | null
    ts?: DateTimeFilter<"Custody"> | Date | string
    assinatura?: StringNullableFilter<"Custody"> | string | null
    evidenceId?: StringFilter<"Custody"> | string
  }

  export type EvidenceCreateWithoutCustodiesInput = {
    id?: string
    tipo: string
    caminho: string
    hashSha256: string
    coletadoEm?: Date | string
    tamanho?: number | null
    case: CaseCreateNestedOneWithoutEvidenciasInput
  }

  export type EvidenceUncheckedCreateWithoutCustodiesInput = {
    id?: string
    tipo: string
    caminho: string
    hashSha256: string
    coletadoEm?: Date | string
    tamanho?: number | null
    caseId: string
  }

  export type EvidenceCreateOrConnectWithoutCustodiesInput = {
    where: EvidenceWhereUniqueInput
    create: XOR<EvidenceCreateWithoutCustodiesInput, EvidenceUncheckedCreateWithoutCustodiesInput>
  }

  export type EvidenceUpsertWithoutCustodiesInput = {
    update: XOR<EvidenceUpdateWithoutCustodiesInput, EvidenceUncheckedUpdateWithoutCustodiesInput>
    create: XOR<EvidenceCreateWithoutCustodiesInput, EvidenceUncheckedCreateWithoutCustodiesInput>
    where?: EvidenceWhereInput
  }

  export type EvidenceUpdateToOneWithWhereWithoutCustodiesInput = {
    where?: EvidenceWhereInput
    data: XOR<EvidenceUpdateWithoutCustodiesInput, EvidenceUncheckedUpdateWithoutCustodiesInput>
  }

  export type EvidenceUpdateWithoutCustodiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    caminho?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    coletadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tamanho?: NullableIntFieldUpdateOperationsInput | number | null
    case?: CaseUpdateOneRequiredWithoutEvidenciasNestedInput
  }

  export type EvidenceUncheckedUpdateWithoutCustodiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    caminho?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    coletadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tamanho?: NullableIntFieldUpdateOperationsInput | number | null
    caseId?: StringFieldUpdateOperationsInput | string
  }

  export type AttackRunCreateWithoutScenarioInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    user: UserCreateNestedOneWithoutAttackRunsInput
    asset: AssetCreateNestedOneWithoutAttackRunsInput
    results?: AttackResultCreateNestedManyWithoutRunInput
  }

  export type AttackRunUncheckedCreateWithoutScenarioInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    userId: string
    assetId: string
    results?: AttackResultUncheckedCreateNestedManyWithoutRunInput
  }

  export type AttackRunCreateOrConnectWithoutScenarioInput = {
    where: AttackRunWhereUniqueInput
    create: XOR<AttackRunCreateWithoutScenarioInput, AttackRunUncheckedCreateWithoutScenarioInput>
  }

  export type AttackRunCreateManyScenarioInputEnvelope = {
    data: AttackRunCreateManyScenarioInput | AttackRunCreateManyScenarioInput[]
    skipDuplicates?: boolean
  }

  export type AttackRunUpsertWithWhereUniqueWithoutScenarioInput = {
    where: AttackRunWhereUniqueInput
    update: XOR<AttackRunUpdateWithoutScenarioInput, AttackRunUncheckedUpdateWithoutScenarioInput>
    create: XOR<AttackRunCreateWithoutScenarioInput, AttackRunUncheckedCreateWithoutScenarioInput>
  }

  export type AttackRunUpdateWithWhereUniqueWithoutScenarioInput = {
    where: AttackRunWhereUniqueInput
    data: XOR<AttackRunUpdateWithoutScenarioInput, AttackRunUncheckedUpdateWithoutScenarioInput>
  }

  export type AttackRunUpdateManyWithWhereWithoutScenarioInput = {
    where: AttackRunScalarWhereInput
    data: XOR<AttackRunUpdateManyMutationInput, AttackRunUncheckedUpdateManyWithoutScenarioInput>
  }

  export type AttackScenarioCreateWithoutRunsInput = {
    id?: string
    nome: string
    descricao?: string | null
    protocolo?: string | null
    tecnicaMITRE?: string | null
  }

  export type AttackScenarioUncheckedCreateWithoutRunsInput = {
    id?: string
    nome: string
    descricao?: string | null
    protocolo?: string | null
    tecnicaMITRE?: string | null
  }

  export type AttackScenarioCreateOrConnectWithoutRunsInput = {
    where: AttackScenarioWhereUniqueInput
    create: XOR<AttackScenarioCreateWithoutRunsInput, AttackScenarioUncheckedCreateWithoutRunsInput>
  }

  export type UserCreateWithoutAttackRunsInput = {
    id?: string
    nome: string
    email: string
    papel: string
    senhaHash: string
  }

  export type UserUncheckedCreateWithoutAttackRunsInput = {
    id?: string
    nome: string
    email: string
    papel: string
    senhaHash: string
  }

  export type UserCreateOrConnectWithoutAttackRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttackRunsInput, UserUncheckedCreateWithoutAttackRunsInput>
  }

  export type AssetCreateWithoutAttackRunsInput = {
    id?: string
    nome: string
    tipo: string
    fabricante?: string | null
    modelo?: string | null
    ip?: string | null
    zona?: string | null
    criticidade?: number | null
    events?: OT_EventCreateNestedManyWithoutAssetInput
    sightings?: SightingCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutAttackRunsInput = {
    id?: string
    nome: string
    tipo: string
    fabricante?: string | null
    modelo?: string | null
    ip?: string | null
    zona?: string | null
    criticidade?: number | null
    events?: OT_EventUncheckedCreateNestedManyWithoutAssetInput
    sightings?: SightingUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutAttackRunsInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutAttackRunsInput, AssetUncheckedCreateWithoutAttackRunsInput>
  }

  export type AttackResultCreateWithoutRunInput = {
    id?: string
    sucesso: boolean
    impacto?: string | null
    logs?: string | null
    iocsGerados?: string | null
  }

  export type AttackResultUncheckedCreateWithoutRunInput = {
    id?: string
    sucesso: boolean
    impacto?: string | null
    logs?: string | null
    iocsGerados?: string | null
  }

  export type AttackResultCreateOrConnectWithoutRunInput = {
    where: AttackResultWhereUniqueInput
    create: XOR<AttackResultCreateWithoutRunInput, AttackResultUncheckedCreateWithoutRunInput>
  }

  export type AttackResultCreateManyRunInputEnvelope = {
    data: AttackResultCreateManyRunInput | AttackResultCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type AttackScenarioUpsertWithoutRunsInput = {
    update: XOR<AttackScenarioUpdateWithoutRunsInput, AttackScenarioUncheckedUpdateWithoutRunsInput>
    create: XOR<AttackScenarioCreateWithoutRunsInput, AttackScenarioUncheckedCreateWithoutRunsInput>
    where?: AttackScenarioWhereInput
  }

  export type AttackScenarioUpdateToOneWithWhereWithoutRunsInput = {
    where?: AttackScenarioWhereInput
    data: XOR<AttackScenarioUpdateWithoutRunsInput, AttackScenarioUncheckedUpdateWithoutRunsInput>
  }

  export type AttackScenarioUpdateWithoutRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicaMITRE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttackScenarioUncheckedUpdateWithoutRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicaMITRE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutAttackRunsInput = {
    update: XOR<UserUpdateWithoutAttackRunsInput, UserUncheckedUpdateWithoutAttackRunsInput>
    create: XOR<UserCreateWithoutAttackRunsInput, UserUncheckedCreateWithoutAttackRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttackRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttackRunsInput, UserUncheckedUpdateWithoutAttackRunsInput>
  }

  export type UserUpdateWithoutAttackRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateWithoutAttackRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
  }

  export type AssetUpsertWithoutAttackRunsInput = {
    update: XOR<AssetUpdateWithoutAttackRunsInput, AssetUncheckedUpdateWithoutAttackRunsInput>
    create: XOR<AssetCreateWithoutAttackRunsInput, AssetUncheckedCreateWithoutAttackRunsInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutAttackRunsInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutAttackRunsInput, AssetUncheckedUpdateWithoutAttackRunsInput>
  }

  export type AssetUpdateWithoutAttackRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableStringFieldUpdateOperationsInput | string | null
    criticidade?: NullableIntFieldUpdateOperationsInput | number | null
    events?: OT_EventUpdateManyWithoutAssetNestedInput
    sightings?: SightingUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutAttackRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableStringFieldUpdateOperationsInput | string | null
    criticidade?: NullableIntFieldUpdateOperationsInput | number | null
    events?: OT_EventUncheckedUpdateManyWithoutAssetNestedInput
    sightings?: SightingUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AttackResultUpsertWithWhereUniqueWithoutRunInput = {
    where: AttackResultWhereUniqueInput
    update: XOR<AttackResultUpdateWithoutRunInput, AttackResultUncheckedUpdateWithoutRunInput>
    create: XOR<AttackResultCreateWithoutRunInput, AttackResultUncheckedCreateWithoutRunInput>
  }

  export type AttackResultUpdateWithWhereUniqueWithoutRunInput = {
    where: AttackResultWhereUniqueInput
    data: XOR<AttackResultUpdateWithoutRunInput, AttackResultUncheckedUpdateWithoutRunInput>
  }

  export type AttackResultUpdateManyWithWhereWithoutRunInput = {
    where: AttackResultScalarWhereInput
    data: XOR<AttackResultUpdateManyMutationInput, AttackResultUncheckedUpdateManyWithoutRunInput>
  }

  export type AttackResultScalarWhereInput = {
    AND?: AttackResultScalarWhereInput | AttackResultScalarWhereInput[]
    OR?: AttackResultScalarWhereInput[]
    NOT?: AttackResultScalarWhereInput | AttackResultScalarWhereInput[]
    id?: StringFilter<"AttackResult"> | string
    sucesso?: BoolFilter<"AttackResult"> | boolean
    impacto?: StringNullableFilter<"AttackResult"> | string | null
    logs?: StringNullableFilter<"AttackResult"> | string | null
    iocsGerados?: StringNullableFilter<"AttackResult"> | string | null
    runId?: StringFilter<"AttackResult"> | string
  }

  export type AttackRunCreateWithoutResultsInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    scenario: AttackScenarioCreateNestedOneWithoutRunsInput
    user: UserCreateNestedOneWithoutAttackRunsInput
    asset: AssetCreateNestedOneWithoutAttackRunsInput
  }

  export type AttackRunUncheckedCreateWithoutResultsInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    scenarioId: string
    userId: string
    assetId: string
  }

  export type AttackRunCreateOrConnectWithoutResultsInput = {
    where: AttackRunWhereUniqueInput
    create: XOR<AttackRunCreateWithoutResultsInput, AttackRunUncheckedCreateWithoutResultsInput>
  }

  export type AttackRunUpsertWithoutResultsInput = {
    update: XOR<AttackRunUpdateWithoutResultsInput, AttackRunUncheckedUpdateWithoutResultsInput>
    create: XOR<AttackRunCreateWithoutResultsInput, AttackRunUncheckedCreateWithoutResultsInput>
    where?: AttackRunWhereInput
  }

  export type AttackRunUpdateToOneWithWhereWithoutResultsInput = {
    where?: AttackRunWhereInput
    data: XOR<AttackRunUpdateWithoutResultsInput, AttackRunUncheckedUpdateWithoutResultsInput>
  }

  export type AttackRunUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    scenario?: AttackScenarioUpdateOneRequiredWithoutRunsNestedInput
    user?: UserUpdateOneRequiredWithoutAttackRunsNestedInput
    asset?: AssetUpdateOneRequiredWithoutAttackRunsNestedInput
  }

  export type AttackRunUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
  }

  export type AttackRunCreateManyUserInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    scenarioId: string
    assetId: string
  }

  export type AttackRunUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    scenario?: AttackScenarioUpdateOneRequiredWithoutRunsNestedInput
    asset?: AssetUpdateOneRequiredWithoutAttackRunsNestedInput
    results?: AttackResultUpdateManyWithoutRunNestedInput
  }

  export type AttackRunUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioId?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    results?: AttackResultUncheckedUpdateManyWithoutRunNestedInput
  }

  export type AttackRunUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioId?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
  }

  export type OT_EventCreateManyAssetInput = {
    id?: string
    ts: Date | string
    protocolo: string
    srcIp?: string | null
    dstIp?: string | null
    funcao?: string | null
    valor?: string | null
    anomalia?: boolean | null
  }

  export type SightingCreateManyAssetInput = {
    id?: string
    ts: Date | string
    count?: number
    indicatorId: string
  }

  export type AttackRunCreateManyAssetInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    scenarioId: string
    userId: string
  }

  export type OT_EventUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolo?: StringFieldUpdateOperationsInput | string
    srcIp?: NullableStringFieldUpdateOperationsInput | string | null
    dstIp?: NullableStringFieldUpdateOperationsInput | string | null
    funcao?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    anomalia?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OT_EventUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolo?: StringFieldUpdateOperationsInput | string
    srcIp?: NullableStringFieldUpdateOperationsInput | string | null
    dstIp?: NullableStringFieldUpdateOperationsInput | string | null
    funcao?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    anomalia?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OT_EventUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolo?: StringFieldUpdateOperationsInput | string
    srcIp?: NullableStringFieldUpdateOperationsInput | string | null
    dstIp?: NullableStringFieldUpdateOperationsInput | string | null
    funcao?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    anomalia?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SightingUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    indicator?: IndicatorUpdateOneRequiredWithoutSightingsNestedInput
  }

  export type SightingUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    indicatorId?: StringFieldUpdateOperationsInput | string
  }

  export type SightingUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    indicatorId?: StringFieldUpdateOperationsInput | string
  }

  export type AttackRunUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    scenario?: AttackScenarioUpdateOneRequiredWithoutRunsNestedInput
    user?: UserUpdateOneRequiredWithoutAttackRunsNestedInput
    results?: AttackResultUpdateManyWithoutRunNestedInput
  }

  export type AttackRunUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    results?: AttackResultUncheckedUpdateManyWithoutRunNestedInput
  }

  export type AttackRunUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SightingCreateManyIndicatorInput = {
    id?: string
    ts: Date | string
    count?: number
    assetId: string
  }

  export type IndicatorThreatCreateManyIndicatorInput = {
    id?: string
    threatId: string
  }

  export type SightingUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    asset?: AssetUpdateOneRequiredWithoutSightingsNestedInput
  }

  export type SightingUncheckedUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    assetId?: StringFieldUpdateOperationsInput | string
  }

  export type SightingUncheckedUpdateManyWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    assetId?: StringFieldUpdateOperationsInput | string
  }

  export type IndicatorThreatUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    threat?: ThreatEntityUpdateOneRequiredWithoutIndicatorsNestedInput
  }

  export type IndicatorThreatUncheckedUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatId?: StringFieldUpdateOperationsInput | string
  }

  export type IndicatorThreatUncheckedUpdateManyWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatId?: StringFieldUpdateOperationsInput | string
  }

  export type IndicatorThreatCreateManyThreatInput = {
    id?: string
    indicatorId: string
  }

  export type IndicatorThreatUpdateWithoutThreatInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicator?: IndicatorUpdateOneRequiredWithoutThreatsNestedInput
  }

  export type IndicatorThreatUncheckedUpdateWithoutThreatInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
  }

  export type IndicatorThreatUncheckedUpdateManyWithoutThreatInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicatorId?: StringFieldUpdateOperationsInput | string
  }

  export type EvidenceCreateManyCaseInput = {
    id?: string
    tipo: string
    caminho: string
    hashSha256: string
    coletadoEm?: Date | string
    tamanho?: number | null
  }

  export type EvidenceUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    caminho?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    coletadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tamanho?: NullableIntFieldUpdateOperationsInput | number | null
    custodies?: CustodyUpdateManyWithoutEvidenceNestedInput
  }

  export type EvidenceUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    caminho?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    coletadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tamanho?: NullableIntFieldUpdateOperationsInput | number | null
    custodies?: CustodyUncheckedUpdateManyWithoutEvidenceNestedInput
  }

  export type EvidenceUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    caminho?: StringFieldUpdateOperationsInput | string
    hashSha256?: StringFieldUpdateOperationsInput | string
    coletadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tamanho?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CustodyCreateManyEvidenceInput = {
    id?: string
    acao: string
    ator: string
    local?: string | null
    ts: Date | string
    assinatura?: string | null
  }

  export type CustodyUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    acao?: StringFieldUpdateOperationsInput | string
    ator?: StringFieldUpdateOperationsInput | string
    local?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    assinatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustodyUncheckedUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    acao?: StringFieldUpdateOperationsInput | string
    ator?: StringFieldUpdateOperationsInput | string
    local?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    assinatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustodyUncheckedUpdateManyWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    acao?: StringFieldUpdateOperationsInput | string
    ator?: StringFieldUpdateOperationsInput | string
    local?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    assinatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttackRunCreateManyScenarioInput = {
    id?: string
    tsInicio: Date | string
    tsFim?: Date | string | null
    status?: string | null
    userId: string
    assetId: string
  }

  export type AttackRunUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAttackRunsNestedInput
    asset?: AssetUpdateOneRequiredWithoutAttackRunsNestedInput
    results?: AttackResultUpdateManyWithoutRunNestedInput
  }

  export type AttackRunUncheckedUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    results?: AttackResultUncheckedUpdateManyWithoutRunNestedInput
  }

  export type AttackRunUncheckedUpdateManyWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tsInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    tsFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
  }

  export type AttackResultCreateManyRunInput = {
    id?: string
    sucesso: boolean
    impacto?: string | null
    logs?: string | null
    iocsGerados?: string | null
  }

  export type AttackResultUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    sucesso?: BoolFieldUpdateOperationsInput | boolean
    impacto?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    iocsGerados?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttackResultUncheckedUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    sucesso?: BoolFieldUpdateOperationsInput | boolean
    impacto?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    iocsGerados?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttackResultUncheckedUpdateManyWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    sucesso?: BoolFieldUpdateOperationsInput | boolean
    impacto?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    iocsGerados?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}